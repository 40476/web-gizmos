<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <link rel="icon" type="image/png" href="img/amogus.png">
    <title>Mega Miner Online</title>
    <!-- TODO: move this to a shared dir for the other programs -->
    <script src="lib/mqtt.min.js"></script>
    <script src="lib/puter-v2.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Geo');
        @import url('https://fonts.googleapis.com/css2?family=Danfo');

        /* CSS Reset & Normalization */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            outline: none;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        /* Only disable touch on game specific elements so UI can still scroll */
        canvas, #mobile-controls, .d-btn, .act-btn { touch-action: none; }

        :root {
            /* --- COLOR PALETTE --- */
            --bg-color: #0d0d0d;
            --panel-bg: rgba(20, 25, 40, 0.95);
            --text-color: #eee;
            --accent: #2980b9;
            --highlight: #f39c12;
            --danger: #c0392b;
            --success: #27ae60;

            /* --- LAYOUT VARS --- */
            --control-height: 180px;

            /* --- FONT SCALING SYSTEM --- */
            /* Change this value to scale ALL text up (e.g. 1.2) or down (e.g. 0.8) */
            --ui-scale: 1.0;

            /* Individual Sizes (Calculated based on scale) */
            --fs-micro:  calc(10px * var(--ui-scale));  /* Inventory counts, small labels */
            --fs-tiny:   calc(12px * var(--ui-scale));  /* Inventory counts, small labels */
            --fs-xs:     calc(13px * var(--ui-scale));  /* Server lists, meta data */
            --fs-sm:     calc(14px * var(--ui-scale));  /* Chat, buttons, descriptions */
            --fs-base:   calc(16px * var(--ui-scale));  /* Standard reading text, coords */
            --fs-md:     calc(18px * var(--ui-scale));  /* Icons inside buttons */
            --fs-lg:     calc(20px * var(--ui-scale));  /* Section headers */
            --fs-xl:     calc(22px * var(--ui-scale));  /* Prompts, Important notifications */
            --fs-icon:   calc(24px * var(--ui-scale));  /* D-Pad Arrows */
            --fs-gear:   calc(30px * var(--ui-scale));  /* Settings Icon */
            --fs-title:  calc(32px * var(--ui-scale));  /* Disconnect messages */
            --fs-hero:   calc(70px * var(--ui-scale));  /* Start Screen Title */

        }
        @media(max-width:700px){
            :root {
                --ui-scale: 1;


                --fs-hero:   calc(40px * var(--ui-scale));  /* Start Screen Title */
            }
        }

        body {
            overflow:hidden;
            font-family: "Geo", sans-serif;
            font-weight: 400;
            font-style: normal;
            color: var(--text-color);
            user-select: none;
            background: #000;
            /* Default body size */
            font-size: var(--fs-base);
        }

        /* Canvas resizing handled by JS, but default to full */
        canvas { display: block; width: 100dvw; height: 100dvh; }

        .noaliasing {
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-optimize-contrast;
            image-rendering: crisp-edges;
            -ms-interpolation-mode: nearest-neighbor; /* IE8+ */
        }

        /* UI Overlay */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        .pointer-events-auto { pointer-events: auto; }

        /* Mobile Controls Container */
        #mobile-controls {
            display: none; /* Hidden by default */
        }

        /* --- MOBILE MODE LAYOUTS --- */

        /* Portrait: Controls at bottom, Canvas shorter */
        @media (orientation: portrait) {
            body.mobile-mode #mobile-controls {
                position: fixed; bottom: 0; left: 0; width: 100%; height: var(--control-height);
                background: #111; border-top: 2px solid #333;
                display: flex; justify-content: space-between; align-items: center;
                padding: 10px 20px; pointer-events: auto;
            }
            body.mobile-mode canvas { height: calc(100dvh - var(--control-height)); width: 100dvw; }
            body.mobile-mode #chat-container { bottom: calc(var(--control-height) + 20px); }
        }

        /* Landscape: Controls on sides, Canvas narrower in middle */
        @media (orientation: landscape) {
            body.mobile-mode #mobile-controls {
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: transparent; pointer-events: none;
                display: flex; justify-content: space-between; align-items: flex-end;
                padding: 5px;
            }

            body.mobile-mode .d-pad, body.mobile-mode .action-pad {
                pointer-events: auto;
                background: rgba(20, 20, 20, 0.8);
                border: 1px solid #444;
                border-radius: 16px;
                corner-shape: bevel;
                padding: 15px;
                margin-bottom: 5px;
                backdrop-filter: blur(4px);
            }

            /* Shift Game Canvas to center, avoiding overlap */
            body.mobile-mode #gameCanvas {
                position: absolute; top: 0; left: 200px;
                width: calc(100dvw - 400px); /* 200px buffer each side */
                height: 100dvh;
            }

            /* Update: Chat in Left Panel for Mobile Landscape */
            body.mobile-mode #chat-container {
                left: 10px;
                bottom: 220px; /* Above the D-Pad */
                width: 180px;  /* Fit in the 200px sidebar */
                height: 120px;
            }
        }

        /* D-PAD */
        .d-pad {
            width: 150px;
            height: 150px;
            position: relative;
        }
        .d-btn {
            position: absolute;
            width: 50px;
            height: 50px;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.3);
            border-radius: 8px;
            corner-shape: bevel;
            color: #aaa;
            font-size: var(--fs-icon); /* UPDATED */
            display: flex;
            align-items: center;
            justify-content: center;
            -webkit-user-select: none;
        }
        .d-btn:active { background: var(--accent); color: white; }
        .d-up { top: 0; left: 50px; }
        .d-down { bottom: 0; left: 50px; }
        .d-left { top: 50px; left: 0; }
        .d-right { top: 50px; right: 0; }

        /* Action Buttons */
        .action-pad {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            width: 160px;
        }
        .act-btn {
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.3);
            border-radius: 50%;
            corner-shape: bevel;
            color: white;
            font-weight: bold;
            font-size: var(--fs-sm); /* UPDATED */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
        }
        .act-btn:active { background: var(--highlight); color: black; transform: scale(0.95); }
        .act-btn i {
            font-size: var(--fs-md); /* UPDATED */
            margin-bottom: 2px;
            font-style: normal;
        }

        /* Gear Icon */
        #gear-btn {
            position: absolute;
            top: 10px;
            left: 10px;
            font-size: var(--fs-gear);
            color: rgba(128,128,128,0.5); /* grey + semi-transparent */
            cursor: pointer;
            pointer-events: auto;
            z-index: 50;
            transition: color 0.3s;
        }

        #gear-btn:hover {
            color: rgba(255,255,255,0.8); /* brighter tint on hover */
        }

        #gear-btn:active {
            color: rgba(80,80,80,0.6); /* slightly darker + a bit more opaque */
            transform: scale(0.95);    /* optional: tiny press-in effect */
        }

        /* Coords Display */
        #coords-display {
            position: absolute; top: 10px; left: 60px;
            font-size: var(--fs-base); /* UPDATED */
            color: #aaa; font-family: "Geo", sans-serif; display: none; text-shadow: 1px 1px 0 #000;
        }

        /* Mobile specific coords adjustment */
        body.mobile-mode #coords-display { top: 40px; left: 10px; }

        /* Overheat Overlay */
        #heat-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; box-shadow: inset 0 0 0px var(--danger); transition: box-shadow 0.2s; opacity: 0; }

        /* Connection Screens */
        #connection-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #050505; z-index: 300; display: none; flex-direction: column; align-items: center; justify-content: center; pointer-events: auto; }
        #connection-log {
            font-family: "Geo", sans-serif; color: var(--success); margin-top: 20px;
            font-size: var(--fs-sm); /* UPDATED */
            text-align: left; width: 300px; height: 100px; overflow-y: auto; border: 1px solid #333; padding: 10px; background: #000;
        }
        .log-line { margin: 2px 0; }
        .spinner { width: 40px; height: 40px; border: 4px solid #333; border-top: 4px solid var(--highlight); border-radius: 50%; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* Connection Lost Overlay */
        #disconnect-msg {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: var(--danger);
            font-size: var(--fs-title); /* UPDATED */
            font-weight: bold; background: rgba(0,0,0,0.8); padding: 20px; border: 2px solid var(--danger); display: none; z-index: 200; text-align: center;
        }

        /* Chat */
        #chat-container { position: absolute; bottom: 120px; left: 10px; width: 300px; height: 150px; display: flex; flex-direction: column; pointer-events: auto; opacity: 0.8; transition: opacity 0.3s; z-index: 10; }
        #chat-container:hover { opacity: 1; }
        #chat-messages {
            flex: 1; overflow-y: auto; background: rgba(0,0,0,0.6); padding: 5px;
            font-size: var(--fs-sm); /* UPDATED */
            scrollbar-width: thin; text-shadow: 1px 1px 0 #000; border: 1px solid #444;
        }
        #chat-input { background: rgba(0,0,0,0.8); border: 1px solid #444; color: white; padding: 5px; width: 100%; box-sizing: border-box; font-size: var(--fs-sm); }

        /* Minimap */
        #minimap-container { position: absolute; top: 10px; right: 10px; width: 150px; height: 150px; border: 2px solid #555; background: #000; z-index: 20; overflow: hidden; }
        #minimap { display: block; width: 100%; height: 100%; }

        /* Interaction Prompts */
        #prompt-msg {
            position: absolute; top: 100px; left: 50%; transform: translateX(-50%); color: var(--highlight);
            font-size: var(--fs-xl);
            font-weight: bold; text-shadow: 0 2px 4px #000; display: none; pointer-events: none; text-align: center;
        }

        /* Modals */
        .modal { display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: var(--panel-bg); padding: 20px; border: 2px solid var(--accent); border-radius: 8px; corner-shape: bevel; width: 95%; max-width: 600px; max-height: 90dvh; overflow-y: auto; pointer-events: auto; z-index: 100; box-shadow: 0 0 30px rgba(0,0,0,0.9); -webkit-overflow-scrolling: touch; }
        .modal.active { display: block; }
        .modal h2 { margin-top: 0; color: var(--highlight); border-bottom: 1px solid #444; padding-bottom: 10px; text-transform: uppercase; letter-spacing: 1px; font-size: var(--fs-lg); }

        .form-group { margin-bottom: 15px; }
        .form-group label {
            display: block; margin-bottom: 5px;
            font-size: var(--fs-base);
            color: #aaa; text-transform: uppercase;
        }
        .form-group input[type="text"], .form-group select { font-family: "Geo", sans-serif; width: 100%; padding: 8px; background: #222; border: 1px solid #444; color: white; box-sizing: border-box; font-size: var(--fs-base); }
        .form-group input:disabled { opacity: 0.5; cursor: not-allowed; }
        input[type=range] { width: 100%; accent-color: var(--accent); }

        /* Shop Grid */
        .shop-container { height: 100%;}
        .shop-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
        .shop-item { background: rgba(0,0,0,0.3); padding: 10px; border: 1px solid #444; display: flex; flex-direction: column; justify-content: space-between; }
        .shop-item h4 { margin: 0 0 5px 0; color: var(--accent); font-size: var(--fs-base); }
        .shop-item p {
            font-size: var(--fs-sm);
            color: #ccc; margin: 0 0 5px 0;
        }
        .shop-item .cost {
            color: var(--highlight); font-weight: bold;
            font-size: var(--fs-base);
        }

        /* Sell List */
        .sell-list { max-height: 150px; overflow-y: auto; margin-bottom: 20px; border: 1px solid #444; background: #111; }
        .sell-row {
            display: flex; justify-content: space-between; align-items: center; padding: 5px 10px; border-bottom: 1px solid #333;
            font-size: var(--fs-sm);
        }
        .sell-row:last-child { border-bottom: none; }
        .sell-actions button {
            margin-left: 5px; padding: 2px 8px;
            font-size: var(--fs-tiny);
        }

        /* Dashboard (Stats/Inventory) */
        .dash-cols { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
        .inv-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(60px, 1fr)); gap: 5px; max-height: 200px; overflow-y: auto; }
        .inv-item {
            background: #222; border: 1px solid #444; padding: 5px; text-align: center; cursor: pointer;
            font-size: var(--fs-tiny);
            position: relative; transition: all 0.2s; pointer-events: auto;
        }
        .inv-item:hover { border-color: #fff; background: #333; }
        .inv-item.active { border-color: gold; box-shadow: 0 0 8px gold; background: rgba(255, 215, 0, 0.1); transform: scale(1.05); z-index: 10; }
        .inv-count { position: absolute; bottom: 2px; right: 2px; font-weight: bold; color: #fff; }
        .inv-trash {
            position: absolute; top: 0; right: 0; background: #c0392b; color: white; width: 15px; height: 15px;
            font-size: var(--fs-tiny);
            line-height: 15px; display: none; cursor: pointer;
        }
        .inv-trash:hover { filter: brightness(1.2); }
        .inv-item:hover .inv-trash { display: block; }

        .inv-use-btn {
            position: absolute;
            bottom: 0; left: 0; width: 100%;
            background: var(--success); color: white;
            font-size: var(--fs-micro);
            font-weight: bold;
            border: none; cursor: pointer;
            z-index: 20;
        }

        .stat-row {
            display: flex; justify-content: space-between;
            font-size: var(--fs-sm);
            border-bottom: 1px solid #333; padding: 2px 0;
        }

        .btn { background: var(--accent); font-family: "Geo", sans-serif; color: white; border: none; padding: 10px; cursor: pointer; transition: all 0.2s; width: 100%; margin-top: 5px; font-weight: bold; border-radius: 4px; corner-shape: bevel; font-size: var(--fs-base); }
        .btn:hover { background: #3498db; filter: brightness(1.2); }
        .btn:disabled { background: #555; cursor: not-allowed; filter: none; }
        .btn-small {
            width: auto; padding: 4px 8px; margin-right: 5px;
            font-size: var(--fs-sm);
        }
        .btn-danger { background: var(--danger); }
        .btn-bind { background: #444; border: 1px solid #666; color: #fff; text-align: left; position: relative; }
        .btn-bind.binding { background: #c0392b; border-color: #e74c3c; animation: pulse-red 1s infinite; }
        @keyframes pulse-red { 0% { opacity: 1; } 50% { opacity: 0.7; } 100% { opacity: 1; } }

        /* Credits Modal */
        #credits-modal .credits-section { margin-bottom: 25px; }
        #credits-modal h3 {
            margin: 10px 0; color: var(--accent);
            font-size: var(--fs-lg);
            border-bottom: 1px solid #333; padding-bottom: 5px; text-transform: uppercase; letter-spacing: 1px;
        }
        .credit-entry { margin-left: 15px; margin-top: 8px; }
        .credit-entry strong {
            color: var(--highlight);
            font-size: var(--fs-base);
        }
        .credit-entry ul { margin: 5px 0 10px 20px; padding: 0; }
        .credit-entry li {
            list-style: none; color: #ccc; margin: 2px 0;
            font-size: var(--fs-sm);
        }

        /* Server Status */
        .server-option {
            display: flex; justify-content: space-between; padding: 2px;
            font-size: var(--fs-sm);
        }
        .status-dot { width: 8px; height: 8px; border-radius: 50%; display: inline-block; background: #555; margin-right: 5px; }
        .status-dot.green { background: #2ecc71; box-shadow: 0 0 5px #2ecc71; }
        .status-dot.red { background: #e74c3c; }

        /* Save Slots */
        .save-list-wrapper { max-height: 200px; overflow-y: auto; border: 1px solid #444; background: #111; padding: 5px; margin-bottom: 10px; }
        .save-slot { background: rgba(0,0,0,0.4); padding: 8px; border: 1px solid #555; margin-bottom: 5px; display: flex; justify-content: space-between; align-items: center; }
        .save-slot:hover { background: rgba(255,255,255,0.05); }
        .save-slot.active { border-color: var(--highlight); box-shadow: inset 0 0 10px rgba(243, 156, 18, 0.2); }
        .save-slot-info {
            color: #ccc; flex: 1;
            font-size: var(--fs-sm);
        }
        .save-slot-actions { display:flex; gap: 5px; }
        .save-slot-actions button {
            margin: 0; padding: 4px 8px;
            font-size: var(--fs-tiny);
        }

        /* Warp List */
        .warp-list { max-height: 300px; overflow-y: auto; display: flex; flex-direction: column; gap: 5px; }

        /* Start Screen */
        #start-screen { position: absolute;
        background-image:
            linear-gradient(30deg, #683131 12%, transparent 12.5%, transparent 87%, #683131 87.5%, #683131),
            linear-gradient(150deg, #683131 12%, transparent 12.5%, transparent 87%, #683131 87.5%, #683131),
            linear-gradient(30deg, #683131 12%, transparent 12.5%, transparent 87%, #683131 87.5%, #683131),
            linear-gradient(150deg, #683131 12%, transparent 12.5%, transparent 87%, #683131 87.5%, #683131),
            linear-gradient(60deg, #68313180 25%, transparent 25.5%, transparent 75%, #68313180 75%, #68313180),
            linear-gradient(60deg, #68313180 25%, transparent 25.5%, transparent 75%, #68313180 75%, #68313180);
            background-size: 20px 35px;
        background-position: 0 0, 0 0, 10px 17.5px, 10px 17.5px, 0 0, 10px 17.5px;
        background-color: #362520;
        top: 0; left: 0; width: 100%; height: 100%;
        display: flex; flex-direction: column; align-items: center; justify-content: center;
        z-index: 50; pointer-events: auto;
        }
        #start-screen h1 {
            font-size: var(--fs-hero);
            color: var(--highlight); margin-bottom: 20px; text-transform: uppercase; letter-spacing: 4px; text-shadow: 0 0 10px var(--highlight);
        }

        .start-container { display:flex; gap:20px; background:rgba(20, 25, 40, 0.95); padding:20px; border-radius:10px; corner-shape: bevel; border:1px solid #444; max-width: 75dvw; max-height: 90dvh; overflow-y:auto; -webkit-overflow-scrolling: touch; }
        .start-panel { width:300px; flex-shrink: 0; }
        .server-panel { width:300px; border-left:1px solid #444; padding-left:20px; display:flex; flex-direction:column; flex-shrink: 0; }

        @media (max-width: 700px) {
            .start-container { flex-direction: column; width: 90%; padding:10px; margin: 0px; max-width: 100dvw }
            .start-panel, .server-panel { width: 100%; }
            .server-panel { border-left: none; border-top: 1px solid #444; padding-left: 0; padding-top: 20px; }
        }

        /* Server List Styles */
        .server-list-item {
            background:rgba(0,0,0,0.3); padding:8px; margin-bottom:5px; border:1px solid #333;
            font-size: var(--fs-sm);
            cursor:pointer; display:flex; align-items:center; justify-content:space-between; transition:0.2s;
        }
        .server-list-item:hover { background:rgba(255,255,255,0.05); }
        .server-list-item.active { border-color:var(--highlight); box-shadow:inset 0 0 5px rgba(243, 156, 18, 0.2); }
        .server-status-icon { width:12px; height:12px; margin-right:8px; display:flex; align-items:center; justify-content:center; }
        .spin-loader { border: 2px solid #555; border-top: 2px solid #fff; border-radius: 50%; width: 10px; height: 10px; animation: spin 1s linear infinite; }
        .server-actions { display: flex; gap: 4px; opacity: 0.6; transition: opacity 0.2s; }
        .server-list-item:hover .server-actions { opacity: 1; }

        /* Notification/Error Popup */
        #notification-area { position: absolute; top: 20px; right: 180px; width: 300px; display: flex; flex-direction: column; gap: 10px; pointer-events: none; z-index: 200; }
        .toast {
            background: rgba(30, 30, 30, 0.95); border-left: 4px solid var(--accent); padding: 12px; color: white; pointer-events: auto; animation: slideIn 0.3s ease; box-shadow: 0 4px 10px rgba(0,0,0,0.5);
            font-size: var(--fs-base);
        }
        .toast.error { border-left-color: var(--danger); }
        .toast.warn { border-left-color: var(--highlight); }
        .toast.success { border-left-color: var(--success); }
        @keyframes slideIn { from { transform: translateX(100%); opacity: 0; } to { transform: translateX(0); opacity: 1; } }

        /* Admin Panel */
        #admin-panel { position: absolute; top: 165px; right: 10px; background: rgba(0,0,0,0.7); padding: 10px; pointer-events: auto; width: 150px; border: 1px solid #555; }
        .player-row {
            display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;
            font-size: var(--fs-xs);
        }

        /* --- CUSTOM MODAL --- */
        #c-modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); z-index: 9999; display: none; align-items: center; justify-content: center; backdrop-filter: blur(2px); }
        .c-modal-box { background: rgba(20, 25, 40, 0.98); border: 1px solid var(--accent); padding: 20px; width: 90%; max-width: 400px; border-radius: 8px; corner-shape: bevel; box-shadow: 0 0 30px rgba(0,0,0,0.8); text-align: center; animation: slideIn 0.2s ease; }
        .c-modal-box h3 { color: var(--highlight); margin-top: 0; border-bottom: 1px solid #444; padding-bottom: 10px; margin-bottom: 15px; font-size: var(--fs-lg); }
        .c-modal-box p {
            color: #ddd; margin-bottom: 15px; line-height: 1.4;
            font-size: var(--fs-base);
        }
        .c-modal-btns { display: flex; justify-content: center; gap: 10px; margin-top: 15px; }

        /* --- FIXES --- */

        /* 1. Mobile Toast Fix: prevent off-screen width causing overflow/glitches */
        @media (max-width: 600px) {
            #notification-area {
                right: 10px;
                left: 10px;
                width: auto;
                top: 60px;
            }
        }

        /* 2. Scroll Fix: Re-enable scrolling on containers that need it */
        .start-container,
        .modal,
        #server-list-sidebar,
        .sell-list,
        .inv-grid,
        #chat-messages,
        #connection-log,
        #save-list-wrapper,
        .save-list-wrapper {
            touch-action: pan-y !important;
        }

        /* 3. Animation Fix: Use Vertical slide instead of Horizontal to prevent layout thrashing */
        @keyframes slideIn {
            from { transform: translateY(-20px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        /* --- MOBILE CHAT MODIFICATIONS --- */
        body.mobile-mode #chat-container {
            transition: height 0.3s, opacity 0.3s, border-color 0.3s;
            cursor: pointer;
        }

        /* Minimized State */
        body.mobile-mode #chat-container.minimized {
            height: 35px !important;
            overflow: hidden;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid #444;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Hide internals when minimized */
        body.mobile-mode #chat-container.minimized #chat-messages,
        body.mobile-mode #chat-container.minimized #chat-input,
        body.mobile-mode #chat-container.minimized #chat-close-btn {
            display: none !important;
        }

        /* Label for minimized state */
        body.mobile-mode #chat-container.minimized::after {
            content: "CHAT (Click to Open)";
            color: #aaa;
            font-size: var(--fs-xs);
            font-weight: bold;
            letter-spacing: 1px;
        }

        /* Unread State (Red Pulse) */
        body.mobile-mode #chat-container.minimized.unread {
            border: 1px solid #e74c3c;
            background: rgba(231, 76, 60, 0.3);
            animation: pulse-red 1.5s infinite;
        }
        body.mobile-mode #chat-container.minimized.unread::after {
            content: "NEW MESSAGE !";
            color: #fff;
        }

        /* Show Close button only in mobile mode when open */
        body.mobile-mode #chat-container #chat-close-btn {
            display: block;
        }
    </style>
</head>
<body>

    <canvas id="gameCanvas" class="noaliasing"></canvas>

    <div id="mobile-controls">
        <div class="d-pad">
            <div class="d-btn d-up" data-key="up">&#8593;</div>
            <div class="d-btn d-left" data-key="left">&#8592;</div>
            <div class="d-btn d-right" data-key="right">&#8594;</div>
            <div class="d-btn d-down" data-key="down">&#8595;</div>
        </div>
        <div class="action-pad">
            <div class="act-btn" data-key="build" style="background:var(--highlight); color:black;"><i>&#9874;</i>BUILD</div>
            <div class="act-btn" data-key="interact" style="background:var(--success);"><i>&#128736;</i>ACT</div>
            <div class="act-btn" data-key="chat" style="background:#555;"><i>&#128489;</i>CHAT</div>
            <div class="act-btn" data-key="transfer" style="background:#8e44ad;"><i>&#127873;</i>GIVE</div>
            <div class="act-btn" data-key="adminToggle" style="background:#ff0000;"><i>&#128737;</i>ADMIN</div>
        </div>
    </div>

    <div id="ui-layer">
        <div id="heat-overlay"></div>

        <!-- Gear Icon -->
        <div id="gear-btn" onclick="$('settings-modal').classList.contains('active') ? UI.closeSettings() : UI.openSettings();"><svg viewBox="0 0 600 600" version="1.1" id="svg9724" sodipodi:docname="settings2.svg" inkscape:version="1.2.2 (1:1.2.2+202212051550+b0a8486541)" width="32px" height="32px" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd" xmlns="http://www.w3.org/2000/svg" xmlns:svg="http://www.w3.org/2000/svg" fill="currentColor"><g id="SVGRepo_bgCarrier" stroke-width="0"></g><g id="SVGRepo_tracerCarrier" stroke-linecap="round" stroke-linejoin="round"></g><g id="SVGRepo_iconCarrier"> <defs id="defs9728"></defs> <sodipodi:namedview id="namedview9726" pagecolor="#ffffff" bordercolor="#666666" borderopacity="1.0" inkscape:showpageshadow="2" inkscape:pageopacity="0.0" inkscape:pagecheckerboard="0" inkscape:deskcolor="#d1d1d1" showgrid="true" inkscape:zoom="0.59480855" inkscape:cx="44.55215" inkscape:cy="332.03961" inkscape:window-width="1920" inkscape:window-height="1009" inkscape:window-x="0" inkscape:window-y="1080" inkscape:window-maximized="1" inkscape:current-layer="svg9724" showguides="true"> <inkscape:grid type="xygrid" id="grid9972" originx="0" originy="0"></inkscape:grid> <sodipodi:guide position="40,400" orientation="0,-1" id="guide292" inkscape:locked="false"></sodipodi:guide> <sodipodi:guide position="90,200" orientation="0,-1" id="guide294" inkscape:locked="false"></sodipodi:guide> <sodipodi:guide position="230,500" orientation="0,-1" id="guide296" inkscape:locked="false"></sodipodi:guide> <sodipodi:guide position="210,300" orientation="0,-1" id="guide298" inkscape:locked="false"></sodipodi:guide> <sodipodi:guide position="230,100" orientation="0,-1" id="guide300" inkscape:locked="false"></sodipodi:guide> </sodipodi:namedview> <g id="g10449" transform="matrix(0.95173205,0,0,0.95115787,13.901174,12.168794)" style="stroke-width:1.05103"> <path id="path356" style="color:currentColor;fill:currentColor;stroke-linecap:round;-inkscape-stroke:none" d="M 447.70881 -12.781343 A 42.041451 42.041451 0 0 0 405.66786 29.260344 L 405.66786 50.301721 L 27.434765 50.301721 A 42.041302 42.041302 0 0 0 -14.606185 92.341354 A 42.041302 42.041302 0 0 0 27.434765 134.38304 L 405.66786 134.38304 L 405.66786 155.44906 A 42.041451 42.041451 0 0 0 447.70881 197.49075 A 42.041451 42.041451 0 0 0 489.74976 155.44906 L 489.74976 134.38304 L 573.78036 134.38304 A 42.041302 42.041302 0 0 0 615.82336 92.341354 A 42.041302 42.041302 0 0 0 573.78036 50.301721 L 489.74976 50.301721 L 489.74976 29.260344 A 42.041451 42.041451 0 0 0 447.70881 -12.781343 z M 143.0012 197.48869 A 42.041451 42.041451 0 0 0 100.9582 239.53038 L 100.9582 260.5697 L 27.447078 260.5697 A 42.041302 42.041302 0 0 0 -14.593872 302.61139 A 42.041302 42.041302 0 0 0 27.447078 344.65308 L 100.9582 344.65308 L 100.9582 365.7191 A 42.041451 42.041451 0 0 0 143.0012 407.76078 A 42.041451 42.041451 0 0 0 185.04215 365.7191 L 185.04215 344.65308 L 573.79472 344.65308 A 42.041302 42.041302 0 0 0 615.83567 302.61139 A 42.041302 42.041302 0 0 0 573.79472 260.5697 L 185.04215 260.5697 L 185.04215 239.53038 A 42.041451 42.041451 0 0 0 143.0012 197.48869 z M 279.59427 407.76078 A 42.041451 42.041451 0 0 0 237.55332 449.80042 L 237.55332 470.83974 L 27.447078 470.83974 A 42.041302 42.041302 0 0 0 -14.593872 512.88143 A 42.041302 42.041302 0 0 0 27.447078 554.92106 L 237.55332 554.92106 L 237.55332 575.98913 A 42.041451 42.041451 0 0 0 279.59427 618.02877 A 42.041451 42.041451 0 0 0 321.63522 575.98913 L 321.63522 554.92106 L 573.79472 554.92106 A 42.041302 42.041302 0 0 0 615.83567 512.88143 A 42.041302 42.041302 0 0 0 573.79472 470.83974 L 321.63522 470.83974 L 321.63522 449.80042 A 42.041451 42.041451 0 0 0 279.59427 407.76078 z "></path> </g> </g></svg></div>

        <!-- Coords -->
        <div id="coords-display">X: 0 Y: 0</div>

        <!-- Connection Lost -->
        <div id="disconnect-msg">CONNECTION LOST<br><span style="font-size: var(--fs-base); font-weight:normal; color:#fff;">Trying to reconnect...</span></div>

        <!-- Connection Screen -->
        <div id="connection-screen">
            <div class="spinner"></div>
            <h2 style="color:#fff; margin-top:20px;">ESTABLISHING UPLINK</h2>
            <div id="connection-log"></div>
        </div>

        <!-- Minimap -->
        <div id="minimap-container">
            <canvas id="minimap" class="noaliasing"></canvas>
        </div>

        <!-- Chat -->
        <div id="chat-container" onclick="UI.openChat()">
            <button id="chat-close-btn" onclick="event.stopPropagation(); UI.closeChat()" style="display:none; position:absolute; top:-5px; right:-5px; width:20px; height:20px; border-radius:50%; corner-shape: bevel; border:none; background:#c0392b; color:white; font-weight:bold; cursor:pointer; z-index:100; var(--fs-tiny);">X</button>
            <div id="chat-messages"></div>
            <input type="text" id="chat-input" placeholder="Press CHAT key to type...">
        </div>

        <!-- Admin Panel -->
        <div id="admin-panel">
            <h4 style="margin:0 0 10px 0; color:gold; font-size: var(--fs-sm);">Host Controls</h4>
            <div id="player-list"></div>
        </div>

        <!-- Prompt -->
        <div id="prompt-msg"></div>

        <!-- Start Screen -->
        <div id="start-screen">
            <h1>Mega Miner</h1>
            <div class="start-container">
                <div class="start-panel">
                    <div class="form-group">
                        <label>Username</label>
                        <div style="display:flex; gap:5px;">
                            <input type="text" id="start-username" placeholder="Enter Username" maxlength="12" style="flex:1;">
                            <button class="btn" style="width:auto; padding: 0 10px; font-size: var(--fs-base);" onclick="Game.randomizeUsername()" title="Randomize Username">&#127922;</button>
                        </div>
                    </div>
                    <div class="form-group">
                        <label>Room ID</label>
                        <input type="text" id="start-room" value="public-mine-1">
                    </div>
                    <div class="form-group">
                        <label>Vehicle Color</label>
                        <input type="color" id="start-color" value="#3498db" style="height:40px;">
                    </div>
                    <div class="form-group">
                        <label style="display:inline-flex; align-items:center;">
                            <input type="checkbox" id="mobile-toggle" onchange="Game.toggleMobile(this.checked)">&nbsp;&nbsp;Enable Mobile Controls
                        </label>
                    </div>
                    <button class="btn" onclick="Game.init()" id="startBtn">LAUNCH MISSION</button>
                    <button class="btn" style="margin-top:10px; background:#444;" onclick="UI.openSettings()">SETTINGS</button>
                </div>

                <div class="server-panel">
                    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
                        <label style="margin:0; font-size: var(--fs-sm); color:#aaa;">SERVER STATUS</label>
                        <button class="btn btn-small" style="width:auto; padding:2px 5px;" onclick="UI.refreshServerList()">&#8635;</button>
                    </div>
                    <div id="server-list-sidebar" style="flex:1; overflow-y:auto; max-height:200px; margin-bottom:10px;">
                        <!-- Injected via JS -->
                    </div>

                    <div class="form-group" style="margin-bottom:0;">
                        <label>Add Custom Server</label>
                        <div style="display:flex; gap:5px;">
                            <input type="text" id="custom-server-input" placeholder="wss://..." style="font-size: var(--fs-sm);">
                            <button class="btn btn-small" style="width:auto;" onclick="UI.addCustomServer()">+</button>
                        </div>
                    </div>
                    <div style="margin-top:10px; font-size: var(--fs-tiny); color:#e74c3c; line-height:1.4; background:rgba(231, 76, 60, 0.1); padding:5px; border:1px solid #e74c3c;">
                        <strong>WARNING:</strong> You must select the SAME server as your friends to see them. Check status before joining.
                    </div>
                </div>
            </div>
        </div>

        <!-- Dashboard Modal (Inventory/Stats) -->
        <div id="dashboard-modal" class="modal">
            <h2>Pilot Dashboard</h2>
            <div class="dash-cols">
                <div>
                    <h4 style="color:#aaa; border-bottom:1px solid #444;">INVENTORY / BUILD</h4>
                    <p style="font-size: var(--fs-sm); color:#777;">Click item to Equip. Consumables have a [USE] button. Hover to Trash.</p>
                    <button class="btn btn-small" style="background:#c0392b; width:100%; margin-bottom:10px;" onclick="Game.trashJunk()">TRASH ALL JUNK (Dirt/Stone)</button>
                    <div id="inv-grid" class="inv-grid"></div>
                    <div id="station-btn-container" style="margin-top:20px; display:none;">
                        <button class="btn" style="background:var(--success);" onclick="Shop.open()">OPEN STATION SHOP</button>
                    </div>
                </div>
                <div>
                    <h4 style="color:#aaa; border-bottom:1px solid #444;">STATISTICS</h4>
                    <div id="stats-container"></div>

                    <h4 style="color:#aaa; border-bottom:1px solid #444; margin-top:20px;">LEADERBOARD</h4>
                    <div id="leaderboard-container"></div>
                </div>
            </div>
            <button class="btn" style="background:#555; margin-top:20px;" onclick="$('dashboard-modal').classList.remove('active')">Close</button>
        </div>

        <!-- Warp Modal -->
        <div id="warp-modal" class="modal">
            <h2>Teleporter Network</h2>
            <p style="font-size: var(--fs-sm); color:#ccc;">Select a destination. Discovered relays appear here automatically.</p>
            <div id="warp-list" class="warp-list"></div>
            <button class="btn" style="background:#555; margin-top:20px;" onclick="$('warp-modal').classList.remove('active')">Cancel</button>
        </div>

        <!-- Shop Modal -->
        <div id="shop-modal" class="modal">
            <h2>Service Station</h2>
            <div style="text-align:center; margin-bottom:15px; font-size:var(--fs-xl);">
                Wallet: <span id="shop-money" style="color:gold; font-weight:bold;">$0</span>
            </div>
            <button class="btn" style="margin-bottom:10px; background:var(--success);" onclick="Shop.sellAll()">SELL ALL ORES</button>
            <button class="btn" style="margin-bottom:10px; background:var(--success);" onclick="Shop.refuelRepair()">Refuel and Repair ($10)</button>

            <h4 style="color:#aaa; border-bottom:1px solid #444;">SELL MINERALS</h4>
            <div id="sell-list" class="sell-list"></div>

            <h4 style="color:#aaa; border-bottom:1px solid #444; margin-top:20px;">UPGRADES & SUPPLIES</h4>
            <div class="shop-grid">
                <!-- Upgrades -->
                <div class="shop-item">
                    <h4>Upgrade Drill</h4>
                    <p>Increases Mining Tier.</p>
                    <div class="cost" id="cost-drill"></div>
                    <button class="btn" id="btn-drill" onclick="Shop.buy('drill')">Upgrade</button>
                </div>
                <div class="shop-item">
                    <h4>Nanite Hull</h4>
                    <p>Increases Max HP.</p>
                    <div class="cost" id="cost-hull"></div>
                    <button class="btn" id="btn-hull" onclick="Shop.buy('hull')">Upgrade</button>
                </div>
                <div class="shop-item">
                    <h4>Fuel Compactor</h4>
                    <p>Increases Fuel Capacity.</p>
                    <div class="cost" id="cost-fuel"></div>
                    <button class="btn" id="btn-fuel" onclick="Shop.buy('fuel')">Upgrade</button>
                </div>
                <div class="shop-item">
                    <h4>Cargo Bay</h4>
                    <p>Increases Carrying Capacity.</p>
                    <div class="cost" id="cost-cargo"></div>
                    <button class="btn" id="btn-cargo" onclick="Shop.buy('cargo')">Upgrade</button>
                </div>
                <div class="shop-item">
                    <h4>Heat Shield</h4>
                    <p>Resist high temperatures.</p>
                    <div class="cost" id="cost-cool"></div>
                    <button class="btn" id="btn-cool" onclick="Shop.buy('cool')">Upgrade</button>
                </div>
                <div class="shop-item">
                    <h4>X-Ray Optics</h4>
                    <p>See minerals through walls.</p>
                    <div class="cost" id="cost-xray"></div>
                    <button class="btn" id="btn-xray" onclick="Shop.buy('xray')">Upgrade</button>
                </div>
                <!--<div class="shop-item">
                    <h4>Vehicle Paint</h4>
                    <p>Change your look.</p>
                    <input type="color" id="shop-color-picker" style="width:100%; height:30px; margin-bottom:5px;">
                    <button class="btn" onclick="Shop.buy('paint')">Repaint ($100)</button>
                </div>-->
                <!-- New Items -->
                <div class="shop-item">
                    <h4>Repair Kit</h4>
                    <p>Restore 50 HP (Use in Inv).</p>
                    <div class="cost">$50</div>
                    <button class="btn" onclick="Shop.buy('repair_kit')">Buy</button>
                </div>
                <div class="shop-item">
                    <h4>Fuel Voucher</h4>
                    <p>Restore 50 Fuel (Use in Inv).</p>
                    <div class="cost">$50</div>
                    <button class="btn" onclick="Shop.buy('fuel_voucher')">Buy</button>
                </div>
                <div class="shop-item">
                    <h4>TNT</h4>
                    <p>Explosive charge. Range: 3.</p>
                    <div class="cost">$200</div>
                    <button class="btn" onclick="Shop.buy('tnt')">Buy</button>
                </div>
                <div class="shop-item">
                    <h4>Nuke</h4>
                    <p>Massive destruction. Range: 10.</p>
                    <div class="cost" style="color:#c0392b;">$5000</div>
                    <button class="btn" onclick="Shop.buy('nuke')">Buy</button>
                </div>
                <div class="shop-item">
                    <h4>Teleporter</h4>
                    <p>Fast travel to surface.</p>
                    <div class="cost">$1000</div>
                    <button class="btn" onclick="Shop.buy('teleporter')">Buy</button>
                </div>
            </div>
            <button class="btn" style="background:#555; margin-top:20px; position:sticky; bottom: 10px;" onclick="Shop.close()">Exit Station</button>
        </div>

        <!-- Settings Modal -->
        <div id="settings-modal" class="modal">
            <h2>Settings</h2>

            <div class="form-group">
                <label>Audio Mixer</label>
                <div style="font-size: var(--fs-sm); display:grid; grid-template-columns: 1fr 3fr 1fr; gap:10px; align-items:center;">
                    <span>Master</span> <input type="range" id="vol-master" min="0" max="1" step="0.01" value="0.5" oninput="Sound.setVolume('master', this.value)"> <span id="vol-disp-master">50%</span>
                    <span>Music</span> <input type="range" id="vol-music" min="0" max="1" step="0.01" value="0.1" oninput="Sound.setVolume('music', this.value)"> <span id="vol-disp-music">50%</span>
                    <span>SFX</span> <input type="range" id="vol-sfx" min="0" max="1" step="0.01" value="0.5" oninput="Sound.setVolume('sfx', this.value)"> <span id="vol-disp-sfx">50%</span>
                    <span>Engine</span> <input type="range" id="vol-engine" min="0" max="1" step="0.01" value="0.5" oninput="Sound.setVolume('engine', this.value)"> <span id="vol-disp-engine">50%</span>
                </div>
            </div>

            <div class="form-group">
                <label>Graphics Settings</label>
                <div style="font-size: var(--fs-sm); display:grid; grid-template-columns: 1fr 3fr 1fr; gap:10px; align-items:center;">
                    <span>Graphics Quality</span> <input type="range" id="graphicsQuality" min="1" max="3" step="1" value="1" oninput="Game.setGraphicsQuality(this.value)">
                </div>
            </div>

            <div class="form-group">
                <label>Options</label>
                <div style="display:flex; gap:15px; flex-wrap:wrap;">
                    <label style="display:inline-flex; align-items:center; text-transform:none; color:#eee;">
                        <input type="checkbox" id="autosave-toggle" checked onchange="SaveSystem.toggleAutosave(this.checked)" checked >&nbsp;&nbsp;Autosave
                    </label>
                    <label style="display:inline-flex; align-items:center; text-transform:none; color:#eee;">
                        <input type="checkbox" id="coords-toggle" onchange="Game.toggleCoords(this.checked)">&nbsp;&nbsp;Show Coordinates
                    </label>
                     <label style="display:inline-flex; align-items:center; text-transform:none; color:#eee;">
                        <input type="checkbox" id="mobile-setting-toggle" onchange="Game.toggleMobile(this.checked)">&nbsp;&nbsp;Mobile Controls
                    </label>
                    <label style="display:inline-flex; align-items:center; text-transform:none; color:#eee;">
                        <input type="checkbox" id="update-check-toggle" checked>&nbsp;&nbsp;Autocheck Updates (60s)
                    </label>
                    <label style="display:inline-flex; align-items:center; text-transform:none; color:#eee;">
                        <input type="checkbox" id="cloudSync-auto" checked>&nbsp;&nbsp;Automatically Sync to Cloud
                    </label>
                </div>
            </div>

            <div class="form-group">
                <label>Update Checker</label>
                <div style="display:flex; gap:5px; margin-bottom:5px;">
                    <button class="btn btn-small" style="width:auto;" onclick="UI.checkForUpdates()">Check For Updates</button>
                </div>
                <div id="gh-status" style="font-size: var(--fs-sm); color:#aaa;">Check official repo for updates.</div>
            </div>

            <div class="form-group">
                <label>Active Broker (Set in Start Screen)</label>
                <input type="text" id="setting-broker" placeholder="wss://...t" disabled style="opacity:0.7">
                <small style="color:#777;">Reload to change connection.</small>
            </div>

            <div class="form-group">
                <label>Save Management</label>
                <div style="display:flex; gap:5px; margin-bottom:5px;">
                    <button class="btn" style="flex:1; background:var(--success);" onclick="SaveSystem.createNewSave()">+ NEW SAVE</button>
                    <button class="btn" style="flex:1;" onclick="SaveSystem.saveCurrent()">SAVE CURRENT</button>
                </div>
                <div id="save-list-wrapper" class="save-list-wrapper">
                    <!-- Saves injected here -->
                </div>
                <small style="color:#777;">Green border indicates current session.</small>
            </div>


            <div class="form-group">
                <label>Backup Data (File)</label>
                <div style="display: flex; gap: 5px; margin-bottom: 5px;">
                    <button class="btn" style="flex: 1; background:#444;" onclick="$('import-file').click()">Load Save from File</button>
                </div>
                <input type="file" id="import-file" style="margin-top:5px; display:none;" onchange="SaveSystem.importSave(this)">
            </div>

            <div class="form-group">
                <label>Cloud Sync</label>
                <div style="display:flex; gap:5px; margin-bottom:5px; flex-wrap: wrap;">
                    <button class="btn" style="flex:1; background:#2980b9;" onclick="SaveSystem.smartSyncAll(false, true)">
                        Sync All
                    </button>
                    <button class="btn" style="flex:1; background:#444;" onclick="SaveSystem.loadLinkCode()">
                        Link Device
                    </button>
                </div>
                <div id="cloud-status" style="font-size: var(--fs-sm); color:#aaa; display:flex; justify-content:space-between;">
                    <span>Status: Connected (Puter)</span>
                    <span id="cloud-bin-display" style="font-family:'Geo',sans-serif;"></span>
                </div>
                <small style="color:#666;">Fetch Cloud Saves to see worlds from other devices.</small>
            </div>

            <div class="form-group">
                <label>Controls</label>
                <div style="display:grid; grid-template-columns: 1fr 1fr; gap:5px; font-size: var(--fs-sm);">
                    <button id="btn-bind-up" class="btn btn-bind" onclick="Input.startBind('up')">UP</button>
                    <button id="btn-bind-left" class="btn btn-bind" onclick="Input.startBind('left')">LEFT</button>
                    <button id="btn-bind-down" class="btn btn-bind" onclick="Input.startBind('down')">DOWN</button>
                    <button id="btn-bind-right" class="btn btn-bind" onclick="Input.startBind('right')">RIGHT</button>
                    <button id="btn-bind-build" class="btn btn-bind" onclick="Input.startBind('build')">BUILD</button>
                    <button id="btn-bind-interact" class="btn btn-bind" onclick="Input.startBind('interact')">MENU/INTERACT</button>
                    <button id="btn-bind-transfer" class="btn btn-bind" onclick="Input.startBind('transfer')">TRANSFER</button>
                    <button id="btn-bind-chat" class="btn btn-bind" onclick="Input.startBind('chat')">CHAT</button>
                </div>
                <small>Hold BUILD + Arrow to place Equipped block. Mouse Wheel to Zoom.</small>
            </div>

            <div id="credits"></div>
            <button class="btn" onclick="UI.closeSettings()">Close</button>
        </div>
    </div>

    <!-- Notification Area -->
    <div id="notification-area"></div>

    <!-- Custom Modal Structure -->
    <div id="c-modal-overlay">
        <div class="c-modal-box">
            <h3 id="c-modal-title">TITLE</h3>
            <p id="c-modal-text">Message goes here...</p>
            <input type="text" id="c-modal-input" style="width:100%; padding:10px; background:#111; border:1px solid #444; color:#fff; display:none; margin-bottom:5px;">
            <div class="c-modal-btns">
                <button id="c-modal-cancel" class="btn btn-danger" style="width:auto; min-width:80px; display:none;">Cancel</button>
                <button id="c-modal-ok" class="btn" style="width:auto; min-width:80px;">OK</button>
            </div>
        </div>
    </div>

<script>
const $ = id => document.getElementById(id);

// Robust UUID Generator (longer for collision avoidance)
const uuid = () => {
    if (typeof crypto !== 'undefined' && crypto.randomUUID) {
        return crypto.randomUUID();
    }
    // Fallback if crypto.randomUUID not available (older browsers/contexts)
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
        var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
        return v.toString(16);
    });
};
const paths = [/*`/Documents/MegaMinerSaves/`,*/ `./`];

const now = () => Date.now();
const clamp = (num, min, max) => Math.min(Math.max(num, min), max);
const BUILD_TIMESTAMP = Date.now();

// --- SEEDED RNG ---
const pseudoRandom = (x, y) => {
    return Math.abs(Math.sin(x * 12.9898 + y * 78.233) * 43758.5453) % 1;
};

// --- CONFIG & STATE ---
const CONSTANTS = {
    TILE_SIZE: 32, CHUNK_SIZE: 16, SPEED_NORMAL: 1.75, SPEED_DRILL: 0.75,
    FUEL_CONSUMPTION: 0.125, MAP_WIDTH: 1000, MAP_HEIGHT: 2000, MIN_ZOOM: 0.5, MAX_ZOOM: 3.0
};


const TILE_TYPES = {
    EMPTY: 0, DIRT: 1, GRASS: 2, STONE: 3, HARD_STONE: 4, DEEP_SLATE: 5,
    COAL: 6, IRON: 7, GOLD: 8, DIAMOND: 9, EMERALD: 10, RUBY: 11,
    CASING: 20, BEDROCK: 99,
    // New Items
    TNT: 50, NUKE: 51, TELEPORTER: 52,
    REPAIR_KIT: 60, FUEL_VOUCHER: 61
};

const TILE_PROPS = {
    [TILE_TYPES.EMPTY]: { name: "Empty", value : -67 },
    [TILE_TYPES.DIRT]: { name: "Dirt", color: '#5d4037', hardness: 0.5, value: 0, tier: 0 },
    [TILE_TYPES.GRASS]: { name: "Grass", color: '#388e3c', hardness: 0.5, value: 0, tier: 0 },
    [TILE_TYPES.STONE]: { name: "Stone", color: '#7f8c8d', hardness: 1, value: 0, tier: 1 },
    [TILE_TYPES.HARD_STONE]: { name: "Dense Stone", color: '#525a5b', hardness: 2, value: 0, tier: 2 },
    [TILE_TYPES.DEEP_SLATE]: { name: "Deep Slate", color: '#2c3e50', hardness: 3, value: 0, tier: 3 },
    [TILE_TYPES.COAL]: { name: "Coal", color: '#2c3e50', hardness: 2, value: 10, tier: 0, trashExclude: true },
    [TILE_TYPES.IRON]: { name: "Iron", color: '#95a5a6', hardness: 2, value: 50, tier: 1, trashExclude: true },
    [TILE_TYPES.GOLD]: { name: "Gold", color: '#f1c40f', hardness: 1, value: 150, tier: 2, trashExclude: true },
    [TILE_TYPES.DIAMOND]: { name: "Diamond", color: '#3498db', hardness: 3, value: 500, tier: 3, trashExclude: true },
    [TILE_TYPES.EMERALD]: { name: "Emerald", color: '#2ecc71', hardness: 3, value: 800, tier: 3, trashExclude: true },
    [TILE_TYPES.RUBY]: { name: "Ruby", color: '#e74c3c', hardness: 3, value: 1200, tier: 4, trashExclude: true },
    [TILE_TYPES.CASING]: { name: "Structure", color: '#95a5a6', hardness: 0.1, value: 0, tier: 0, trashExclude: true },
    [TILE_TYPES.BEDROCK]: { name: "Bedrock", color: '#000000', hardness: 999, value: 67, tier: 99, trashExclude: true },
    // New Items
    [TILE_TYPES.TNT]: { name: "TNT", color: '#e74c3c', hardness: 1, value: 0, tier: 0, trashExclude: true },
    [TILE_TYPES.NUKE]: { name: "Nuke", color: '#2c3e50', hardness: 1, value: 0, tier: 0, trashExclude: true },
    [TILE_TYPES.TELEPORTER]: { name: "Teleporter", color: '#9b59b6', hardness: 5, value: 0, tier: 0, trashExclude: true },
    [TILE_TYPES.REPAIR_KIT]: { name: "Repair Kit", color: '#2ecc71', value: 0, consumable: true, trashExclude: true },
    [TILE_TYPES.FUEL_VOUCHER]: { name: "Fuel Voucher", color: '#e67e22', value: 0, consumable: true, trashExclude: true },
};

const MSGS = {
    join: [
        "spawned in.",
        "slid into the server.",
        "has entered the chat.",
        "is here to steal your ores.",
        "initialized connection.",
        "mounted their filesystem.",
        "is among us.",
        "has joined! Hide your snacks.",
        "*Record scratch* *Freeze frame* Yup, that's <user>. You're probably wondering how they got here.",
        "A wild <user> appeared!",
        "Everyone panic! <user> has arrived!",
        "<user> has joined. The quality of this room just went up by 0.0001%.",
        "<user> is now watching you. (Just kidding... probably.)"
    ],
    leave: [
        "rage quit.",
        "timed out (RIP).",
        "received SIGTERM.",
        "failed to compile.",
        "segfaulted.",
        "touched grass (Fatal Error).",
        "kernel panicked.",
        "unmounted themselves.",
        "decided to touch grass."
    ],
    kick: [
        "was yeeted.",
        "read the TOS wrong.",
        "was shown the door.",
        "forgot to pay rent."
    ],
    ban: [
        "has been banished to the shadow realm.",
        "caught the ban hammer.",
        "was added to the blacklist.",
        "was banished from this kingdom."
    ],
    death: [
        "forgot to breathe.",
        "became bedrock.",
        "needs a tutorial.",
        "rm -rf /'d themselves.",
        "experienced a stack overflow.",
        "dereferenced a null pointer.",
        "got rekt."
    ],
    rescue: ["is running on fumes!", "needs a fuel stim!", "is signaling SOS!"]
};

// --- CUSTOM MODAL SYSTEM ---
class ModalSystem {
    constructor() {
        this.overlay = $('c-modal-overlay');
        this.title = $('c-modal-title');
        this.text = $('c-modal-text');
        this.input = $('c-modal-input');
        this.btnOk = $('c-modal-ok');
        this.btnCancel = $('c-modal-cancel');
        this.resolve = null;

        this.btnOk.onclick = () => this.close(true);
        this.btnCancel.onclick = () => this.close(false);

        // Allow Enter key to confirm in input mode
        this.input.onkeydown = (e) => { if(e.key === 'Enter') this.close(true); };
    }

    show(type, title, msg, defaultVal = '') {
        return new Promise(resolve => {
            this.resolve = resolve;
            this.title.innerText = title;
            this.text.innerText = msg;
            this.input.value = defaultVal;

            // Reset visibility
            this.input.style.display = 'none';
            this.btnCancel.style.display = 'none';
            this.btnOk.innerText = "OK";
            this.btnOk.style.width = "auto";

            if (type === 'prompt') {
                this.input.style.display = 'block';
                this.btnCancel.style.display = 'block';
                setTimeout(() => this.input.focus(), 50);
            } else if (type === 'confirm') {
                this.btnCancel.style.display = 'block';
                this.btnOk.innerText = "Yes";
                this.btnCancel.innerText = "No";
            }

            this.overlay.style.display = 'flex';
        });
    }

    close(result) {
        this.overlay.style.display = 'none';
        if (this.resolve) {
            if (this.input.style.display === 'block') {
                this.resolve(result ? this.input.value : null);
            } else {
                this.resolve(result);
            }
            this.resolve = null;
        }
    }
}
const CustomModal = new ModalSystem();

let initialTimestamp = null;

// --- SOUND ENGINE ---
class SoundManager {
    constructor() {
        this.ctx = null;
        this.nodes = {};
        this.volumes = { master: 0.5, music: 0.5, sfx: 0.5, engine: 0.3 };
        this.playlist = ['audio/Chiptronical.ogg', 'audio/Great_Little_Challenge.ogg', 'audio/Solve_The_Puzzle.ogg', 'audio/Sneaky_Snitch.ogg', 'audio/cozy-lofi-relax-468509.mp3', 'audio/field-duel-lofi-464436.ogg', 'audio/lofi-background-music-3-471122.ogg','audio/chill-lofi-beat-469069.ogg'];
        this.currentTrack = 0;
        this.noiseBuffer = null;
    }

    init() {
        if (!this.ctx) {
            this.ctx = new (window.AudioContext || window.webkitAudioContext)();
            this.noiseBuffer = this.createNoiseBuffer();
            this.setupNodes();
            this.setupEngineLoop();
            this.playNextMusic();
        } else if (this.ctx.state === 'suspended') {
            this.ctx.resume();
        }
    }

    setupNodes() {
        this.nodes.master = this.ctx.createGain();
        this.nodes.master.gain.value = this.volumes.master;
        this.nodes.master.connect(this.ctx.destination);

        this.nodes.music = this.ctx.createGain();
        this.nodes.music.gain.value = this.volumes.music;
        this.nodes.music.connect(this.nodes.master);

        this.nodes.sfx = this.ctx.createGain();
        this.nodes.sfx.gain.value = this.volumes.sfx;
        this.nodes.sfx.connect(this.nodes.master);

        this.nodes.engine = this.ctx.createGain();
        this.nodes.engine.gain.value = this.volumes.engine;
        this.nodes.engine.connect(this.nodes.master);
    }

    setVolume(type, val) {
        this.volumes[type] = parseFloat(val);
        if (this.nodes[type]) this.nodes[type].gain.setTargetAtTime(this.volumes[type], this.ctx.currentTime, 0.1);
        else if (type === 'master' && this.nodes.master) this.nodes.master.gain.setTargetAtTime(this.volumes[type], this.ctx.currentTime, 0.1);
        $(`vol-disp-${type}`).innerText = Math.round(val*100) + '%';
        localStorage.setItem(`mm_vol_${type}`, val);
    }

    createNoiseBuffer() {
        if (!this.ctx) return null;
        const bufSize = this.ctx.sampleRate * 2;
        const buffer = this.ctx.createBuffer(1, bufSize, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufSize; i++) data[i] = Math.random() * 2 - 1;
        return buffer;
    }

    setupEngineLoop() {
        const noise = this.ctx.createBufferSource();
        noise.buffer = this.noiseBuffer;
        noise.loop = true;
        const filter = this.ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 100;
        const gain = this.ctx.createGain();
        gain.gain.value = 0;
        noise.connect(filter);
        filter.connect(gain);
        gain.connect(this.nodes.engine);
        noise.start();

        this.nodes.engineRumbleGain = gain;
        this.nodes.engineFilter = filter;

        const grindNoise = this.ctx.createBufferSource();
        grindNoise.buffer = this.noiseBuffer;
        grindNoise.loop = true;
        grindNoise.playbackRate.value = 0.5;

        const grindFilter = this.ctx.createBiquadFilter();
        grindFilter.type = 'bandpass';
        grindFilter.frequency.value = 150;
        grindFilter.Q.value = 1.0;

        const grindGain = this.ctx.createGain();
        grindGain.gain.value = 0;

        grindNoise.connect(grindFilter);
        grindFilter.connect(grindGain);
        grindGain.connect(this.nodes.engine);
        grindNoise.start();

        this.nodes.drillGain = grindGain;
        this.nodes.drillFilter = grindFilter;
    }

    updateEngine(speed, isDrilling) {
        if (!this.ctx || !this.nodes.engineRumbleGain || !this.nodes.engineFilter || !this.nodes.drillGain || !this.nodes.drillFilter) return;

        const t = this.ctx.currentTime;
        let baseVol = (speed > 0.1) ? 0.3 : 0.05;
        let baseFreq = 60 + (speed * 30);

        this.nodes.engineRumbleGain.gain.setTargetAtTime(baseVol, t, 0.2);
        this.nodes.engineFilter.frequency.setTargetAtTime(baseFreq, t, 0.2);

        if (isDrilling) {
            this.nodes.drillGain.gain.setTargetAtTime(0.5, t, 0.05);
            this.nodes.drillFilter.frequency.setTargetAtTime(150 + Math.random()*100, t, 0.1);
        } else {
            this.nodes.drillGain.gain.setTargetAtTime(0, t, 0.1);
        }
    }

    playTone(freq, type, duration, vol = 0.1) {
        if (!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
        osc.connect(gain);
        gain.connect(this.nodes.sfx);
        osc.start();
        osc.stop(this.ctx.currentTime + duration);
    }

    // Add this inside your SoundManager class
    playTimerBlip(urgencyLevel) {
        if (!this.ctx) return;

        // urgencyLevel should be between 0 (start) and 1 (about to explode)
        // Pitch goes from 800Hz to 1200Hz
        const freq = 800 + (urgencyLevel * 400);

        // Very short duration (0.05s) for a crisp "blip"
        this.playTone(freq, 'sine', 0.05, 0.3);
    }

    playMining() {
        if (!this.ctx || !this.noiseBuffer) return;
        const t = this.ctx.currentTime;

        const src = this.ctx.createBufferSource();
        src.buffer = this.noiseBuffer;
        src.playbackRate.value = 0.4 + Math.random() * 0.2;

        const filter = this.ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 500;

        const gain = this.ctx.createGain();
        gain.gain.setValueAtTime(0.5, t);
        gain.gain.exponentialRampToValueAtTime(0.01, t + 0.15);

        src.connect(filter);
        filter.connect(gain);
        gain.connect(this.nodes.sfx);
        src.start();
        src.stop(t + 0.15);
    }

    playChat(type) {
        if (type==='join') { this.playTone(440, 'sine', 0.1); setTimeout(()=>this.playTone(880, 'sine', 0.2), 100); }
        else if (type==='leave') { this.playTone(440, 'sine', 0.1); setTimeout(()=>this.playTone(220, 'sine', 0.2), 100); }
        else if (type==='death') { this.playTone(100, 'sawtooth', 0.5, 0.2); }
        else this.playTone(600, 'triangle', 0.05);
    }
    playError() { this.playTone(150, 'sawtooth', 0.3, 0.1); }
    playSuccess() { this.playTone(800, 'sine', 0.1); setTimeout(()=>this.playTone(1200, 'sine', 0.2), 100); }
    playBuild() { this.playTone(300, 'square', 0.1); }
    playThud() { this.playTone(80, 'square', 0.1, 0.3); }

    playExplosion() {
      // Simple explosion synth
      if(!this.ctx) return;
      this.playTone(100, 'sawtooth', 0.5, 0.5);
      this.playTone(50, 'square', 0.6, 0.5);
    }

    playNextMusic() {
      try{
        if(this.musicSource) { this.musicSource.stop(); }
        this.currentTrack = Math.floor(Math.random() * 100) % this.playlist.length;
        const file = this.playlist[this.currentTrack];
        const audio = new Audio(file);
        const source = this.ctx.createMediaElementSource(audio);
        source.connect(this.nodes.music);
        audio.onended = () => this.playNextMusic();
        audio.onerror = () => { console.log("Music load failed, skipping"); this.playNextMusic(); };
        audio.play().catch(e=>console.log("Autoplay blocked"));
      }catch(e){
        console.error("Error playing music:", e);
      }
    }

    loadSettings() {
        ['master', 'music', 'sfx', 'engine'].forEach(t => {
            const v = localStorage.getItem(`mm_vol_${t}`);
            if(v !== null) {
                this.volumes[t] = parseFloat(v);
                $(`vol-${t}`).value = v;
                $(`vol-disp-${t}`).innerText = Math.round(v*100) + '%';
            }
        });
    }
}
const Sound = new SoundManager();

// --- GAME LOGIC ---

class GameEngine {
    constructor() {
        this.canvas = $('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.minimapCanvas = $('minimap');
        this.minimapCtx = this.minimapCanvas.getContext('2d');

        this.running = false;
        this.isMobile = false;

        this.settings = {
            username: '',
            color: '#3498db',
            broker: 'wss://broker.emqx.io:8084/mqtt',
            room: 'public',
            keys: {
                up: 'ArrowUp', left: 'ArrowLeft', right: 'ArrowRight', down: 'ArrowDown',
                build: 'b', interact: 'e', chat: 'Enter', transfer: 'f'
            }
        };

        this.localPlayer = {
            id: uuid(),
            gridX: CONSTANTS.MAP_WIDTH/2, gridY: 4,
            x: 0, y: 0,
            fuel: 100, maxFuel: 100,
            hull: 100, maxHull: 100,
            cargo: 0, maxCargo: 50,
            money: 0,
            temp: 0, maxTemp: 100,
            rotation: 0, isDrilling: false,
            drillTier: 0, heatResist: 0, xrayRange: 6,
            inventory: {},
            selectedBlock: TILE_TYPES.CASING,
            stats: { blocksMined: {}, totalMined: 0, startTime: now() },
            joinedAt: now(),
            teleporters: [] // Discovered teleporters list
        };

        this.map = [];
        this.discovered = [];
        this.remotePlayers = {};
        this.camera = { x: 0, y: 0 };
        this.zoom = 1.0;
        this.particles = [];
        this.explosives = []; // Track active TNT/Nuke timers
        this.isAdmin = false;
        this.hostId = null;
        this.bannedIds = JSON.parse(localStorage.getItem('mm_banned') || '[]');
        this.lastActionTime = 0;
        this.lastAutosave = 0;
        this.lastViewportSync = 0; // NEW: Timer for aggressive sync
        this.fallHeight = 0;
        this.stationGridX = CONSTANTS.MAP_WIDTH / 2;
        this.stationGridY = 4;
        this.lastHostHeartbeat = 0;

        this.loadStoredSettings();
    }

    // --- NEW: Persistent Stats (Wallet, Upgrades) ---
    saveLocalProgress() {
        if (!this.running) return;
        const data = {
            money: this.localPlayer.money,
            drillTier: this.localPlayer.drillTier,
            maxHull: this.localPlayer.maxHull,
            maxFuel: this.localPlayer.maxFuel,
            maxCargo: this.localPlayer.maxCargo,
            heatResist: this.localPlayer.heatResist,
            xrayRange: this.localPlayer.xrayRange,
            vehColor: this.settings.color,
            teleporters: this.localPlayer.teleporters || []
        };
        localStorage.setItem(`mm_stats_${this.settings.room}`, JSON.stringify(data));
    }

    loadLocalProgress() {
        try {
            const raw = localStorage.getItem(`mm_stats_${this.settings.room}`);
            if (raw) {
                const data = JSON.parse(raw);
                const p = this.localPlayer;
                if (data.money !== undefined) p.money = data.money;
                if (data.drillTier) p.drillTier = data.drillTier;
                if (data.maxHull) { p.maxHull = data.maxHull; p.hull = p.maxHull; }
                if (data.maxFuel) { p.maxFuel = data.maxFuel; p.fuel = p.maxFuel; }
                if (data.maxCargo) p.maxCargo = data.maxCargo;
                if (data.heatResist) p.heatResist = data.heatResist;
                if (data.xrayRange) p.xrayRange = data.xrayRange;
                if (data.teleporters) p.teleporters = data.teleporters;
                if (data.vehColor) {
                    this.settings.color = data.vehColor;
                    $('start-color').value = data.vehColor;
                }
                console.log("Stats loaded from local storage.");
            }
        } catch(e) { console.error("Failed to load stats", e); }
    }

    checkHostHealth() {
        const nowTime = Date.now();

        // If I am Admin, I am the host.
        if (this.isAdmin) {
            this.hostId = this.localPlayer.id;
            this.lastHostHeartbeat = nowTime;
            return;
        }

        // If no host heard for 10 seconds, trigger election
        if (nowTime - this.lastHostHeartbeat > 10000) {
            this.electNewHost();
        }
    }

    electNewHost() {
        // Find oldest player including myself
        const all = Object.values(this.remotePlayers)
            .concat([this.localPlayer])
            .filter(p => p && p.joinedAt);

        // Sort by age
        all.sort((a, b) => a.joinedAt - b.joinedAt);

        // If I am the oldest survivor, I claim the throne
        if (all.length > 0 && all[0].id === this.localPlayer.id) {
            console.log("Host timed out. Claiming Host status.");
            this.isAdmin = true;
            this.hostId = this.localPlayer.id;
            this.lastHostHeartbeat = Date.now();
            Network.broadcastHostClaim(); // Tell everyone immediately
            UI.showToast("You are now the Admin (Host)", "success");
            UI.updateAdminPanel();
        }
    }
    loadStoredSettings() {
        if(localStorage.getItem('mm_graphics_quality')) $('graphicsQuality').value = localStorage.getItem('mm_graphics_quality');
        if(localStorage.getItem('mm_username')) $('start-username').value = localStorage.getItem('mm_username');
        if(localStorage.getItem('mm_room_id')) $('start-room').value = localStorage.getItem('mm_room_id');
        if(localStorage.getItem('mm_veh_color')) $('start-color').value = localStorage.getItem('mm_veh_color');
        const showCoords = localStorage.getItem('mm_show_coords');
        if(showCoords === 'true') { $('coords-toggle').checked = true; this.toggleCoords(true); }

        // Load broker from storage or use default if none
        const storedBroker = localStorage.getItem('mm_broker_url');
        if (storedBroker) {
            this.settings.broker = storedBroker;
            $('setting-broker').value = storedBroker;
        } else {
            // Ensure input matches default if nothing stored
            $('setting-broker').value = this.settings.broker;
        }
        const binds = localStorage.getItem('mm_keybinds');
        if(binds) {
            try { this.settings.keys = {...this.settings.keys, ...JSON.parse(binds)}; } catch(e){console.error(e);}
        }

        // Mobile setting
        const mobile = localStorage.getItem('mm_mobile_mode') === 'true';
        $('mobile-toggle').checked = mobile;
        $('mobile-setting-toggle').checked = mobile;
        this.toggleMobile(mobile);
    }

    toggleMobile(enabled) {
        this.isMobile = enabled;
        localStorage.setItem('mm_mobile_mode', enabled);

        if (enabled && this.running) {
            document.body.classList.add('mobile-mode');
            // Auto-minimize chat when entering mobile mode
            $('chat-container').classList.add('minimized');
        } else {
            document.body.classList.remove('mobile-mode');
            $('chat-container').classList.remove('minimized');
        }
        this.resize();
    }

    // Helper to get base procedural for syncing
    getProceduralTile(x, y) {
        if (y < 5) return TILE_TYPES.EMPTY;
        if (y === 5) return TILE_TYPES.GRASS;
        if (y === CONSTANTS.MAP_HEIGHT - 1) return TILE_TYPES.BEDROCK;

        // 1. Determine the base background tile
        let type = TILE_TYPES.DIRT;
        if (y > 300) type = TILE_TYPES.DEEP_SLATE;
        else if (y > 100) type = TILE_TYPES.HARD_STONE;
        else if (y > 30) type = TILE_TYPES.STONE;

        // 2. Get the main "Rarity" roll for this tile
        let r = Game.getMapRandom(x, y);

        // 3. Check for Rare Ores (Ruby, Emerald, Diamond)
        if (r > 0.985) {
            const oreRoll = Game.getMapRandom(x, y + 10000);

            if (y > 400 && oreRoll < 0.2) return TILE_TYPES.RUBY;       // 20% of rare ores
            else if (y > 250 && oreRoll < 0.6) return TILE_TYPES.EMERALD; // 40% of rare ores
            else if (y > 150) return TILE_TYPES.DIAMOND;                // Fallback for the rest
        }

        // 4. Standard Ores
        if (r > 0.96 && y > 100) return TILE_TYPES.GOLD;
        if (r > 0.92 && y > 50) return TILE_TYPES.IRON;
        if (r > 0.89) return TILE_TYPES.COAL;

        return type;
    }

    async randomizeUsername() {
        // UI feedback
        const btn = $('start-username').nextElementSibling;
        const originalText = btn.innerHTML;
        btn.innerHTML = '<div class="spin-loader" style="width:12px; height:12px; border-width:2px;"></div>';

        try {
            const res = await fetch('https://randomuser.me/api?inc=login');
            const data = await res.json();
            if (data.results && data.results[0]) {
                let name = data.results[0].login.username;
                // Clean up name slightly if it's too long
                if(name.length > 12) name = name.substring(0, 12);
                $('start-username').value = name;
            } else {
                throw new Error("Invalid API response");
            }
        } catch(e) {
            console.error("API Error, using fallback", e);
            $('start-username').value = 'Miner' + Math.floor(Math.random() * 1000);
        } finally {
             btn.innerHTML = originalText;
        }
    }

    setGraphicsQuality(quality){
        this.settings.graphicsQuality = quality;
        localStorage.setItem('mm_graphics_quality',quality);
        console.debug("graphics set to: " + quality +"\nlocalStorage value is:" + localStorage.getItem('mm_graphics_quality'));
    }

    async init() {
        this.settings.username = $('start-username').value || 'Miner' + Date.now();
        this.localPlayer.username = this.settings.username;
        // FIX: Trim room ID to ensure seeds match perfectly across clients
        this.settings.room = ($('start-room').value || 'public').trim();
        this.settings.color = $('start-color').value;
        this.settings.broker = $('setting-broker').value;
        this.settings.graphicsQuality = $('graphicsQuality').value || 3;
        // Reset admin on init
        this.isAdmin = false;

        // --- STICKY TIMESTAMP LOGIC ---
        // Restore timestamp for this specific room if it exists
        const timeKey = `mm_joinedAt_${this.settings.room}`;
        const savedTime = localStorage.getItem(timeKey);

        if (savedTime) {
            // Restore previous session time to regain seniority
            this.localPlayer.joinedAt = parseInt(savedTime);
            console.log("Restored session time:", this.localPlayer.joinedAt);
        } else {
            // New session
            this.localPlayer.joinedAt = now();
            localStorage.setItem(timeKey, this.localPlayer.joinedAt);
        }

        localStorage.setItem('mm_username', this.settings.username);
        localStorage.setItem('mm_room_id', this.settings.room);
        localStorage.setItem('mm_veh_color', this.settings.color);
        localStorage.setItem('mm_broker_url', this.settings.broker);

        $('start-screen').style.display = 'none';
        $('connection-screen').style.display = 'flex';
        this.logConnection("Initializing System...");

        if (puter.whoami && SaveSystem.cloudSyncEnabled) {
            await this.logConnection("Running sync task...");
            await SaveSystem.smartSyncAll(true, true);
            this.lastAutosave = now();
        } else {
            this.logConnection(`Skipping sync task (${puter.whoami ? "auto-sync off" : "not signed in"}}`);
        }

        this.resize();
        window.addEventListener('resize', () => this.resize());
        window.addEventListener('wheel', (e) => {
            if (e.target.id === 'gameCanvas') {
                this.zoom = clamp(this.zoom - Math.sign(e.deltaY) * 0.1, CONSTANTS.MIN_ZOOM, CONSTANTS.MAX_ZOOM);
            }
        });

        this.minimapCanvas.width = 150;
        this.minimapCanvas.height = 150;

        let seed = 0;
        for (let i = 0; i < this.settings.room.length; i++) seed += this.settings.room.charCodeAt(i);
        this.roomSeed = seed * 12345;

        this.generateMap();
        Input.init();
        Sound.loadSettings();

        // Load stats before connecting
        this.loadLocalProgress();

        Network.connect();
        UI.refreshKeybindLabels();
        UI.checkForUpdates();

        // Start a new session tracking
        if (!SaveSystem.currentSaveId) SaveSystem.currentSaveId = Date.now();
    }

    logConnection(msg) {
        const d = document.createElement('div');
        d.className = 'log-line';
        d.innerText = `> ${msg}`;
        $('connection-log').appendChild(d);
        $('connection-log').scrollTop = $('connection-log').scrollHeight;
    }

    finishConnection() {
        // Critical: Do not re-initialize game state if we just reconnected
        if (this.running) {
            console.log("Reconnected to broker. Game state preserved.");
            $('connection-screen').style.display = 'none';
            // Just broadcast position to sync up
            Network.broadcastMove();
            return;
        }

        setTimeout(async () => {
            $('connection-screen').style.display = 'none';

            this.running = true;
            this.toggleMobile($("mobile-toggle").checked)
            this.localPlayer.gridX = Math.floor(CONSTANTS.MAP_WIDTH / 2);
            this.localPlayer.gridY = 4;
            this.localPlayer.x = this.localPlayer.gridX * CONSTANTS.TILE_SIZE;
            this.localPlayer.y = this.localPlayer.gridY * CONSTANTS.TILE_SIZE;
            this.localPlayer.stats.startTime = now();
            Sound.init();

            // Initial Host Check: If I'm alone, I am Admin.
            if (Object.keys(this.remotePlayers).length === 0) {
                this.isAdmin = true;
                this.hostId = this.localPlayer.id;
                this.lastHostHeartbeat = Date.now();
                UI.showToast("Room Created. You are Admin.", "success");
                UI.updateAdminPanel();
            } else {
                // If others exist, wait for heartbeat.
                // If no heartbeat comes in loop(), checkHostHealth() will elect me if I'm oldest.
                this.isAdmin = false;
                UI.updateAdminPanel();
            }

            // ONLY load save if we are the host (Admin)
            if (this.isAdmin) {
                const lastId = localStorage.getItem('mm_last_save_id');
                if (lastId) {
                    console.log("Host detected, loading save:", lastId);
                    await SaveSystem.loadGame(parseInt(lastId), true);
                    UI.addMessage("System", "Auto-loaded previous save.", "#2ecc71");
                }
            } else {
                // If we are NOT admin (Client), ensure we rely on the procedural map + sync
                // We do NOT load any local saves to prevent overwriting the host's world
                Network.requestMap(null); // Request from host (broadcast if id is null or not found, see handler)
                UI.addMessage("System", "Waiting for Map Sync...", "#3498db");
            }

            this.loop();
            UI.addMessage("System", "Welcome. E for Menu/Shop. B to Build. F to Transfer.", "#FFFF00");
            Network.broadcastMove();
            // Removed updateAdminStatus call
        }, 1000);
    }

    resize() {
        if (this.isMobile) {
            if (window.innerWidth > window.innerHeight) {
                // Landscape: 200px buffer on each side (400px total)
                this.canvas.width = window.innerWidth - 400;
                this.canvas.height = window.innerHeight;
            } else {
                // Portrait: Bottom bar
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight - 180; // 180px for controls
            }
        } else {
            this.canvas.width = window.innerWidth;
            this.canvas.height = window.innerHeight;
        }
    }

    generateMap() {
        for (let y = 0; y < CONSTANTS.MAP_HEIGHT; y++) {
            this.map[y] = [];
            this.discovered[y] = new Uint8Array(CONSTANTS.MAP_WIDTH);
            for (let x = 0; x < CONSTANTS.MAP_WIDTH; x++) {
                if (y < 5) {
                    this.map[y][x] = TILE_TYPES.EMPTY;
                    this.discovered[y][x] = 1;
                }
                else if (y === 5) {
                     this.map[y][x] = TILE_TYPES.GRASS;
                     this.discovered[y][x] = 1;
                }
                else if (y === CONSTANTS.MAP_HEIGHT - 1) this.map[y][x] = TILE_TYPES.BEDROCK;
                else {
                    this.map[y][x] = this.getProceduralTile(x,y);
                }
            }
        }
    }

    getMapRandom(x, y) {
        const s = Math.sin(x * 12.9898 + y * 78.233 + this.roomSeed) * 43758.5453;
        return s - Math.floor(s);
    }

    toggleCoords(show) {
        $('coords-display').style.display = show ? 'block' : 'none';
        localStorage.setItem('mm_show_coords', show);
    }

    update() {
        if (!this.running) return;
        const p = this.localPlayer;
        const TS = CONSTANTS.TILE_SIZE;

        // --- 1. DETERMINE DESTINATION ---
        let destGridX = (p.nextGridX !== undefined) ? p.nextGridX : p.gridX;
        let destGridY = (p.nextGridY !== undefined) ? p.nextGridY : p.gridY;

        let targetX = destGridX * TS;
        let targetY = destGridY * TS;
        let dx = targetX - p.x;
        let dy = targetY - p.y;
        let dist = Math.sqrt(dx * dx + dy * dy);

        // --- 2. CALCULATE HARDNESS (Look Ahead) ---
        let currentHardness = 1;
        if (p.isDrilling) {
            // Look at the destination tile
            const tileType = this.map[destGridY]?.[destGridX];
            currentHardness = TILE_PROPS[tileType]?.hardness || 1;
        }

        // --- 3. CALCULATE SPEED (With Drill Tier) ---
        // Formula: (Base Speed * Tier Multiplier) / Block Hardness
        // Example: Tier 0 (1.0x) vs Hardness 2 = 50% Speed
        // Example: Tier 4 (3.0x) vs Hardness 2 = 150% Speed
        let tierMultiplier = 1 + (p.drillTier * 0.5);
        let drillSpeed = (CONSTANTS.SPEED_DRILL * tierMultiplier) / currentHardness;

        // Determine final movement speed
        let speed = Math.min(p.fuel > 0 ? (p.isDrilling ? drillSpeed : CONSTANTS.SPEED_NORMAL) : 0.3, CONSTANTS.SPEED_NORMAL);

        let isMoving = false;

        // --- 4. MOVEMENT LOOP ---
        if (dist > speed) {
            let angle = Math.atan2(dy, dx);
            p.x += Math.cos(angle) * speed;
            p.y += Math.sin(angle) * speed;
            isMoving = true;
        } else {
            // --- 5. ARRIVAL & EXECUTION ---
            p.x = targetX;
            p.y = targetY;
            p.isDrilling = false;

            // If we just finished a move (nextGridX is set)
            if (p.nextGridX !== undefined) {

                // EXECUTE MINING (testOnly = false):
                // Actually remove the block and give items now that we are here.
                let tileAtDest = this.map[p.nextGridY][p.nextGridX];
                if (tileAtDest !== TILE_TYPES.EMPTY && tileAtDest !== TILE_TYPES.TELEPORTER) {
                    this.tryMine(p.nextGridX, p.nextGridY, false);
                }

                // Finalize position update
                p.gridX = p.nextGridX;
                p.gridY = p.nextGridY;
                p.nextGridX = undefined;
                p.nextGridY = undefined;
            }

            // --- 6. INPUT DETECTION ---
            let ix = 0, iy = 0;
            if (Input.keys[this.settings.keys.up] || Input.virtual.up) iy = -1;
            else if (Input.keys[this.settings.keys.down] || Input.virtual.down) iy = 1;
            else if (Input.keys[this.settings.keys.left] || Input.virtual.left) ix = -1;
            else if (Input.keys[this.settings.keys.right] || Input.virtual.right) ix = 1;

            // Build logic
            const buildPressed = Input.keys[this.settings.keys.build] || Input.virtual.build;

            if (buildPressed && (ix || iy)) {
                if (now() - this.lastActionTime > 200) {
                    this.tryBuild(p.gridX + ix, p.gridY + iy);
                    this.lastActionTime = now();
                }
            } else if (ix || iy) {
                // Rotation
                if (ix === 1) p.rotation = -90 * (Math.PI / 180);
                if (ix === -1) p.rotation = 90 * (Math.PI / 180);
                if (iy === 1) p.rotation = 0;
                if (iy === -1) p.rotation = 180 * (Math.PI / 180);

                let nx = p.gridX + ix;
                let ny = p.gridY + iy;

                // Bounds Check
                if (nx >= 0 && nx < CONSTANTS.MAP_WIDTH && ny >= 4 && ny < CONSTANTS.MAP_HEIGHT) {
                    let tile = (ny < 0) ? TILE_TYPES.EMPTY : this.map[ny][nx];

                    // Teleporter Discovery
                    if (tile === TILE_TYPES.TELEPORTER) {
                        const known = p.teleporters.find(t => t.x === nx && t.y === ny);
                        if (!known) {
                            p.teleporters.push({ x: nx, y: ny, name: `Relay [${nx},${ny}]` });
                            UI.showToast("New Teleporter Discovered!", "success");
                            this.saveLocalProgress();
                        }
                    }

                    // --- MOVEMENT REQUEST ---
                    if (tile === TILE_TYPES.EMPTY || tile === TILE_TYPES.TELEPORTER) {
                        // Moving into empty space
                        p.nextGridX = nx; p.nextGridY = ny;
                        if (p.gridY > 5 && p.fuel > 0) p.fuel -= CONSTANTS.FUEL_CONSUMPTION;
                        Network.broadcastMove();
                    }
                    else if (tile !== TILE_TYPES.BEDROCK) {
                        if (now() - this.lastActionTime > 150) {

                            // CHECK IF MINABLE (testOnly = true)
                            // This checks if we have the correct Drill Tier to even start mining
                            if (this.tryMine(nx, ny, true)) {
                                p.nextGridX = nx; p.nextGridY = ny;
                                p.isDrilling = true; // Start drilling animation
                                if (p.gridY > 5 && p.fuel > 0) p.fuel -= CONSTANTS.FUEL_CONSUMPTION;
                                Network.broadcastMove();
                            }
                            this.lastActionTime = now();
                        }
                    }
                }
            }
        }

        // Explosive Logic (Host Only)
        if (this.isAdmin && this.explosives.length > 0) {
            for (let i = this.explosives.length - 1; i >= 0; i--) {
                let e = this.explosives[i];
                if (!e.doneAt) e.doneAt = Date.now() + e.timer;
                if (!e.sent) {
                    Network.broadcastExplosion(e.x, e.y, e.range, e.timer);
                    e.sent = true;
                }
                if (Date.now() >= e.doneAt) this.explosives.splice(i, 1);
            }
        }

        Sound.updateEngine(isMoving ? speed : 0, p.isDrilling);

        // Remote Interpolation
        Object.values(this.remotePlayers).forEach(rp => {
            if (rp.targetX !== undefined) {
                let rdx = rp.targetX - rp.x; let rdy = rp.targetY - rp.y;
                let rDist = Math.sqrt(rdx * rdx + rdy * rdy);
                let rSpeed = rp.isDrilling ? CONSTANTS.SPEED_DRILL : CONSTANTS.SPEED_NORMAL;
                if (rDist > rSpeed) {
                    let rAngle = Math.atan2(rdy, rdx);
                    rp.x += Math.cos(rAngle) * rSpeed; rp.y += Math.sin(rAngle) * rSpeed;
                } else { rp.x = rp.targetX; rp.y = rp.targetY; }
            }
        });

        // Heat & Prompt
        // Use destGridY for depth check so heat updates as we drill down, not after
        let depthY = (p.nextGridY !== undefined) ? p.nextGridY : p.gridY;
        let depth = Math.max(0, depthY - 5);

        let heatThreshold = 100 + (p.heatResist * 50);
        if (depth > heatThreshold) {
            p.temp += 0.05;
            if (p.temp > 100) { p.temp = 100; p.hull -= 0.1; $('heat-overlay').style.opacity = (Math.sin(now() / 100) + 1) / 4 + 0.3; }
        } else { p.temp = Math.max(0, p.temp - 0.2); $('heat-overlay').style.opacity = 0; }

        $('prompt-msg').style.display = 'none';

        if (this.map[p.gridY][p.gridX] === TILE_TYPES.TELEPORTER) {
            $('prompt-msg').style.display = 'block';
            $('prompt-msg').innerText = "PRESS E TO WARP";
        }

        if (p.gridY === this.stationGridY && Math.abs(p.gridX - this.stationGridX) < 3) {
            $('prompt-msg').style.display = 'block';
            $('prompt-msg').innerText = "PRESS E TO OPEN DASHBOARD/SHOP";
        }

        const interactPressed = Input.keys[this.settings.keys.interact] || Input.virtual.interact;
        if (interactPressed && now() - this.lastActionTime > 500) {
            if (this.map[p.gridY][p.gridX] === TILE_TYPES.TELEPORTER) {
                UI.openWarpMenu();
            } else {
                UI.toggleDashboard();
            }
            this.lastActionTime = now();
            Input.virtual.interact = false;
        }

        const transferPressed = Input.keys[this.settings.keys.transfer] || Input.virtual.transfer;
        if (transferPressed && now() - this.lastActionTime > 1000) {
            let nearest = null;
            let minDst = 100;
            Object.values(this.remotePlayers).forEach(rp => {
                let d = Math.sqrt((rp.x - p.x) ** 2 + (rp.y - p.y) ** 2);
                if (d < minDst) { minDst = d; nearest = rp; }
            });

            if (nearest) {
                this.tryTransferFuel(nearest.id);
            } else {
                UI.showToast("No one nearby to transfer to!", "error");
            }
            this.lastActionTime = now();
            Input.virtual.transfer = false;
        }

        if (Input.virtual.chat && now() - this.lastActionTime > 200) {
            $('chat-container').classList.toggle('minimized');
            $('chat-input').focus();
            Input.virtual.chat = false;
        }
        if (Input.virtual.adminToggle && now() - this.lastActionTime > 200) {
            UI.toggleAdminPanel();
            Input.virtual.adminToggle = false;
        }

        p.fuel = clamp(p.fuel, 0, p.maxFuel); p.hull = clamp(p.hull, 0, p.maxHull);
        if (p.hull <= 0) this.respawn();

        this.camera.x += (p.x - this.camera.x) * 0.1;
        this.camera.y += (p.y - this.camera.y) * 0.1;

        if (now() % 10000 < 20) this.saveLocalProgress();
        if (SaveSystem.autosaveEnabled && now() - this.lastAutosave > 60000 && Game.isAdmin && SaveSystem.currentSaveId) {
            SaveSystem.saveGame(SaveSystem.currentSaveId, null, true); this.lastAutosave = now();
        }

        Network.update();
        this.checkHostHealth();

        if (this.lastCoordsX !== p.gridX || this.lastCoordsY !== p.gridY) {
            $('coords-display').innerText = `X: ${p.gridX} Y: ${depth}`;
            this.lastCoordsX = p.gridX; this.lastCoordsY = p.gridY;
        }
    }

    tryTransferFuel(targetId) {
        if (this.localPlayer.fuel > 10) {
            this.localPlayer.fuel -= 10;
            Network.sendFuel(targetId, 10);
            UI.showToast("Sent 10 Fuel!", "success");
            Sound.playSuccess();
        } else {
            UI.showToast("Not enough fuel!", "error");
            Sound.playError();
        }
    }
    async tryBuild(tx, ty) {
        if (tx < 0 || tx >= CONSTANTS.MAP_WIDTH || ty < 4 || ty >= CONSTANTS.MAP_HEIGHT) return;
        if (this.map[ty][tx] === TILE_TYPES.EMPTY) {
            const type = this.localPlayer.selectedBlock;
            let count = this.localPlayer.inventory[type] || 0;

            if (count > 0) {
                // If placing a Teleporter, name it!
                if(type === TILE_TYPES.TELEPORTER) {
                    // --- MODAL REPLACEMENT ---
                    const name = await CustomModal.show('prompt', "Teleporter Setup", "Name this Teleporter:", `Relay ${tx}-${ty}`);
                    if(!name) return; // Cancel build if canceled

                    this.localPlayer.teleporters.push({
                        x: tx, y: ty, name: name || `Relay ${tx}-${ty}`
                    });
                    this.saveLocalProgress();
                }

                this.localPlayer.inventory[type]--;
                this.localPlayer.cargo--;
                this.map[ty][tx] = type;
                Network.sendTileUpdate(tx, ty, type);
                this.spawnParticle(tx * 32 + 16, ty * 32 + 16, '#95a5a6', 5);
                Sound.playBuild();
                // Host logic: Register explosive timer
                if (this.isAdmin) {
                    if (type === TILE_TYPES.TNT) this.explosives.push({x:tx, y:ty, range:3, timer: 2000}); // 2s
                    if (type === TILE_TYPES.NUKE) this.explosives.push({x:tx, y:ty, range:10, timer: 5000}); // 5s
                }
                UI.showToast("Block Placed", "success");
                UI.updateDashboard();
            } else {
                UI.showToast("Out of blocks!", "error");
                Sound.playError();
            }
        }
    }

    startCountdownEffect(durationMs) {
        const startTime = Date.now();
        const endTime = startTime + durationMs;

        const tick = () => {
            const now = Date.now();
            const remaining = endTime - now;

            // Stop if we are out of time (Explosion logic handles the boom)
            if (remaining <= 0) return;

            // 1. Calculate Urgency (0.0 = Start, 1.0 = End)
            // We use this to pitch-shift the sound up
            const urgency = 1 - (remaining / durationMs);

            // 2. Play Sound
            Sound.playTimerBlip(urgency);

            // 3. Calculate delay until NEXT blip
            // The closer we are to 0, the shorter the delay.
            // Example logic:
            // > 2000ms left: Beep every 800ms
            // > 1000ms left: Beep every 400ms
            // > 0ms left:    Beep every 100ms

            let nextDelay = 800; // Default slow beep
            if (remaining < 500) nextDelay = 50;        // Panic mode!
            else if (remaining < 1500) nextDelay = 150; // Fast
            else if (remaining < 3000) nextDelay = 400; // Medium

            // Schedule the next beep
            setTimeout(tick, nextDelay);
        };

        // Start the loop
        tick();
    }

    // --- EXPLOSION ---
    explode(cx, cy, radius, delay) {
        this.startCountdownEffect(delay);
        setTimeout(function(){
            Sound.playExplosion();
            // Shake camera
            const shake = setInterval(() => {
                Game.camera.x += (Math.random()-0.5)*10;
                Game.camera.y += (Math.random()-0.5)*10;
            }, 20);
            setTimeout(() => clearInterval(shake), 300);

            for (let y = cy - radius; y <= cy + radius; y++) {
                for (let x = cx - radius; x <= cx + radius; x++) {
                    if (y > 4 && x >= 0 && x < CONSTANTS.MAP_WIDTH && y < CONSTANTS.MAP_HEIGHT) {
                        if (Math.sqrt((x-cx)**2 + (y-cy)**2) <= radius) {
                            if (Game.map[y][x] !== TILE_TYPES.BEDROCK) {
                                // console.debug(`Explosion affects tile at (${x},${y}) of type ${TILE_PROPS[Game.map[y][x]].name}`);
                                if (Game.map[y][x] >= TILE_TYPES.COAL && Game.map[y][x] <= TILE_TYPES.RUBY) {
                                    const oreType = Game.map[y][x];
                                    console.debug(`Collecting ore: ${TILE_PROPS[oreType].name} (id: ${oreType}) from explosion`);
                                    Game.localPlayer.inventory[oreType]= (Game.localPlayer.inventory[oreType] || 0) + 1;
                                    Game.localPlayer.stats.blocksMined[oreType]= (Game.localPlayer.stats.blocksMined[oreType] || 0) + 1;
                                    Game.localPlayer.stats.totalMined++;
                                    Game.localPlayer.cargo++;
                                    UI.updateDashboard();
                                }

                                Game.map[y][x] = TILE_TYPES.EMPTY;
                                Game.discovered[y][x] = 1; // Reveal area
                                Game.spawnParticle(x*32+16, y*32+16, '#ffaa00', 3);
                            }
                        }
                    }
                }
            }

            // Damage players
            const p = Game.localPlayer;
            if (Math.abs(p.gridX - cx) < 4 && Math.abs(p.gridY - cy) < 4) {
                p.hull -= 50;
                UI.showToast("CAUGHT IN EXPLOSION!", "error");
            }
        },delay);
    }

    trashBlock(type, all=false) {
        const p = this.localPlayer;
        if(p.inventory[type] > 0) {
            let amount = all ? p.inventory[type] : 1;
            p.inventory[type] -= amount;
            p.cargo -= amount;

            if(p.inventory[type] < 0) p.inventory[type] = 0; // sanity
            if(p.cargo < 0) p.cargo = 0;

            const name = TILE_PROPS[type].name;
            UI.showToast(`Trashed ${amount} ${name}`, "normal");
            UI.updateDashboard();
        }
    }

    trashJunk() {
        const p = this.localPlayer;
        let totalTrashed = 0;

        for (let key in p.inventory) {
            let type = parseInt(key);
            let count = p.inventory[type];
            let prop = TILE_PROPS[type];

            // Trash if value is 0, but keep Casings (building blocks)
            if (count > 0 && prop.value === 0 && type !== TILE_TYPES.CASING && !TILE_PROPS[type].trashExclude) {
                p.inventory[type] = 0;
                p.cargo -= count;
                totalTrashed += count;
            }
        }

        if (p.cargo < 0) p.cargo = 0;

        if(totalTrashed > 0) {
            UI.showToast(`Trashed ${totalTrashed} Junk Items`, "success");
            Sound.playChat('death'); // Reuse sound for impact
        } else {
            UI.showToast("No Junk Found", "normal");
        }
        UI.updateDashboard();
    }

    tryMine(tx, ty, testOnly = false) {
        // Safety check for map bounds
        if (!this.map[ty] || this.map[ty][tx] === undefined) return false;

        let tile = this.map[ty][tx];

        // Basic validity checks
        if (tile !== TILE_TYPES.EMPTY && tile !== TILE_TYPES.BEDROCK && this.localPlayer.fuel > 0) {
            let props = TILE_PROPS[tile];

            // 1. Drill Tier Check
            if (this.localPlayer.drillTier < props.tier) {
                // We show the error even in test mode so the player knows why they can't move
                UI.showToast(`Need Tier ${props.tier} Drill`, "error");
                Sound.playError();
                return false;
            }

            // 2. Cargo Check
            if (this.localPlayer.cargo >= this.localPlayer.maxCargo) {
                // If the inventory already has this item, we might still be able to stack it?
                // Assuming strict slot limit based on your previous code:
                UI.showToast("Cargo Full!", "error");
                Sound.playError();
                return false;
            }

            // --- SUCCESS CASE ---

            // If we are just checking if movement is allowed:
            if (testOnly) {
                return true;
            }

            // If we are actually mining (Arrived at tile):
            if (!this.localPlayer.inventory[tile]) this.localPlayer.inventory[tile] = 0;
            this.localPlayer.inventory[tile]++;
            this.localPlayer.cargo++;

            if (!this.localPlayer.stats.blocksMined[tile]) this.localPlayer.stats.blocksMined[tile] = 0;
            this.localPlayer.stats.blocksMined[tile]++;
            this.localPlayer.stats.totalMined++;

            this.map[ty][tx] = TILE_TYPES.EMPTY;
            this.discovered[ty][tx] = 1;

            // Visuals
            this.spawnParticle(tx * 32 + 16, ty * 32 + 16, props.color, 8);
            Sound.playMining();

            // Network / UI
            Network.sendTileUpdate(tx, ty, TILE_TYPES.EMPTY);
            UI.updateDashboard();

            return true;
        }
        return false;
    }

    spawnParticle(x, y, color, count) {
        for(let i=0; i<count; i++) {
            this.particles.push({x, y, vx: (Math.random()-0.5)*6, vy: (Math.random()-0.5)*6, life: 1.0, color});
        }
    }

    respawn() {
        this.localPlayer.gridX = Math.floor(CONSTANTS.MAP_WIDTH / 2);
        this.localPlayer.gridY = 4;
        this.localPlayer.x = this.localPlayer.gridX * CONSTANTS.TILE_SIZE;
        this.localPlayer.y = this.localPlayer.gridY * CONSTANTS.TILE_SIZE;
        this.localPlayer.hull = this.localPlayer.maxHull;
        this.localPlayer.fuel = this.localPlayer.maxFuel;
        this.localPlayer.cargo = 0;
        this.localPlayer.inventory = {};
        this.localPlayer.money = Math.floor(this.localPlayer.money * 0.7);
        Network.broadcastDeath();
        Sound.playChat('death');
        $('heat-overlay').style.opacity = 0;
        UI.updateDashboard();
    }

    draw() {
        if (!this.running) return;

        // 1. CLEAR & SETUP
        this.ctx.resetTransform();
        this.ctx.fillStyle = '#050505';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        let cx = this.canvas.width / 2;
        let cy = this.canvas.height / 2;

        // Cache zoomed dimensions to avoid division in loops
        const zoom = this.zoom;
        const viewW = (this.canvas.width / zoom);
        const viewH = (this.canvas.height / zoom);

        this.ctx.translate(cx, cy);
        this.ctx.scale(zoom, zoom);
        // Use bitwise | 0 for faster integer rounding than Math.round/floor
        this.ctx.translate(-(this.camera.x | 0), -(this.camera.y | 0));

        // Calculate bounds once
        const TILE_SIZE = CONSTANTS.TILE_SIZE;
        const startCol = ((this.camera.x - viewW / 2) / TILE_SIZE | 0) - 1;
        const endCol   = ((this.camera.x + viewW / 2) / TILE_SIZE | 0) + 1;
        const startRow = ((this.camera.y - viewH / 2) / TILE_SIZE | 0) - 1;
        const endRow   = ((this.camera.y + viewH / 2) / TILE_SIZE | 0) + 1;

        // -------------------------------
        // OPTIMIZATION: CACHE TIME LOGIC
        // -------------------------------
        // Sorting an array every frame is slow. Finding min value is O(n).
        // If possible, calculate 'host' outside draw(), but here is the O(n) version:
        if (!this._cachedHost || (this.frameTick % 60 === 0)) { // Update host logic occasionally, not every frame
            const allPlayers = Object.values(this.remotePlayers);
            allPlayers.push(this.localPlayer);

            let minTime = this.localPlayer.joinedAt || Date.now();
            let hostRef = this.localPlayer;

            for(let i=0; i<allPlayers.length; i++) {
                const p = allPlayers[i];
                if(p.joinedAt && p.joinedAt < minTime) {
                    minTime = p.joinedAt;
                    hostRef = p;
                }
            }
            this._cachedHost = hostRef;
        }

        const worldTime = Date.now() - (this._cachedHost.joinedAt || Date.now());
        const dayLength = 20 * 60 * 1000;
        const t = (worldTime % dayLength) / dayLength;
        const sunAngle = (t * Math.PI * 2) - Math.PI / 2;

        // Smooth daylight curve
        const x = (Math.cos(sunAngle) + 1) / 2;
        const daylight = x * x * (3 - 2 * x);

        // -------------------------------
        // SKY RENDERING
        // -------------------------------
        const groundY = 5 * TILE_SIZE;
        const sunrise = Math.max(0, 1 - Math.abs(t - 0.25) * 20);
        const sunset  = Math.max(0, 1 - Math.abs(t - 0.75) * 20);
        const warm = sunrise + sunset;

        // Pre-calc colors to avoid string parsing overhead if possible,
        // but template literals are decent in modern JS engines.
        const r = (135 * (0.3 + daylight * 0.7) - warm * 80) | 0;
        const g = (206 * (0.3 + daylight * 0.7) - warm * 40) | 0;
        const b = (235 * (0.3 + daylight * 0.7) - warm * 20) | 0;

        this.ctx.fillStyle = `rgb(${r},${g},${b})`;
        // Draw sky in one large rect
        this.ctx.fillRect(this.camera.x - viewW, -2000, viewW * 2, groundY + 2000);

        if (warm > 0) {
            const grad = this.ctx.createLinearGradient(0, -2000, 0, groundY);
            grad.addColorStop(0, `rgba(255,120,50,${warm * 0.6})`);
            grad.addColorStop(1, `rgba(255,180,120,${warm * 0.3})`);
            this.ctx.fillStyle = grad;
            this.ctx.fillRect(this.camera.x - viewW, -2000, viewW * 2, groundY + 2000);
        }

        // -------------------------------
        // CELESTIAL BODIES
        // -------------------------------
        const skyRadius = 900;
        const sunX = this.camera.x + Math.cos(sunAngle) * skyRadius;
        const sunY = groundY + Math.sin(sunAngle) * skyRadius;
        const moonX = this.camera.x + Math.cos(sunAngle + Math.PI) * skyRadius;
        const moonY = groundY + Math.sin(sunAngle + Math.PI) * skyRadius;

        // SUN
        const sunSize = 70;
        const sunGrd = this.ctx.createRadialGradient(sunX, sunY, 0, sunX, sunY, sunSize);
        sunGrd.addColorStop(0, "rgba(255,255,200,1)");
        sunGrd.addColorStop(1, "rgba(255,180,0,0.2)");
        this.ctx.fillStyle = sunGrd;
        this.ctx.beginPath();
        this.ctx.arc(sunX, sunY, sunSize, 0, Math.PI * 2);
        this.ctx.fill();

        // MOON
        const moonSize = 55;
        const moonCycle = 60 * 60 * 1000;
        const moonPhase = (worldTime % moonCycle) / moonCycle;

        this.ctx.fillStyle = "#e0e0e0";
        this.ctx.beginPath();
        this.ctx.arc(moonX, moonY, moonSize, 0, Math.PI * 2);
        const curveOffset = (moonPhase - 0.5) * moonSize * 1.6;
        this.ctx.moveTo(moonX - moonSize, moonY);
        this.ctx.quadraticCurveTo(moonX + curveOffset, moonY, moonX - moonSize, moonY);
        this.ctx.fill();

        // -------------------------------
        // OPTIMIZATION: BATCHED STARS
        // -------------------------------
        // Instead of looping and setting fillStyle/globalAlpha 200 times,
        // we set the style once and draw all rects.
        if (!this.starField) {
            this.starField = [];
            for (let i = 0; i < 200; i++) {
                this.starField.push({
                    x: Math.random() * 5000 - 2500,
                    y: Math.random() * 2000 - 2000,
                    b: Math.random() * 0.8 + 0.2
                });
            }
        }

        const starAlpha = (0.4 - daylight) / 0.4;
        if (starAlpha > 0) {
            this.ctx.fillStyle = "#fff";
            this.ctx.beginPath(); // Start a path for batching
            for (let i = 0; i < this.starField.length; i++) {
                const s = this.starField[i];
                // Only draw stars that are actually bright enough
                if (s.b * starAlpha < 0.05) continue;

                // To vary opacity without context switching, we can either:
                // 1. Group by opacity (complex)
                // 2. Just use globalAlpha for the whole batch (loss of individual twinkle variation)
                // 3. Keep current logic but use rect() instead of fillRect()

                // Fast compromise: Draw all stars at average opacity
                // If individual star twinkle is vital, you must accept the perf hit.
                // Here is the "fast" version:
                this.ctx.rect(s.x, s.y, 2, 2);
            }
            this.ctx.globalAlpha = starAlpha; // Apply overall fade
            this.ctx.fill(); // ONE draw call for all stars
            this.ctx.globalAlpha = 1;
        }

        // Black void below ground
        this.ctx.fillStyle = "#000";
        this.ctx.fillRect(this.camera.x - viewW, groundY, viewW * 2, 5000);

        this.drawStation();

        // -------------------------------
        // OPTIMIZATION: TILE BATCHING
        // -------------------------------
        // Problem: Your old code switched globalAlpha inside the loop.
        // Solution: Collect coordinates, then draw in two passes.

        const pcx = this.localPlayer.gridX;
        const pcy = this.localPlayer.gridY;
        const visionRadSq = this.localPlayer.xrayRange * this.localPlayer.xrayRange;

        // We create temporary lists. In high-perf code, reuse these arrays to avoid Garbage Collection.
        // Assuming simple usage here:
        const visibleTiles = [];
        const discoveredTiles = [];

        // 1. LOGIC PASS (Determine visibility)
        // Clamp loops to map bounds to avoid Math.min/max inside loop
        const iStartRow = (startRow < 0) ? 0 : startRow;
        const iEndRow   = (endRow >= CONSTANTS.MAP_HEIGHT) ? CONSTANTS.MAP_HEIGHT - 1 : endRow;
        const iStartCol = (startCol < 0) ? 0 : startCol;
        const iEndCol   = (endCol >= CONSTANTS.MAP_WIDTH) ? CONSTANTS.MAP_WIDTH - 1 : endCol;

        for (let y = iStartRow; y <= iEndRow; y++) {
            const dy = y - pcy;
            const dySq = dy * dy;
            const row = this.map[y]; // Cache row lookup

            for (let x = iStartCol; x <= iEndCol; x++) {
                const dx = x - pcx;
                const distSq = dx * dx + dySq;

                if (distSq <= visionRadSq) {
                    this.discovered[y][x] = 1; // Update model
                    // Store tile render data: [x, y, tileType]
                    visibleTiles.push(x, y, row[x]);
                } else if (this.discovered[y][x]) {
                    discoveredTiles.push(x, y, row[x]);
                }
            }
        }

        // 2. RENDER PASS - FULL VISIBILITY
        // Draw all bright tiles consecutively. No alpha switching.
        for (let i = 0; i < visibleTiles.length; i+=3) {
            this.drawProceduralTile(visibleTiles[i], visibleTiles[i+1], visibleTiles[i+2], false);
        }

        // 3. RENDER PASS - DISCOVERED (FOG)
        // Switch Alpha ONCE
        if (discoveredTiles.length > 0) {
            this.ctx.globalAlpha = 0.9;
            for (let i = 0; i < discoveredTiles.length; i+=3) {
                this.drawProceduralTile(discoveredTiles[i], discoveredTiles[i+1], discoveredTiles[i+2], false);
            }
            this.ctx.globalAlpha = 1.0; // Reset once
        }

        // Players
        const remote = Object.values(this.remotePlayers);
        for(let i=0; i<remote.length; i++) this.drawPlayer(remote[i], false);
        this.drawPlayer(this.localPlayer, true);

        // -------------------------------
        // OPTIMIZATION: PARTICLE BATCHING
        // -------------------------------
        if (this.particles.length > 0) {
            // Since particles have different colors/alpha, we can't batch perfectly
            // without grouping by color.
            // However, we can use integer positions for sharper rendering.
            for (let i = this.particles.length - 1; i >= 0; i--) {
                let p = this.particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.life -= 0.05;

                if (p.life <= 0) {
                    this.particles.splice(i, 1);
                    continue;
                }

                this.ctx.globalAlpha = p.life;
                this.ctx.fillStyle = p.color;
                // Use bitwise OR for integer coordinates (faster/crisper)
                this.ctx.fillRect(p.x | 0, p.y | 0, 4, 4);
            }
            this.ctx.globalAlpha = 1.0;
        }

        this.drawLocalMinimap();
        this.ctx.resetTransform();
        this.drawHUD();

        // Increment a tick for logic throttling
        this.frameTick = (this.frameTick || 0) + 1;
    }


    drawStation() {
        const ts = CONSTANTS.TILE_SIZE;

        // Station top-left corner in pixels
        const baseX = (this.stationGridX * ts)+ts;
        const baseY = (this.stationGridY * ts)-ts;

        const ctx = this.ctx;

        // -------------------------------
        // BUILDING DIMENSIONS (in tiles)
        // -------------------------------
        const buildingW = 2 * ts;   // 2 tiles wide
        const buildingH = 2 * ts;   // 2 tiles tall

        const roofH = ts * 0.4;     // roof height
        const doorW = ts * 0.5;
        const doorH = ts * 0.9;

        // -------------------------------
        // MAIN BUILDING
        // -------------------------------
        ctx.fillStyle = "#7f8c8d"; // concrete walls
        ctx.fillRect(baseX, baseY, buildingW, buildingH);

        // Wall bevel
        ctx.fillStyle = "rgba(0,0,0,0.25)";
        ctx.fillRect(baseX, baseY + buildingH - 4, buildingW, 4);
        ctx.fillRect(baseX + buildingW - 4, baseY, 4, buildingH);

        ctx.fillStyle = "rgba(255,255,255,0.15)";
        ctx.fillRect(baseX, baseY, buildingW, 3);
        ctx.fillRect(baseX, baseY, 3, buildingH);

        // -------------------------------
        // ROOF (tile-aligned)
        // -------------------------------
        ctx.fillStyle = "#c0392b";
        ctx.fillRect(baseX - ts * 0.25, baseY - roofH, buildingW + ts * 0.5, roofH);

        // Roof trim
        ctx.fillStyle = "#922b21";
        ctx.fillRect(baseX - ts * 0.25, baseY - roofH, buildingW + ts * 0.5, 4);

        // -------------------------------
        // DOOR (centered)
        // -------------------------------
        const doorX = baseX + buildingW / 2 - doorW / 2;
        const doorY = baseY + buildingH - doorH;

        ctx.fillStyle = "#2c3e50";
        ctx.fillRect(doorX, doorY, doorW, doorH);

        // Door handle
        ctx.fillStyle = "#ecf0f1";
        ctx.fillRect(doorX + doorW - 8, doorY + doorH / 2, 6, 2);

        // -------------------------------
        // WINDOWS
        // -------------------------------
        const winW = ts * 0.7;
        const winH = ts * 0.6;

        ctx.fillStyle = "#3498db";

        // Left window
        ctx.fillRect(baseX + ts * 0.2, baseY + ts * 0.3, winW, winH);

        // Right window
        ctx.fillRect(baseX + buildingW - winW - ts * 0.2, baseY + ts * 0.3, winW, winH);

        // Window shine
        ctx.fillStyle = "rgba(255,255,255,0.25)";
        ctx.fillRect(baseX + ts * 0.25, baseY + ts * 0.35, winW * 0.4, winH * 0.2);
        ctx.fillRect(baseX + buildingW - winW - ts * 0.15, baseY + ts * 0.35, winW * 0.4, winH * 0.2);

        // -------------------------------
        // SIGNAGE
        // -------------------------------
        ctx.fillStyle = `hsl(${(Date.now()*0.05)%360}, 100%, 60%)`;
        ctx.font = `${ts * 0.5}px Danfo`;
        ctx.textAlign = "center";
        ctx.fillText("SHOP", baseX + buildingW / 2, baseY - roofH * 0.4);

        // -------------------------------
        // GAS PUMPS (tile-aligned, left side)
        // -------------------------------
        const pumpW = ts * 0.5;
        const pumpH = ts * 1.2;

        // Pumps should sit to the LEFT of the building
        const pumpX = baseX - ts*2;   // 1.2 tiles left of building
        const pumpY = baseY + buildingH - pumpH;  // same Y-level for both pumps


        // Pump hoses
        ctx.strokeStyle = "#000";
        ctx.lineWidth = 3;

        ctx.beginPath();
        ctx.moveTo(pumpX + pumpW, pumpY - ts * 0.3 + pumpH * 0.6);
        ctx.lineTo(pumpX + pumpW + ts * 0.3, pumpY - ts * 0.3 + pumpH * 0.8);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(pumpX + pumpW - ts, pumpY - ts * 0.3 + pumpH * 0.6);
        ctx.lineTo(pumpX + pumpW + ts * 0.3 - ts, pumpY - ts * 0.3 + pumpH * 0.8);
        ctx.stroke();

        ctx.fillStyle = "#bdc3c7";

        // Pump 1 (front)
        ctx.fillRect(pumpX, pumpY, pumpW, pumpH);

        // Pump 2 (behind it, slightly offset upward)
        ctx.fillRect(pumpX - ts, pumpY, pumpW, pumpH);

        // Pump screens
        ctx.fillStyle = "#2c3e50";
        ctx.fillRect(pumpX + pumpW * 0.2, pumpY + ts * 0.2, pumpW * 0.6, pumpH * 0.3);
        ctx.fillRect(pumpX + pumpW * 0.2 - ts, pumpY + ts * 0.2, pumpW * 0.6, pumpH * 0.3);
    }


    drawProceduralTile(x, y, type) {
        let ts = CONSTANTS.TILE_SIZE;
        let px = x * ts; let py = y * ts;
        let prop = TILE_PROPS[type];

        if (type === TILE_TYPES.EMPTY && y < 5) {
            return;
        }

        const n1 = (pseudoRandom(x, y) % 1);
        const n2 = ((pseudoRandom(x, y) * 10) % 1);

        let bevel = true;
        let isOre = false;

        // --- ORE RENDERING (Detailed) ---
        if (type >= TILE_TYPES.COAL && type <= TILE_TYPES.RUBY) {

            isOre=true
            // Stone background
            this.ctx.fillStyle = TILE_PROPS[TILE_TYPES.STONE].color;
            this.ctx.fillRect(px, py, ts, ts);


            // Ore color
            this.ctx.fillStyle = prop.color;

            // Use your seeded RNG
            const r0 = pseudoRandom(x, y);
            const r1 = pseudoRandom(x + 17, y + 3);
            const r2 = pseudoRandom(x - 9, y + 11);
            const r3 = pseudoRandom(x + 4, y - 6);

            // Cluster center
            const cx = px + 8 + r0 * 16;
            const cy = py + 8 + r1 * 16;

            // Main chunk
            this.ctx.fillRect(cx - 3, cy - 3, 6, 6);

            // Satellite specks
            const specks = [
                { dx: (r1 - 0.5) * 12, dy: (r2 - 0.5) * 12, s: 3 },
                { dx: (r2 - 0.5) * 14, dy: (r3 - 0.5) * 14, s: 4 },
                { dx: (r3 - 0.5) * 16, dy: (r0 - 0.5) * 16, s: 3 }
            ];

            for (const sp of specks) {
                this.ctx.fillRect(cx + sp.dx, cy + sp.dy, sp.s, sp.s);
            }

            if (this.settings.graphicsQuality > 2 && ((now() + Math.floor(pseudoRandom(x, y) * 2000)) % 2000 < 200)) {
                this.ctx.fillStyle = 'rgba(255,255,255,0.9)';
                this.ctx.fillRect(cx - 1, cy - 1, 2, 2);
            }
        }

        if(!isOre){
            // --- STANDARD BLOCKS ---
            this.ctx.fillStyle = prop.color;
            this.ctx.fillRect(px, py, ts + 1, ts + 1);

            if (type === TILE_TYPES.EMPTY && y>=5) {
                this.ctx.fillStyle = 'rgba(50, 25, 15, 1)';
                this.ctx.fillRect(px, py, ts + 1, ts + 1);

                // Add some small pebbles/debris
                if(this.settings.graphicsQuality > 2){
                    this.ctx.fillStyle = 'rgba(120, 90, 70, 0.4)';
                    if(n1 > 0.7) this.ctx.fillRect(px + 8, py + 8, 3, 3);
                    if(n2 > 0.6) this.ctx.fillRect(px + 20, py + 12, 2, 2);
                    if(n1 < 0.3) this.ctx.fillRect(px + 15, py + 20, 4, 2);
                }
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0)';
                bevel=false;
            }
            else if (type === TILE_TYPES.EMPTY && y<5) {
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0)';
                return
            }
            else if (this.settings.graphicsQuality > 2 && type === TILE_TYPES.DIRT) {
                this.ctx.fillStyle = 'rgba(0,0,0,0.15)';
                if(n1 > 0.5) this.ctx.fillRect(px+4, py+4, 4, 4);
                if(n2 < 0.5) this.ctx.fillRect(px+20, py+20, 5, 5);
                if(n1 < 0.2) this.ctx.fillRect(px+12, py+10, 3, 3);
            } else if (this.settings.graphicsQuality > 1 && type === TILE_TYPES.GRASS) {
                this.ctx.fillStyle = '#2ecc71';
                this.ctx.fillRect(px, py, ts, 6);
                this.ctx.fillStyle = 'rgba(0,0,0,0.1)';
                this.ctx.fillRect(px, py+6, ts, ts-6);
            } else if (this.settings.graphicsQuality > 2 && (type === TILE_TYPES.STONE || type === TILE_TYPES.HARD_STONE || type === TILE_TYPES.DEEP_SLATE)) {
                const r0 = pseudoRandom(x, y);
                const r1 = pseudoRandom(x + 17, y + 3);
                const r2 = pseudoRandom(x - 9, y + 11);
                const r3 = pseudoRandom(x + 4, y - 6);
                this.ctx.fillStyle = 'rgba(0,0,0,0.2)';
                if(n1 > 0.3) {
                    this.ctx.fillRect(px+(r0*5), py+(r2*5), 10, 6);
                    this.ctx.fillRect(px+(r1*18), py+(r3*18), 10, 6);
                }
                this.ctx.strokeStyle = 'rgba(0,0,0,0.1)';
                this.ctx.beginPath();
                this.ctx.moveTo(px+(ts*r2), py+(ts*r1));
                this.ctx.lineTo(px+(ts*r3), py+(ts*r0));
                this.ctx.stroke();
            } else if (type === TILE_TYPES.CASING) {
                this.ctx.strokeStyle = '#555'; this.ctx.lineWidth = 4;
                this.ctx.strokeRect(px+2, py+2, ts-4, ts-4);
                this.ctx.beginPath();
                this.ctx.moveTo(px, py);
                this.ctx.lineTo(px+ts, py+ts);
                this.ctx.moveTo(px+ts, py);
                this.ctx.lineTo(px, py+ts);
                this.ctx.stroke();
            }else if(type === TILE_TYPES.TNT) {
                this.ctx.fillStyle = "#c0392b"; this.ctx.fillRect(px,py,ts,ts);
                this.ctx.fillStyle = "white";
                this.ctx.font="10px Arial";
                this.ctx.textAlign="center";
                this.ctx.fillText("TNT", px+16, py+20);
            }else if(type === TILE_TYPES.NUKE) {
                this.ctx.fillStyle = "#2c3e50";
                this.ctx.fillRect(px,py,ts,ts);
                this.ctx.fillStyle = "#f1c40f";
                this.ctx.beginPath();
                this.ctx.arc(px+16,py+16,8,0,Math.PI*2);
                this.ctx.fill();
            }else if(type === TILE_TYPES.TELEPORTER) {
                this.ctx.fillStyle = "#8e44ad";
                this.ctx.fillRect(px,py,ts,ts);
                this.ctx.strokeStyle = "#fff";
                this.ctx.lineWidth=2;
                this.ctx.beginPath();
                this.ctx.arc(px+16,py+16,10,0,Math.PI*2);
                this.ctx.stroke();
            }
            this.ctx.fillStyle = 'rgba(0, 0, 0, 0)';
        }

        // Bevel for all
        if(this.settings.graphicsQuality > 1 && bevel){
          this.ctx.fillStyle = 'rgba(0,0,0,0.2)'; this.ctx.fillRect(px, py+ts-2, ts, 2); this.ctx.fillRect(px+ts-2, py, 2, ts);
          this.ctx.fillStyle = 'rgba(255,255,255,0.1)'; this.ctx.fillRect(px, py, ts, 2); this.ctx.fillRect(px, py, 2, ts);
        }
    }

    drawPlayer(p, isLocal) {
        let size = CONSTANTS.TILE_SIZE;
        let cx = p.x + size/2; let cy = p.y + size/2;
        this.ctx.save(); this.ctx.translate(cx, cy); this.ctx.rotate(p.rotation || 0);
        let color = isLocal ? this.settings.color : (p.color || '#fff');

        this.ctx.fillStyle = color; this.ctx.fillRect(-12, -12, 24, 24);
        this.ctx.strokeStyle = '#111'; this.ctx.lineWidth = 2; this.ctx.strokeRect(-12, -12, 24, 24);
        this.ctx.fillStyle = '#bdc3c7';
        let drillOffset = (p.isDrilling && now() % 200 > 100) ? 2 : 0;
        this.ctx.beginPath(); this.ctx.moveTo(-6, 12); this.ctx.lineTo(0, 20 + drillOffset); this.ctx.lineTo(6, 12); this.ctx.fill();
        this.ctx.fillStyle = '#2c3e50'; this.ctx.fillRect(-16, -10, 4, 20); this.ctx.fillRect(12, -10, 4, 20);
        this.ctx.fillStyle = '#3498db'; this.ctx.fillRect(-6, -6, 12, 8);
        if (!isLocal) {
            this.ctx.rotate(-p.rotation); this.ctx.fillStyle = '#fff'; this.ctx.font = getFontSize('--fs-md') + ' Geo'; this.ctx.textAlign = 'center';
            this.ctx.shadowColor="black"; this.ctx.shadowBlur=2;
            this.ctx.fillText(p.username || "Unknown", 0, -20);
            this.ctx.shadowBlur=0;
        }
        this.ctx.restore();
    }

    drawLocalMinimap() {
        const ctx = this.minimapCtx;
        const width = 150;
        const height = 150;
        ctx.fillStyle = '#000'; ctx.fillRect(0, 0, width, height);

        // Fixed Minimap Settings (Independent of Zoom)
        const range = 25; // 25 tile radius = 50 tile diameter view
        const pixelSize = width / (range * 2); // 150 / 50 = 3px per tile exact
        const center = width / 2;

        const pX = this.localPlayer.gridX;
        const pY = this.localPlayer.gridY;

        for (let dy = -range; dy < range; dy++) {
            for (let dx = -range; dx < range; dx++) {
                let mx = pX + dx;
                let my = pY + dy;
                // Boundary checks
                if (mx >= 0 && mx < CONSTANTS.MAP_WIDTH && my >= 0 && my < CONSTANTS.MAP_HEIGHT) {
                    if (this.discovered[my][mx]) {
                        let tile = this.map[my][mx];
                        ctx.fillStyle = tile === TILE_TYPES.EMPTY ? '#111' : TILE_PROPS[tile].color;
                        // Use 3x3 pixel rects
                        ctx.fillRect(Math.floor(center + dx * pixelSize), Math.floor(center + dy * pixelSize), pixelSize, pixelSize);
                    }
                }
            }
        }

        // Viewport Border calculation needs to map GAME View to MINIMAP Coordinates
        // Game View Width (in tiles) = CanvasWidth / (TileSize * Zoom)
        ctx.strokeStyle = "rgba(255,255,255,0.5)";
        ctx.lineWidth = 1;

        const gameViewTilesW = this.canvas.width / (CONSTANTS.TILE_SIZE * this.zoom);
        const gameViewTilesH = this.canvas.height / (CONSTANTS.TILE_SIZE * this.zoom);

        // Convert tiles to pixels on the minimap
        const miniMapRectW = gameViewTilesW * pixelSize;
        const miniMapRectH = gameViewTilesH * pixelSize;

        ctx.strokeRect(center - miniMapRectW/2, center - miniMapRectH/2, miniMapRectW, miniMapRectH);

        // Player Dot (Always Center)
        ctx.fillStyle = Game.settings.color;
        ctx.fillRect(center, center, 3, 3);

        // Remote players... mapped to minimap scale
        Object.values(this.remotePlayers).forEach(rp => {
            let dx = rp.gridX - pX;
            let dy = rp.gridY - pY;

            // Only draw if within minimap range
            if(Math.abs(dx) < range && Math.abs(dy) < range) {
                const screenX = center + dx * pixelSize;
                const screenY = center + dy * pixelSize;
                ctx.fillStyle = rp.color;
                ctx.fillRect(screenX, screenY, 3, 3);
            }
        });
    }

    drawHUD() {
        const p = this.localPlayer;
        const w = this.canvas.width;
        const h = this.canvas.height;

        // Adjust gauge scale and position for mobile
        const gaugeR = this.isMobile ? Math.min(this.canvas.width/12, 60) : 55;
        const yPos = h - (gaugeR * 1.5); // Sits just above bottom of canvas
        const xStep = this.isMobile ? (w / 4) : 100; // Spread evenly or fixed

        if (this.isMobile) {
            // Even spread across top of controls
            this.drawGauge(w*0.15, yPos, gaugeR, p.fuel, p.maxFuel, "FUEL", "#d35400");
            this.drawGauge(w*0.38, yPos, gaugeR, p.hull, p.maxHull, "HULL", "#c0392b");
            this.drawGauge(w*0.62, yPos, gaugeR, p.cargo, p.maxCargo, "CARGO", "#27ae60");
            this.drawGauge(w*0.85, yPos, gaugeR, p.temp, 100, "TEMP", "#e74c3c");

            // Money top center
            this.ctx.fillStyle = "#f1c40f"; this.ctx.font = "bold " + getFontSize('--fs-title') + " Geo"; this.ctx.textAlign = "center";
            this.ctx.fillText("$ " + Math.floor(p.money), w/2, 30);
        } else {
            // Desktop layout (bottom corners)
            this.drawGauge(80, h - 60, gaugeR, p.fuel, p.maxFuel, "FUEL", "#d35400");
            this.drawGauge(240, h - 60, gaugeR, p.hull, p.maxHull, "HULL", "#c0392b");
            this.drawGauge(w - 80, h - 60, gaugeR, p.cargo, p.maxCargo, "CARGO", "#27ae60");
            this.drawGauge(w - 240, h - 60, gaugeR, p.temp, 100, "TEMP", "#e74c3c");

            this.ctx.fillStyle = "#f1c40f"; this.ctx.font = "bold " + getFontSize('--fs-title') + " Geo"; this.ctx.textAlign = "center";
            this.ctx.fillText("$ " + Math.floor(p.money), w/2, h - 30);
        }
    }

    drawGauge(x, y, r, val, max, label, color) { /* Same as before */
        const ctx = this.ctx;
        ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.fillStyle = "rgba(0,0,0,0.7)"; ctx.fill();
        ctx.lineWidth = 3; ctx.strokeStyle = "#444"; ctx.stroke();
        const start = Math.PI * 0.7; const end = Math.PI * 2.3;
        const pct = clamp(val / max, 0, 1);
        const current = start + (end - start) * pct;
        ctx.beginPath(); ctx.arc(x, y, r - 5, start, current); ctx.strokeStyle = color; ctx.lineWidth = 6; ctx.stroke();
        ctx.fillStyle = "#fff"; ctx.font = "bold " + getFontSize('--fs-md') + " Geo"; ctx.textAlign = "center";
        ctx.fillText(label, x, y + 15); ctx.fillText(Math.floor(val), x, y - 5);
    }

    loop() {
        this.update();
        this.draw();
        requestAnimationFrame(() => this.loop());
    }
}

// --- HELPER FOR COLORS ---
const Qt = { lighter: (hex, factor) => hex };

// --- SHOP SYSTEM ---
class ShopSystem {
    constructor() {
        this.prices = {
            drill: [500, 2000, 10000, 50000],
            hull: 200, fuel: 200, cargo: 100, cool: 1000, xray: 2000,
            repair_kit: 50, fuel_voucher: 50, tnt: 200, nuke: 5000, teleporter: 1000
        };
    }
    open() { $('shop-modal').classList.add('active'); this.updateUI(); }
    close() { $('shop-modal').classList.remove('active'); }

    sellAll() {
        let total = 0;
        const p = Game.localPlayer;
        for (let type in p.inventory) {
            let count = p.inventory[type];
            if (count > 0 && TILE_PROPS[type].value > 0) {
                total += count * TILE_PROPS[type].value;
                p.inventory[type] = 0;
            }
        }
        if (total > 0) {
            p.money += total;
            p.cargo = 0;
            for(let t in p.inventory) p.cargo += p.inventory[t];
            UI.showToast(`Sold all for $${total}`, "success");
            Sound.playSuccess();
            Game.saveLocalProgress(); // Save on transaction
        } else {
            UI.showToast("Nothing valuable to sell.", "normal");
        }
        this.updateUI();
        UI.updateDashboard();
    }

    sellItem(type, amount) {
        const p = Game.localPlayer;
        if(p.inventory[type] >= amount) {
            let val = TILE_PROPS[type].value * amount;
            p.inventory[type] -= amount;
            p.cargo -= amount;
            p.money += val;
            UI.showToast(`Sold ${amount} ${TILE_PROPS[type].name}`, "success");
            Sound.playSuccess();
            Game.saveLocalProgress(); // Save on transaction
            this.updateUI();
            UI.updateDashboard();
        }
    }

    refuelRepair() {
        const p = Game.localPlayer;
        if(p.money >= 10) {
            p.money -= 10;
            p.fuel = p.maxFuel;
            p.hull = p.maxHull;
            UI.showToast("Refueled & Repaired!", "success");
            Sound.playSuccess();
            Game.saveLocalProgress(); // Save on transaction
            this.updateUI();
        } else {
            UI.showToast("Not enough money!", "error");
            Sound.playError();
        }
    }

    updateUI() {
        const p = Game.localPlayer;
        $('shop-money').innerText = "$" + Math.floor(p.money);
        // $('shop-color-picker').value = Game.settings.color;

        const sellContainer = $('sell-list');
        sellContainer.innerHTML = '';
        let hasItems = false;

        Object.keys(p.inventory).forEach(key => {
            let type = parseInt(key);
            let count = p.inventory[type];
            let val = TILE_PROPS[type].value;

            if (count > 0 && val > 0) {
                hasItems = true;
                let div = document.createElement('div');
                div.className = 'sell-row';
                div.innerHTML = `
                    <span style="color:${TILE_PROPS[type].color}">${TILE_PROPS[type].name} (x${count})</span>
                    <span style="color:gold">$${val}/ea</span>
                    <div class="sell-actions">
                        <button class="btn" onclick="Shop.sellItem(${type}, 1)">Sell 1</button>
                        <button class="btn" onclick="Shop.sellItem(${type}, ${count})">All</button>
                    </div>
                `;
                sellContainer.appendChild(div);
            }
        });

        if(!hasItems) sellContainer.innerHTML = '<div style="padding:10px; color:#555; text-align:center;">No valuable ore to sell.</div>';

        const check = (type, level) => {
            let cost = this.prices[type];
            if(Array.isArray(cost)) cost = cost[level] || 999999;
            else cost = Math.floor(cost * (1 + level));
            $(`cost-${type}`).innerText = "$" + cost;
            $(`btn-${type}`).disabled = p.money < cost;
            if(Array.isArray(this.prices[type]) && !this.prices[type][level]) {
                 $(`cost-${type}`).innerText = "MAX";
                 $(`btn-${type}`).disabled = true;
            }
        };
        check('drill', p.drillTier);
        check('hull', (p.maxHull-100)/20);
        check('fuel', (p.maxFuel-100)/20);
        check('cargo', (p.maxCargo-50)/10);
        check('cool', p.heatResist);
        check('xray', p.xrayRange);
    }

    buy(item) {
        const p = Game.localPlayer;
        let cost = 0;
        let success = false;

        // Item specific logic
        if (item === 'repair_kit' || item === 'fuel_voucher' && p.cargo < p.maxCargo) {
            cost = this.prices[item];
            if (p.money >= cost) {
                p.money -= cost;
                let type = (item === 'repair_kit') ? TILE_TYPES.REPAIR_KIT : TILE_TYPES.FUEL_VOUCHER;
                p.inventory[type] = (p.inventory[type] || 0) + 1;
                UI.showToast(`Bought ${item.replace('_', ' ')}`, "success");
                success = true;
            }
        } else if (item === 'tnt' || item === 'nuke' || item === 'teleporter') {
            cost = this.prices[item];
            if (p.money >= cost && p.cargo < p.maxCargo) {
                p.money -= cost;
                let type = (item === 'tnt') ? TILE_TYPES.TNT : (item === 'nuke' ? TILE_TYPES.NUKE : TILE_TYPES.TELEPORTER);
                p.cargo++;
                p.inventory[type] = (p.inventory[type] || 0) + 1;
                UI.showToast(`Bought ${item.toUpperCase()}`, "success");
                success = true;
            }
        } else {
             // Standard upgrades...
             this.buyUpgrade(item);
             return;
        }

        if(success) {
            Game.saveLocalProgress();
            this.updateUI();
            UI.updateDashboard();
        } else if(p.cargo >= p.maxCargo) {
            UI.showToast("Cargo is full!", "error");
        } else {
             if (item !== 'drill' && item !== 'hull') UI.showToast("Not enough money!", "error");
        }
    }

    buyUpgrade(item) {
        const p = Game.localPlayer;
        let cost = 0;
        let success = false;
        // if (item === 'paint') { if (p.money >= 100) { p.money -= 100; Game.settings.color = $('shop-color-picker').value; UI.showToast("Repainted!", "success"); success=true; } }
        if (item === 'drill') { cost = this.prices.drill[p.drillTier]; if (p.money >= cost) { p.money -= cost; p.drillTier++; UI.showToast("Drill Upgraded!", "success"); Sound.playSuccess(); success=true; } }
        else {
            let level = 0;
            if (item === 'hull') level = (p.maxHull-100)/20;
            if (item === 'fuel') level = (p.maxFuel-100)/20;
            if (item === 'cargo') level = (p.maxCargo-50)/10;
            if (item === 'cool') level = p.heatResist;
            if (item === 'xray') level = p.xrayRange;
            cost = Math.floor(this.prices[item] * (1 + level));
            if (p.money >= cost) {
                p.money -= cost;
                if (item === 'hull') { p.maxHull += 20; p.hull = p.maxHull; }
                if (item === 'fuel') { p.maxFuel += 20; p.fuel = p.maxFuel; }
                if (item === 'cargo') p.maxCargo += 20;
                if (item === 'cool') p.heatResist++;
                if (item === 'xray') p.xrayRange++;
                UI.showToast(`You bought ${item} for \$${cost}!`, "success");
                Sound.playSuccess();
                success = true;
            }
        }
        if(success) Game.saveLocalProgress(); // Save on buy
        this.updateUI();
    }
}

class CloudManager {
    static getFileName(id) {
        return `mm_world_${id}.json`;
    }

    static async syncWithConflictCheck(id, localData) {
        if(!puter.whoami){
            console.warn("No puter user detected, skipping cloud sync.");
            return;
        }
        try {
            const fileName = this.getFileName(id);
            let cloudData = null;

            // Try to find the file in Global first, then Sandbox

            for (const path of paths) {
                try {
                    const fileItem = await puter.fs.read(path+fileName);
                    cloudData = JSON.parse(await fileItem.text());
                    if (cloudData) break;
                } catch (e) { continue; }
            }

            if (!cloudData) {
                await this.upload(id, localData);
                return "uploaded";
            }

            // FORCE numeric comparison for timestamps
            const cloudTime = Number(cloudData.timestamp || 0);
            const localTime = Number(localData.timestamp || 0);

            if (cloudTime > localTime) {
                console.log(`Cloud is newer (${cloudTime} > ${localTime}). Downloading...`);
                await SaveSystem.injectIntoLocal(cloudData);

                if (SaveSystem.currentSaveId === id) {
                    await SaveSystem.loadGame(id, true);
                }
                return "downloaded";
            } else if (localTime > cloudTime) {
                console.log(`Local is newer (${localTime} > ${cloudTime}). Uploading...`);
                await this.upload(id, localData);
                return "uploaded";
            }

            return "synced";
        } catch (err) {
            console.error("Conflict check error:", err);
            return "error";
        }
    }

    static async delete(id) {
        if(!puter.whoami){
            console.warn("No puter user detected, skipping cloud delete.");
            return;
        }
        const fileName = this.getFileName(id);
        paths.forEach(async (path) => {
            try {
                await puter.fs.delete(path+fileName);
                console.log(`Deleted save file at: ${path+fileName}`);
            } catch (e) {
                console.warn(`Failed to delete save file at: ${path+fileName}\n(This is normal as long as you dont see this error twice for a save)`, e);
            }
        });
    }

    // Fallback method to save into the 'app-xxx' folder if /Documents is blocked
    static async uploadToSandbox(id, data) {
        if(!puter.whoami){
            console.warn("No puter user detected, skipping cloud upload.");
            return;
        }
        try {
            const fileName = this.getFileName(id);
            await puter.fs.write(fileName, JSON.stringify(data));
            console.log(" Saved to Sandbox (Only available on this device)");
            return true;
        } catch (e) {
            return false;
        }
    }

    static async download(id) {
        if(!puter.whoami){
            console.warn("No puter user detected, skipping cloud download.");
            return;
        }
        try {
            if (typeof puter === 'undefined') return null;

            const fileName = this.getFileName(id);
            const globalPath = `/Documents/MegaMinerSaves/${fileName}`;

            let fileItem;
            try {
                // Try global first
                fileItem = await puter.fs.read(globalPath);
            } catch (e) {
                // Fallback to sandbox
                fileItem = await puter.fs.read(fileName);
            }

            const content = await fileItem.text();
            return JSON.parse(content);
        } catch (err) {
            if (err.code === 404) return null;
            console.error("Cloud Download Failed:", err);
            return null;
        }
    }

    static async upload(id, data) {
        if(!puter.whoami){
            console.warn("No puter user detected, skipping cloud upload.");
            return;
        }
        try {
            const fileName = this.getFileName(id);
            const path = `/Documents/MegaMinerSaves/${fileName}`;
            await puter.fs.mkdir('/Documents/MegaMinerSaves', { recursive: true });
            await puter.fs.write(path, JSON.stringify(data));
            return true;
        } catch (e) {
            // Fallback to Sandbox if Documents is Forbidden
            await puter.fs.write(this.getFileName(id), JSON.stringify(data));
            return true;
        }
    }
}

// --- NETWORK (MQTT) ---
class NetworkManager {
    constructor() {
        this.client = null;
        this.baseTopic = 'mm_online/';
        this.lastHeartbeat = 0;
        this.lastSyncToast = 0;
        this.connectionWatchdog = 0; // NEW: Monitor connection health
    }

    connect() {
        Game.logConnection(`Connecting to broker ${Game.settings.broker}...`);

        const broker = Game.settings.broker;
        const options = {
            clientId: 'mm_' + Game.localPlayer.id,
            keepalive: 30,
            clean: true,
            reconnectPeriod: 500
        };
        try { this.client = mqtt.connect(broker, options); } catch (e) { Game.logConnection("Error creating client: " + e); }

        this.client.on('connect', () => {
            Game.logConnection("Connected. Subscribing...");
            this.client.subscribe(`${this.baseTopic}${Game.settings.room}/#`, (err) => {
                if(!err) {
                    Game.logConnection("Subscribed. Joining room...");
                    this.publish('ctrl', { type: 'join', id: Game.localPlayer.id, username: Game.settings.username, color: Game.settings.color, joinedAt: Game.localPlayer.joinedAt, /*ver: BUILD_TIMESTAMP*/ });
                    Game.finishConnection();
                    Sound.playSuccess();
                    // BROADCAST MOVE immediately so everyone sees new player
                    this.broadcastMove();
                } else {
                    Game.logConnection("Sub Error: " + err);
                }
            });
        });

        this.client.on('offline', () => { $('disconnect-msg').style.display = 'block'; });
        this.client.on('reconnect', () => { $('disconnect-msg').style.display = 'none'; });
        this.client.on('message', (topic, message) => this.handleMessage(topic, message));
    }

    update() {
        let n = now();

        // --- AGGRESSIVE RECONNECT WATCHDOG ---
        // If client exists but isn't connected for > 5 seconds, FORCE a reconnect attempt
        if (this.client && !this.client.connected) {
            if (n - this.connectionWatchdog > 5000) {
                console.log("Watchdog: Force Reconnecting...");
                try { this.client.reconnect(); } catch(e) { console.error(e); }
                this.connectionWatchdog = n; // Reset watchdog
            }
        } else {
            this.connectionWatchdog = n; // Heartbeat valid, reset watchdog
        }

        Object.keys(Game.remotePlayers).forEach(id => {
            if (n - Game.remotePlayers[id].lastSeen > 10000) {
                const msg = UI.formatMsg(Game.remotePlayers[id].username, 'leave');
                UI.addMessage("System", msg, "#888");
                Sound.playChat('leave');
                delete Game.remotePlayers[id];
                UI.updatePlayerList();
                // Removed updateAdminStatus, checking health in Game loop
            }
        });
        if (n - this.lastHeartbeat > 2000) {
            this.publish('pos', { type: 'heartbeat', id: Game.localPlayer.id, username: Game.settings.username, joinedAt: Game.localPlayer.joinedAt });
            this.requestViewportSync();
            // --- NEW: Admin Heartbeat ---
            if (Game.isAdmin) {
                this.publish('ctrl', { type: 'host_heartbeat', id: Game.localPlayer.id });
            }

            this.lastHeartbeat = n;
        }
    }

    requestViewportSync() {
        if (!Game.running || !this.client || !this.client.connected) return;
        const p = Game.localPlayer;

        // Request an area slightly larger than the screen centered on player
        // Width 50, Height 40 covers most zoom levels
        this.publish('ctrl', {
            type: 'view_req',
            id: p.id,
            x: p.gridX - 25,
            y: p.gridY - 20,
            w: 50,
            h: 40
        });
    }

    broadcastHostClaim() {
        this.publish('ctrl', { type: 'claim_host', id: Game.localPlayer.id });
    }

    broadcastExplosion(x, y, r, t) { this.publish('map', { type: 'explode', x, y, r, t }); }

    broadcastPromote(targetId) {
        this.publish('ctrl', { type: 'promote_host', target: targetId, from: Game.localPlayer.id });
        Game.isAdmin = false;
        Game.hostId = targetId;
        Game.lastHostHeartbeat = Date.now(); // Trust the new guy
        UI.showToast("Admin Transferred", "normal");
        UI.updateAdminPanel();
    }

    broadcastMove() {
        const p = Game.localPlayer;
        // FIX: Added joinedAt to move packets so late joiners see my timestamp
        this.publish('pos', {
            type: 'move', id: p.id,
            sx: p.x, sy: p.y, tx: p.gridX * CONSTANTS.TILE_SIZE, ty: p.gridY * CONSTANTS.TILE_SIZE,
            gx: p.gridX, gy: p.gridY, r: p.rotation, col: Game.settings.color, drill: p.isDrilling,
            username: Game.settings.username,
            joinedAt: p.joinedAt,
            isAdmin: Game.isAdmin // FLAG ADMIN STATUS
        });
        this.lastHeartbeat = now();
    }

    broadcastDeath() { this.publish('chat', { type: 'death', id: Game.localPlayer.id, name: Game.settings.username }); }
    sendFuel(targetId, amount) { this.publish('ctrl', { type: 'fuel', to: targetId, from: Game.settings.username, amt: amount }); }
    sendTileUpdate(x, y, type) { this.publish('map', { type: 'tile', x, y, val: type, id: Game.localPlayer.id }); }
    sendChat(msg) {
        this.publish('chat', { type: 'chat', id: Game.localPlayer.id, name: Game.settings.username, msg });
        UI.addMessage(Game.settings.username, msg, Game.settings.color);
    }
    kickUser(id) { this.publish('ctrl', { type: 'kick', target: id }); }
    transferAdmin(id) { this.publish('ctrl', { type: 'transfer_admin', to: id }); }

    requestMap(fromId) {
        UI.showToast("Requesting Map...", "normal");
        this.publish('ctrl', { type: 'map_req', from: Game.localPlayer.id, to: fromId || null });
    }

    sendAreaDiff(bx, by, w, h, toId) {
        let diffs = [];
        // Bounds check to ensure we don't read outside map array
        let startX = Math.max(0, bx);
        let startY = Math.max(0, by);
        let endX = Math.min(CONSTANTS.MAP_WIDTH, bx + w);
        let endY = Math.min(CONSTANTS.MAP_HEIGHT, by + h);

        for (let y = startY; y < endY; y++) {
            // Optimization: If row doesn't exist, skip
            if(!Game.map[y]) continue;

            for (let x = startX; x < endX; x++) {
                 let base = Game.getProceduralTile(x, y);
                 let current = Game.map[y][x];

                 // Only send if the current map state differs from the seed generation
                 if (current !== base) {
                     diffs.push(x, y, current);
                 }
            }
        }

        // If we found modified tiles, send them
        if (diffs.length > 0) {
             this.publish('map', { type: 'sync', data: diffs, to: toId, flat: true });
        }
    }

    publish(sub, payload) { if (this.client && this.client.connected) this.client.publish(`${this.baseTopic}${Game.settings.room}/${sub}`, JSON.stringify(payload)); }

    async handleMessage(topic, message) {
        let msg;
        try { msg = JSON.parse(message.toString()); } catch(e) { return; }
        if (msg.id === Game.localPlayer.id && msg.type !== 'kick') return;
        if (msg.type === 'move' || msg.type === 'heartbeat') {
            if (!Game.remotePlayers[msg.id]) {
                Game.remotePlayers[msg.id] = {
                    id: msg.id, x: msg.sx || 0, y: msg.sy || 0, targetX: msg.tx, targetY: msg.ty,
                    username: msg.username || "Unknown", color: msg.col || '#fff', lastSeen: now(),
                    joinedAt: msg.joinedAt // FIX: Capture timestamp on first sight
                };
            }
            let rp = Game.remotePlayers[msg.id];
            rp.lastSeen = now();
            if(msg.username && rp.username === "Unknown") rp.username = msg.username;

            // FIX: Ensure timestamp is synced if it comes in late, but sanity check it
            // Must be a valid timestamp > year 2021 to prevent "0" exploits
            if (msg.joinedAt && (!rp.joinedAt || rp.joinedAt > msg.joinedAt)) {
                if (msg.joinedAt > 1769977740008) {
                    rp.joinedAt = msg.joinedAt;
                }
            }

            // HOST ID / ADMIN STATUS TRACKING
            if (msg.isAdmin) {
                Game.hostId = msg.id;

                // CONFLICT RESOLUTION: If I think I'm admin, but I see another admin...
                if (Game.isAdmin && msg.id !== Game.localPlayer.id) {
                    // Respect the elder (First Joiner Rule)
                    if (msg.joinedAt < Game.localPlayer.joinedAt) {
                        console.log("Admin Conflict: Demoting self in favor of older host.");
                        Game.demoteFromAdmin();
                    }
                }
            }

            if (msg.type === 'move') {
                rp.color = msg.col; rp.rotation = msg.r; rp.isDrilling = msg.drill; rp.gridX = msg.gx; rp.gridY = msg.gy;
                rp.targetX = msg.tx; rp.targetY = msg.ty;
                if (Math.abs(rp.x - rp.targetX) > 100 || Math.abs(rp.y - rp.targetY) > 100) { rp.x = rp.targetX; rp.y = rp.targetY; }
        }
        // Removed updateAdminStatus
    }
    else if (msg.type === 'join') {
        if (Game.bannedIds.includes(msg.id) && Game.isAdmin) this.kickUser(msg.id);
        else {
            if(!Game.remotePlayers[msg.id]) {
                UI.addMessage("System", UI.formatMsg(msg.username, 'join'), "#aaa");
                Sound.playChat('join');
            }
            Game.remotePlayers[msg.id] = {
                id: msg.id, username: msg.username, color: msg.color, x: 0, y: 0, targetX: 0, targetY: 0, joinedAt: msg.joinedAt, lastSeen: now()
            };
            UI.updatePlayerList();
            // Removed updateAdminStatus

            if(Game.isAdmin) {
                // Also assert dominance immediately so they know I'm host
                this.publish('ctrl', { type: 'host_heartbeat', id: Game.localPlayer.id });
            }
            this.broadcastMove();
        }
    }
    else if (msg.type === 'map' || msg.type === 'sync') {
            if (Array.isArray(msg.data)) {
                // Optimization: Detect if this is a Flat Array (Level 1 Optimization)
                // If the first element is a number, it's likely flat [x,y,v, x,y,v...]
                // If the first element is an object/array, it's legacy [[x,y,v]...]
                const isFlat = typeof msg.data[0] === 'number';

                if (isFlat) {
                    // --- NEW EFFICIENT WAY ---
                    // Iterate by 3s
                    for (let i = 0; i < msg.data.length; i += 3) {
                        const x = msg.data[i];
                        const y = msg.data[i+1];
                        const v = msg.data[i+2];

                        // Fast boundary check (optional if you trust server)
                        if (Game.map[y] && Game.map[y][x] !== undefined) {
                            Game.map[y][x] = v;
                            Game.discovered[y][x] = 1;
                        }
                    }
                } else {
                    // --- LEGACY WAY (Keep for safety) ---
                    msg.data.forEach(d => {
                        let x, y, v;
                        if (Array.isArray(d)) { [x, y, v] = d; }
                        else { x = d.x; y = d.y; v = d.v; } // Handle {x,y,v} objects

                        if (Game.map[y] && Game.map[y][x] !== undefined) {
                            Game.map[y][x] = v;
                            Game.discovered[y][x] = 1;
                        }
                    });
                }

                // Critical Optimization:
                // Don't redraw the minimap inside the loop!
                // Flag it to update ONCE after processing the whole chunk.
                if (Game.renderer) Game.renderer.markMapDirty();
            }
        }
    // --- NEW: Admin Messages ---
    else if (msg.type === 'host_heartbeat') {
        Game.hostId = msg.id;
        Game.lastHostHeartbeat = now();

        // Glitch prevention: If I thought *I* was admin, but someone else is pulsing...
        if (Game.isAdmin && msg.id !== Game.localPlayer.id) {
            // Tie breaker: Who claimed it first? Or just yield.
            // Simple yield:
            console.warn("Host conflict detected. Yielding to " + msg.id);
            Game.isAdmin = false;
            UI.updateAdminPanel();
        }
    }
    else if (msg.type === 'claim_host') {
        Game.hostId = msg.id;
        Game.lastHostHeartbeat = now();
        if (msg.id !== Game.localPlayer.id) {
            Game.isAdmin = false;
            UI.updateAdminPanel();
            UI.showToast("New Host Claimed: " + (Game.remotePlayers[msg.id]?.username || "Unknown"), "normal");
        }
    }
    else if (msg.type === 'promote_host') {
        if (msg.target === Game.localPlayer.id) {
            Game.isAdmin = true;
            Game.hostId = Game.localPlayer.id;
            Game.lastHostHeartbeat = now();
            UI.showToast("You have been Promoted to Admin!", "success");
            Sound.playSuccess();
            UI.updateAdminPanel();
            this.broadcastHostClaim();
        } else {
             // Handle case where someone else was promoted
             Game.hostId = msg.target;
             Game.lastHostHeartbeat = now();
             Game.isAdmin = false;
             UI.updateAdminPanel();
        }
    }
    else if (msg.type === 'tile') {
             if (Game.map[msg.y]) { Game.map[msg.y][msg.x] = msg.val; Game.discovered[msg.y][msg.x] = 1; }
        }

        else if (msg.type === 'chat') { UI.addMessage(msg.name, msg.msg); Sound.playChat('msg'); }
        else if (msg.type === 'death') { UI.addMessage("System", UI.formatMsg(msg.name, 'death'), "#f55"); Sound.playChat('death'); }
        else if (msg.type === 'kick') {
            if (msg.target === Game.localPlayer.id) {
                // --- MODAL REPLACEMENT ---
                await CustomModal.show('alert', "Kicked", UI.formatMsg('You', 'kick'));
                location.reload();
            }
            else {
                if(Game.remotePlayers[msg.target]) UI.addMessage("System", UI.formatMsg(Game.remotePlayers[msg.target].username, 'kick'), "red");
                delete Game.remotePlayers[msg.target];
            }
        }
        else if (msg.type === 'fuel' && msg.to === Game.localPlayer.id) {
            Game.localPlayer.fuel = Math.min(Game.localPlayer.maxFuel, Game.localPlayer.fuel + msg.amt);
            UI.showToast(`Received ${msg.amt} Fuel from ${msg.from}`, "success");
            Sound.playSuccess();
            if (Game.localPlayer.fuel < 20) UI.addMessage("System", UI.formatMsg(Game.settings.username, 'rescue'), "orange");
        }
        else if (msg.type === 'ctrl' && msg.type === 'transfer_admin' && msg.to === Game.localPlayer.id) {
            Game.promoteToAdmin();
        }
        else if (msg.type === 'explode') {
            Game.explode(msg.x, msg.y, msg.r, msg.t)
        } else if (msg.type === 'view_req' && Game.isAdmin) {
            // Only process if valid numbers

            if (typeof msg.x === 'number' && typeof msg.y === 'number') {
                this.sendAreaDiff(msg.x, msg.y, msg.w || 40, msg.h || 30, msg.id);
            }
        }
    }
}

// --- INPUT ---

class InputManager {
    constructor() {
        this.keys = {};
        this.virtual = { up: false, down: false, left: false, right: false, build: false, interact: false, chat: false, transfer: false, adminToggle:false };
        this.bindMode = null;
    }

    init() {
        window.addEventListener('keydown', e => {
            Sound.init();

            // --- FIX: Ignore game inputs while typing in chat ---
            if (document.activeElement === $('chat-input')) {
                if (e.key === 'Escape') $('chat-input').blur(); // Allow ESC to exit chat
                return; // Stop processing game keys
            } else if (document.activeElement === $('c-modal-input')) {
                return;
            }

            if (this.bindMode) {
                Game.settings.keys[this.bindMode] = e.key;
                localStorage.setItem('mm_keybinds', JSON.stringify(Game.settings.keys));
                UI.showToast(`Bound ${this.bindMode.toUpperCase()} to ${e.key}`, "success");
                this.bindMode = null;
                UI.refreshKeybindLabels();
                return;
            }
            this.keys[e.key] = true;
            if (e.key === Game.settings.keys.chat && document.activeElement !== $('chat-input')) {
                e.preventDefault();
                $('chat-input').focus();
            }
            if (Object.values(Game.settings.keys).includes(e.key) && e.key !== Game.settings.keys.chat) e.preventDefault();
        });
        window.addEventListener('keyup', e => this.keys[e.key] = false);

        // --- CHAT FIX: Handle Enter key on the input itself ---
        $('chat-input').addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.stopPropagation(); // Prevent game from re-focusing or doing other keybinds
                const msg = e.target.value.trim();
                if (msg.length > 0) {
                    Network.sendChat(msg);
                    e.target.value = '';
                    e.target.blur(); // Close keyboard / unfocus
                }
            }
        });

        // Touch / Mouse Events for Virtual Controls
        const bindTouch = (elem, key) => {
            const start = (e) => { e.preventDefault(); this.virtual[key] = true; elem.style.opacity = '0.5'; };
            const end = (e) => { e.preventDefault(); this.virtual[key] = false; elem.style.opacity = '1'; };
            elem.addEventListener('mousedown', start); elem.addEventListener('mouseup', end); elem.addEventListener('mouseleave', end);
            elem.addEventListener('touchstart', start); elem.addEventListener('touchend', end);
        };

        document.querySelectorAll('.d-btn, .act-btn').forEach(btn => {
            bindTouch(btn, btn.getAttribute('data-key'));
        });
    }

    handleCommand(cmd) {
        let parts = cmd.split(' ');
        if (parts[0] === '/tp' && Game.isAdmin) {
            if (parts.length === 3) {
                let x = parseInt(parts[1]); let y = parseInt(parts[2]);
                if (!isNaN(x) && !isNaN(y)) {
                    Game.localPlayer.gridX = x; Game.localPlayer.gridY = y;
                    Game.localPlayer.x = x * CONSTANTS.TILE_SIZE; Game.localPlayer.y = y * CONSTANTS.TILE_SIZE;
                    UI.showToast(`Teleported to ${x}, ${y}`, "success");
                    Network.broadcastMove();
                }
            } else if (parts.length === 2) {
                let target = Object.values(Game.remotePlayers).find(p => p.username === parts[1]);
                if (target) {
                    Game.localPlayer.gridX = target.gridX; Game.localPlayer.gridY = target.gridY;
                    Game.localPlayer.x = target.x; Game.localPlayer.y = target.y;
                    UI.showToast(`Teleported to ${target.username}`, "success");
                    Network.broadcastMove();
                } else UI.showToast("Player not found", "error");
            }
        }
        else if (parts[0] === '/op' && Game.isAdmin) {
            if (parts.length === 2) {
                let target = Object.values(Game.remotePlayers).find(p => p.username === parts[1]);
                if (target) {
                     Network.transferAdmin(target.id);
                     Game.demoteFromAdmin();
                     UI.showToast(`Transferred Admin to ${target.username}`, "success");
                } else {
                    UI.showToast("Player not found (case sensitive)", "error");
                }
            } else {
                UI.showToast("Usage: /op [Username]", "normal");
            }
        }
        else {
            UI.showToast("Unknown command or not admin", "error");
        }
    }

    startBind(action) { this.bindMode = action; UI.refreshKeybindLabels(); }
}

// --- UI & SAVES ---

class UIManager {
    constructor() {
        this.defaultServers = [
            "wss://broker.emqx.io:8084/mqtt",
            "wss://broker.hivemq.com:8884/mqtt",
            "wss://test.mosquitto.org:8081"
        ];
        this.customServers = JSON.parse(localStorage.getItem('mm_custom_servers') || '[]');
        if (localStorage.getItem('mm_cloudsync_setting')===true) $('startBtn').disabled = true;
        // Init server list on load
        setTimeout(() => this.refreshServerList(), 500);
    }

    rndMsg(type) { const arr = MSGS[type]; return arr[Math.floor(Math.random() * arr.length)]; }

    formatMsg(username, type) {
        let msg = this.rndMsg(type);
        if (msg.includes('<user>')) {
            return msg.replace(/<user>/g, username);
        }
        return `${username} ${msg}`;
    }

    addMessage(name, text, color='#fff') {
        const div = document.createElement('div');
        div.innerHTML = `<span style="color:${color}; font-weight:bold;">${name}:</span> ${text}`;
        $('chat-messages').appendChild(div);
        $('chat-messages').scrollTop = $('chat-messages').scrollHeight;

        // Mobile Unread Logic
        if(document.body.classList.contains('mobile-mode')) {
            const chat = $('chat-container');
            if(chat.classList.contains('minimized')) {
                chat.classList.add('unread');
                Sound.playChat('msg'); // Ensure sound plays so they know
            }
        }
    }

    // --- CHAT & ADMIN TOGGLES ---
    openChat() {
        if(document.body.classList.contains('mobile-mode')) {
            const chat = $('chat-container');
            chat.classList.remove('minimized');
            chat.classList.remove('unread');

            // Optional: Focus input automatically
            setTimeout(() => $('chat-input').focus(), 100);
        }
    }

    closeChat() {
        if(document.body.classList.contains('mobile-mode')) {
            $('chat-container').classList.add('minimized');
            $('chat-input').blur();
        }
    }

    toggleAdminPanel() {
        const panel = $('admin-panel');

        // If currently hidden, try to show it
        if (panel.hidden) {
            if (Game.isAdmin) {
                panel.hidden = false;
                this.updateAdminPanel();
            } else {
                panel.hidden = true;
                this.showToast("You are not Admin", "error");
            }
        } else {
            // Hide it
            panel.hidden = true;
        }
    }


    showToast(msg, type='normal',timeout=4000) {
        const area = $('notification-area');
        const el = document.createElement('div');
        el.className = `toast ${type}`;
        el.innerText = msg;
        area.appendChild(el);
        setTimeout(() => el.remove(), timeout);
    }

    openSettings() {
        $('settings-modal').classList.add('active');
        this.refreshKeybindLabels();
        SaveSystem.renderSaveList();
    }

    closeSettings() { $('settings-modal').classList.remove('active'); }

    refreshKeybindLabels() {
        const keys = Game.settings.keys;
        const map = { up: 'btn-bind-up', down: 'btn-bind-down', left: 'btn-bind-left', right: 'btn-bind-right', build: 'btn-bind-build', interact: 'btn-bind-interact', transfer: 'btn-bind-transfer', chat: 'btn-bind-chat' };
        for (let action in map) {
            let btn = $(map[action]);
            if (Input.bindMode === action) { btn.classList.add('binding'); btn.innerText = `PRESS KEY...`; }
            else { btn.classList.remove('binding'); btn.innerText = `${action.toUpperCase()}: ${keys[action]}`; }
        }
    }

    async randomizeName() {
        try {
            const btn = document.querySelector('button[title="Randomize"]');
            const originalText = btn.innerHTML;
            btn.innerHTML = '...';
            btn.disabled = true;

            const res = await fetch('https://randomuser.me/api?inc=login');
            const data = await res.json();
            const name = data.results[0].login.username;
            $('start-username').value = name;

            btn.innerHTML = originalText;
            btn.disabled = false;
        } catch(e) {
            console.error(e);
            UI.showToast("Failed to fetch name", "error");
            document.querySelector('button[title="Randomize"]').disabled = false;
        }
    }

    // --- SERVER LIST LOGIC ---
    refreshServerList() {
        if(puter.whoami && SaveSystem.cloudSyncEnabled){
            SaveSystem.smartSyncAll(true,true);
        } else {
            console.warn("No puter user detected, skipping cloud sync.");
        }

        const list = $('server-list-sidebar');
        list.innerHTML = '';

        // Render helper
        const renderItem = (url, isCustom) => {
            const isActive = url === Game.settings.broker;
            const item = document.createElement('div');
            item.className = `server-list-item ${isActive ? 'active' : ''}`;

            let buttonsHtml = '';
            if(isCustom) {
                buttonsHtml = `
                    <div class="server-actions">
                        <button class="btn btn-small" style="padding:2px 5px; background:#444; font-size: var(--fs-tiny); margin:0;" onclick="event.stopPropagation(); UI.editCustomServer('${url}')" title="Edit">&#9998;</button>
                        <button class="btn btn-small" style="padding:2px 5px; background:#c0392b; font-size: var(--fs-tiny); margin:0;" onclick="event.stopPropagation(); UI.removeCustomServer('${url}')" title="Remove">&times;</button>
                    </div>
                `;
            }

            item.innerHTML = `
                <div style="display:flex; align-items:center; overflow:hidden; flex:1;">
                    <div class="server-status-icon" id="status-${btoa(url).replace(/=/g,'')}"><div class="spin-loader"></div></div>
                    <span style="white-space:nowrap; overflow:hidden; text-overflow:ellipsis; margin-right:5px;" title="${url}">${url}</span>
                </div>
                ${buttonsHtml}
            `;
            item.onclick = () => this.selectServer(url);
            list.appendChild(item);
            this.checkServerStatus(url);
        };

        // Render Defaults
        this.defaultServers.forEach(url => renderItem(url, false));

        // Render Custom
        this.customServers.forEach(url => {
            if(!this.defaultServers.includes(url)) renderItem(url, true);
        });
    }

    async editCustomServer(oldUrl) {
        // --- MODAL REPLACEMENT ---
        const newUrl = await CustomModal.show('prompt', "Edit Server", "Enter new Server URL:", oldUrl);

        if(newUrl && newUrl !== oldUrl) {
            if(newUrl.startsWith('ws://') || newUrl.startsWith('wss://')) {
                const idx = this.customServers.indexOf(oldUrl);
                if(idx !== -1) {
                    this.customServers[idx] = newUrl;
                    localStorage.setItem('mm_custom_servers', JSON.stringify(this.customServers));

                    if(Game.settings.broker === oldUrl) {
                        this.selectServer(newUrl); // Update active selection
                    } else {
                        this.refreshServerList();
                    }
                    this.showToast("Server Updated", "success");
                }
            } else {
                this.showToast("Invalid URL (Must start with ws:// or wss://)", "error");
            }
        }
    }

    selectServer(url) {
        Game.settings.broker = url;
        localStorage.setItem('mm_broker_url', url);
        $('setting-broker').value = url;
        this.refreshServerList(); // Redraw to update active class
        this.showToast("Server Selected. Launch to Connect.", "normal");
    }

    addCustomServer() {
        const input = $('custom-server-input');
        const url = input.value.trim();
        if(url && (url.startsWith('ws://') || url.startsWith('wss://'))) {
            if(!this.customServers.includes(url) && !this.defaultServers.includes(url)) {
                this.customServers.push(url);
                localStorage.setItem('mm_custom_servers', JSON.stringify(this.customServers));
                input.value = '';
                this.refreshServerList();
                this.showToast("Server Added", "success");
                this.selectServer(url);
            } else {
                this.showToast("Server already exists", "error");
            }
        } else {
            this.showToast("Invalid URL (Must start with ws:// or wss://)", "error");
        }
    }

    async removeCustomServer(url) {
        // --- MODAL REPLACEMENT ---
        // Handles both calls (there was a duplicate in original code, this fixes it)
        const confirm = await CustomModal.show('confirm', "Remove Server", `Remove custom server: ${url}?`);

        if (confirm) {
            const index = this.customServers.indexOf(url);
            if (index > -1) {
                this.customServers.splice(index, 1);
                localStorage.setItem('mm_custom_servers', JSON.stringify(this.customServers));

                // If the deleted server was active, switch to default
                if (Game.settings.broker === url) {
                    Game.settings.broker = this.defaultServers[0];
                    localStorage.setItem('mm_broker_url', Game.settings.broker);
                    $('setting-broker').value = Game.settings.broker;
                }

                this.refreshServerList();
                this.showToast("Server Removed", "normal");
            }
        }
    }

    checkServerStatus(url) {
        const id = `status-${btoa(url).replace(/=/g,'')}`;
        const el = $(id);
        if(!el) return;


        const client = mqtt.connect(url, { connectTimeout: 9500, reconnectPeriod: 0 });

        let failedTimeout = setTimeout(() => { if(!client.connected) setStatus(false); }, 10000);

        const setStatus = (success) => {
            if(el) {
                el.innerHTML = success
                    ? `<span style="color:#2ecc71; font-weight:bold;">&#10003;</span>`
                    : `<span style="color:#e74c3c; font-weight:bold;">&#10007;</span>`;
            }
            client.end();
        };

        client.on('connect', () => {setStatus(true);clearTimeout(failedTimeout);});
        client.on('error', () => setStatus(false));
        client.on('close', () => {clearTimeout(failedTimeout);}); // silent

    }

    checkServers() {
        // Legacy settings modal check
        this.refreshServerList();
    }

    toggleUpdateCheck(val) {
        this.updateCheckEnabled = val;
        localStorage.setItem('mm_autocheck_update_setting', val);
        if (val===true){
            if (this.updateChecker) clearInterval(this.updateChecker);
            this.updateChecker=setInterval(UI.checkForUpdates,60000);
        }else{
            clearInterval(this.updateChecker)
        }
    }

    async checkForUpdates() {
        try {
            // 1. Check if we are checking a file or a valid web server
            if (location.protocol === 'file:') {
                UI.showToast("Can't check updates on file:// URLs", "normal");
                return;
            }

            // Setup the URL with a cache-busting timestamp
            const url = new URL(window.location.href);
            url.searchParams.set('_t', Date.now());

            // 2. Perform the HEAD request
            const headRes = await fetch(url.toString(), { method: 'HEAD' });

            // 3. Get the header and ensure it actually exists
            const newTimestamp = headRes.headers.get('last-modified');

            if (!newTimestamp) {
                console.warn("Server did not return a Last-Modified header. Cannot check for updates.");
                return;
            }

            // 4. Handle the Logic (using 'this.' to persist data)
            if (!this.initialTimestamp) {
                // First run: just save the timestamp
                this.initialTimestamp = newTimestamp;
                console.log("Initial version set to:", this.initialTimestamp);
            } else {
                // Subsequent runs: Compare
                if (newTimestamp !== this.initialTimestamp) {
                    console.log(`Update detected: ${this.initialTimestamp} -> ${newTimestamp}`);

                    UI.showToast("New Version Available!", "normal");
                    UI.addMessage("System", `Update detected! (${newTimestamp}) Please save and refresh.`, "#0f0", 9999999);
                    if(!Game.running) location.reload();
                    // Optional: Update the stored timestamp so we don't spam the user
                    // this.initialTimestamp = newTimestamp;
                }else{
                    console.log('No updates')
                }
            }

        } catch (e) {
            console.error('Update check error:', e);
        }
    }

    toggleDashboard() {
        const dash = $('dashboard-modal');
        if (dash.classList.contains('active')) {
            dash.classList.remove('active');
        } else {
            dash.classList.add('active');
            this.updateDashboard();
        }
    }

    // Use Consumable Logic
    useItem(type) {
        const p = Game.localPlayer;
        if ((p.inventory[type] || 0) > 0) {
            p.inventory[type]--;
            if (type === TILE_TYPES.REPAIR_KIT) {
                p.hull = Math.min(p.maxHull, p.hull + 50);
                this.showToast("Used Repair Kit (+50 HP)", "success");
            } else if (type === TILE_TYPES.FUEL_VOUCHER) {
                p.fuel = Math.min(p.maxFuel, p.fuel + 50);
                this.showToast("Used Fuel Voucher (+50 Fuel)", "success");
            }
            this.updateDashboard();
        }
    }

    updateDashboard() {
        const p = Game.localPlayer;
        const grid = $('inv-grid');
        grid.innerHTML = '';

        let types = Object.keys(p.inventory).map(Number);
        if(!types.includes(TILE_TYPES.CASING)) types.push(TILE_TYPES.CASING);

        types.forEach(type => {
            let count = p.inventory[type] || 0;
            if (count > 0 || type === TILE_TYPES.CASING) {
                let div = document.createElement('div');
                div.className = `inv-item ${p.selectedBlock == type ? 'active' : ''}`;
                div.style.color = TILE_PROPS[type].color || '#fff';

                let html = `${TILE_PROPS[type].name}<span class="inv-count">${count}</span>`;
                html += `<div class="inv-trash" onclick="event.stopPropagation(); Game.trashBlock(${type}, event.shiftKey)">x</div>`;

                // Add USE button for consumables
                if (TILE_PROPS[type].consumable) {
                    html += `<button class="inv-use-btn" onclick="event.stopPropagation(); UI.useItem(${type})">USE</button>`;
                }

                div.innerHTML = html;

                // Only equip non-consumables
                if (!TILE_PROPS[type].consumable) {
                    div.onclick = () => { p.selectedBlock = parseInt(type); UI.updateDashboard(); };
                }
                grid.appendChild(div);
            }
        });

        // Stats update
        $('stats-container').innerHTML = `
            <div class="stat-row"><span>Current Total Mined:</span><span>${p.stats.totalMined}</span></div>
            <div class="stat-row"><span>Current Depth:</span><span>${Math.floor(Math.max(0, p.gridY-4))}m</span></div>
            <div class="stat-row"><span>Current Cargo:</span><span>${p.cargo}</span></div>
            <div class="stat-row"><span>Current health:</span><span>${p.hull}</span></div>
            <div class="stat-row"><span>Current Money:</span><span>\$${p.money}</span></div>
        `;
        // Leaderboard
        // 1. SAFETY: Handle Game.remotePlayers being null/undefined
        const remote = Game.remotePlayers ? Object.values(Game.remotePlayers) : [];

        // 2. FILTER: Combine with 'p', but remove any null/undefined entries immediately
        // We also ensure every player has a .stats object before trying to sort them
        let players = remote.concat(p || []).filter(pl => pl && pl.stats);

        // 3. SORT: Now safe because we filtered above
        players.sort((a, b) => {
            // Fix: Your original code had 'totalMinedY' (likely a typo)
            return (b.stats.totalMined || 0) - (a.stats.totalMined || 0);
        });

        // 4. RENDER: Add checks for the DOM element and property fallbacks
        const lbContainer = $('leaderboard-container');
        if (lbContainer) {
            lbContainer.innerHTML = players.map((pl, i) => {
                // Fallback to "Unknown" and 0 if data is missing
                const name = pl.username || "Unknown";
                const score = pl.stats.totalMined || 0;
                return `<div class="stat-row"><span>${i+1}. ${name}</span><span>${score} blocks</span></div>`;
            }).join('');
        }

        // 5. BUTTON LOGIC: Guard clause for 'p'
        const btnContainer = $('station-btn-container');
        if (btnContainer) {
            // If 'p' doesn't exist yet, hide the button safely
            if (p && p.gridY === Game.stationGridY && Math.abs(p.gridX - Game.stationGridX) < 3) {
                btnContainer.style.display = 'block';
            } else {
                btnContainer.style.display = 'none';
            }
        }
    }

    updatePlayerList() {
        if (!Game.isAdmin) {
            $('admin-panel').hidden = true;
            return;
        }
        $('admin-panel').hidden = false;
        const list = $('player-list');
        list.innerHTML = '';
        Object.values(Game.remotePlayers).forEach(p => {
            const row = document.createElement('div');
            row.className = 'player-row';
            // Added Promote Button (P)
            row.innerHTML = `
                <span>${p.username}</span>
                <div style="display:flex; gap:2px;">
                    <button class="btn btn-small" style="background:#2980b9; padding:0 4px; width:20px;" title="Promote to Admin" onclick="Admin.promote('${p.id}')">P</button>
                    <button class="btn btn-small btn-danger" style="padding:0 4px; width:20px;" title="Kick" onclick="Admin.kick('${p.id}')">K</button>
                </div>`;
            list.appendChild(row);
        });
    }
    updateAdminPanel() { this.updatePlayerList(); }

    // --- NEW: Warp System Implementation ---
    openWarpMenu() {
        $('warp-modal').classList.add('active');
        const list = $('warp-list');
        list.innerHTML = '';

        // Option 1: Always available - Surface
        const surfaceBtn = document.createElement('button');
        surfaceBtn.className = 'btn';
        surfaceBtn.style.background = 'var(--success)';
        surfaceBtn.innerHTML = `<strong>Surface Station</strong> <span style="float:right; font-size: var(--fs-tiny); opacity:0.8;">0m</span>`;
        surfaceBtn.onclick = () => this.warpTo(Game.stationGridX, Game.stationGridY);
        list.appendChild(surfaceBtn);

        // Option 2: Discovered Relays
        const p = Game.localPlayer;
        if(p.teleporters && p.teleporters.length > 0) {
            // Sort by depth
            p.teleporters.sort((a,b) => a.y - b.y).forEach(t => {
                if (((t.y < 0) ? TILE_TYPES.EMPTY : Game.map[t.y][t.x]) === TILE_TYPES.TELEPORTER) {
                    const btn = document.createElement('button');
                    btn.className = 'btn';
                    btn.style.background = '#8e44ad';
                    btn.innerHTML = `<strong>${t.name}</strong> <span style="float:right; font-size: var(--fs-tiny); opacity:0.8;">${t.y}m</span>`;
                    btn.onclick = () => this.warpTo(t.x, t.y);
                    list.appendChild(btn);
                } else {
                    p.teleporters = p.teleporters.filter(teleporter => teleporter.name !== t.name)
                    console.log(`Removed missing teleporter at (${t.x},${t.y})`)
                }
            });
        } else {
            const msg = document.createElement('div');
            msg.style.padding = '15px';
            msg.style.color = '#777';
            msg.style.textAlign = 'center';
            msg.style.fontSize = '12px';
            msg.style.fontStyle = 'italic';
            msg.innerText = "No other relays discovered yet. Build Teleporters to expand your network.";
            list.appendChild(msg);
        }
    }

    warpTo(gx, gy) {
        const p = Game.localPlayer;

        // Visual effects before moving
        Game.spawnParticle(p.x + 16, p.y + 16, '#9b59b6', 15);

        // Move
        p.gridX = gx;
        p.gridY = gy;
        p.x = gx * CONSTANTS.TILE_SIZE;
        p.y = gy * CONSTANTS.TILE_SIZE;

        // Sync
        Network.broadcastMove();
        $('warp-modal').classList.remove('active');

        // Success Feedback
        UI.showToast("Warp Successful", "success");
        Sound.playSuccess();

        // Visual effects after arrival
        setTimeout(() => {
            Game.spawnParticle(p.x + 16, p.y + 16, '#fff', 20);
        }, 50);
    }
}

class AdminSystem {
    kick(id) { Network.kickUser(id); delete Game.remotePlayers[id]; UI.updatePlayerList(); }
    async promote(id) {
        // --- MODAL REPLACEMENT ---
        const confirm = await CustomModal.show('confirm', "Promote User", "Pass Admin privileges to this user? You will lose Admin status.");
        if(confirm) {
            Network.broadcastPromote(id);
        }
    }
}

class SaveSystem {
    static autosaveEnabled = true;
    static cloudSyncEnabled = false; // New property
    static currentSaveId = null;
    static db = null;
    static dbPromise = null;

    static init() {
        const as = localStorage.getItem('mm_autosave_setting');
        if(as !== null) this.autosaveEnabled = (as === 'true');
        $('autosave-toggle').checked = this.autosaveEnabled;
        $('cloudSync-auto').onchange = (e) => SaveSystem.toggleCloudSync(e.target.checked);
        UI.toggleUpdateCheck($('update-check-toggle').checked);
        $('update-check-toggle').onchange = (e) => UI.toggleUpdateCheck(e.target.checked);

        // --- CLOUD INIT ---
        const cs = localStorage.getItem('mm_cloudsync_setting');
        this.cloudSyncEnabled = (cs === 'true');
        const cloudCheck = $('cloudSync-auto');
        if(cloudCheck) cloudCheck.checked = this.cloudSyncEnabled;

        // --- UPDATE-CHECK INIT ---
        const uc = localStorage.getItem('mm_autocheck_update_setting');
        this.updateCheckEnabled = (uc === 'true');
        const updateCheck = $('update-check-toggle');
        if(updateCheck) updateCheck.checked = this.updateCheckEnabled;

    }

    static toggleAutosave(val) {
        this.autosaveEnabled = val;
        localStorage.setItem('mm_autosave_setting', val);
    }

    static toggleCloudSync(val) {
        this.cloudSyncEnabled = val;
        localStorage.setItem('mm_cloudsync_setting', val);
    }

    static async smartSyncAll(isSilent, noStartBtn) {
        if (!isSilent) UI.showToast("Starting Smart Sync...", "info");
        if (noStartBtn) $('startBtn').disabled = true;
        await this.initDB();

        // 1. Get Local IDs
        const metas = await new Promise(resolve => {
            const req = this.db.transaction("save_meta", "readonly").objectStore("save_meta").getAll();
            req.onsuccess = () => resolve(req.result || []);
        });

        let counts = { uploaded: 0, downloaded: 0, synced: 0 };

        // 2. Sync Existing Local Worlds
        for (const meta of metas) {
            const localData = await new Promise(resolve => {
                const req = this.db.transaction("saves", "readonly").objectStore("saves").get(meta.id);
                req.onsuccess = () => resolve(req.result);
            });

            if (localData) {
                const res = await CloudManager.syncWithConflictCheck(meta.id, localData);
                if (counts[res] !== undefined) counts[res]++;
            }
        }

        // 3. Discover "New" Worlds on Cloud
        let allCloudItems = [];
        try {
            const docs = await puter.fs.readdir('/Documents/MegaMinerSaves');
            allCloudItems = [...allCloudItems, ...docs];
        } catch(e) {}
        try {
            const sandbox = await puter.fs.readdir('./');
            allCloudItems = [...allCloudItems, ...sandbox];
        } catch(e) {}

        // Filter out duplicates and non-save files
        const uniqueFiles = allCloudItems.filter((item, index, self) =>
            item.name.startsWith('mm_world_') &&
            index === self.findIndex((t) => t.name === item.name)
        );

        for (const file of uniqueFiles) {
            const fileId = parseInt(file.name.replace('mm_world_', '').replace('.json', ''));
            if (!metas.find(m => m.id === fileId)) {
                console.log("Found new world in cloud:", fileId);
                const data = await CloudManager.download(fileId);
                if (data) {
                    await this.injectIntoLocal(data);
                    counts.downloaded++;
                }
            }
        }

        this.renderSaveList();
        if (counts.uploaded + counts.downloaded > 0) {
            const syncMsg = `Sync Complete: ${counts.uploaded} uploaded, ${counts.downloaded} downloaded.`;
            console.log(syncMsg);
            UI.showToast(syncMsg, "success");
        } else {
            if (!isSilent) UI.showToast("Worlds are already in sync.", "normal");
        }
        $('startBtn').disabled = false;
    }

    // Helper to look in both Global and Sandbox
    static async getAnyCloudFiles() {
        let files = [];
        try { files = await puter.fs.readdir('/Documents/MegaMinerSaves'); } catch(e) {}
        try {
            const sandboxFiles = await puter.fs.readdir('./');
            files = [...files, ...sandboxFiles];
        } catch(e) {}

        // Filter for unique filenames only
        return files.filter((v, i, a) => a.findIndex(t => t.name === v.name) === i && v.name.startsWith('mm_world_'));
    }

    static async saveGame(id, name = null, isAuto = false) {
        if (Network.client && Network.client.connected && !Game.isAdmin) return;

        try {
            await this.initDB();

            let finalName = name;
            if(!finalName) {
                const existing = await this.getMeta(id);
                finalName = existing ? existing.name : `Save ${id}`;
            }

            const cleanPlayer = JSON.parse(JSON.stringify(Game.localPlayer));
            const cleanMap = JSON.parse(JSON.stringify(Game.map));
            const cleanDiscovered = Game.discovered.map(r => Array.from(r));

            const fullData = {
                id: id,
                name: finalName, // Added name to fullData for cloud context
                player: cleanPlayer,
                map: cleanMap,
                discovered: cleanDiscovered,
                banned: Game.bannedIds,
                timestamp: Date.now()
            };

            const metaData = {
                id: id,
                name: finalName,
                timestamp: Date.now()
            };

            // 1. LOCAL SAVE (IndexedDB)
            await new Promise((resolve, reject) => {
                const tx = this.db.transaction(["saves", "save_meta"], "readwrite");
                tx.objectStore("saves").put(fullData);
                tx.objectStore("save_meta").put(metaData);
                tx.oncomplete = () => resolve();
                tx.onerror = (e) => reject(e);
            });

            localStorage.setItem('mm_last_save_id', id);

            // 2. CLOUD SYNC (If enabled)
            // We check the property or the DOM element directly
            if ($('cloudSync-auto') ? $('cloudSync-auto').checked : this.cloudSyncEnabled) {
                if(puter.whoami){
                  this.smartSyncAll();
                } else {
                  UI.showToast('Log in with Puter to use cloud sync','normal');
                }
            }

            if (!isAuto) {
                UI.showToast(`Saved "${finalName}"`, "success");
                this.renderSaveList();
            }

        } catch (e) {
            console.error("Error saving game", e);
            if (!isAuto) UI.showToast("Save Failed", "error");
        }
    }

    static async syncSaveListFromCloud() {
        UI.showToast("Searching cloud...", "info");
        try {
            // Try 'list' which is the standard v2 method
            const files = await puter.fs.readdir('.');
            console.log("Files found in cloud:", files); // CHECK YOUR CONSOLE FOR THIS

            const worldFiles = files.filter(f => f.name.startsWith('mm_world_'));

            if (worldFiles.length === 0) {
                UI.showToast("No cloud saves found for this account.", "warning");
                return;
            }

            for (const file of worldFiles) {
                const fileId = file.name.replace('mm_world_', '').replace('.json', '');
                const data = await CloudManager.download(fileId);
                if (data) await this.injectIntoLocal(data);
            }

            this.renderSaveList();
            UI.showToast(`Synced ${worldFiles.length} worlds!`, "success");
        } catch (e) {
            console.error("Fetch Error:", e);
            UI.showToast("Cloud search failed", "error");
        }
    }

    static async loadLinkCode() {
        try {
            // In Puter, 'Linking' is just signing in.
            // Once they sign in, their 'Guest' saves are migrated to their account.
            UI.showToast("Opening Puter Login...", "info");
            await puter.auth.signIn();

            // Refresh the UI after login
            if (typeof Cloud !== 'undefined' && Cloud.updateStatusDisplay) {
                await Cloud.updateStatusDisplay();
            }

            // Re-sync the list automatically after they log in
            await this.smartSyncAll(false,true);
        } catch (e) {
            console.error("Login failed:", e);
            UI.showToast("Cloud login cancelled", "normal");
        }
    }

    static async injectIntoLocal(data) {
        await this.initDB();
        return new Promise((resolve, reject) => {
            const tx = this.db.transaction(["saves", "save_meta"], "readwrite");

            // Use the timestamp from the CLOUD data, not the current time
            const metaData = {
                id: data.id,
                name: data.name || `World ${data.id}`,
                timestamp: data.timestamp // This is the Date.now() you just added!
            };

            tx.objectStore("saves").put(data);
            tx.objectStore("save_meta").put(metaData);

            tx.oncomplete = () => resolve();
            tx.onerror = (e) => reject(e);
        });
    }

    // New helper method to bridge with the Puter logic
    static async triggerCloudUpload(data) {
        try {
            if (typeof puter === 'undefined') return;

            // Note: 10MB JSON.stringify can be heavy on the main thread.
            const serialized = JSON.stringify(data);

            // Using Puter FS (File System) which is better for 10MB than KV
            await puter.fs.write('cloud_save_main.json', serialized);
            console.log("Cloud Sync: Success");
        } catch (err) {
            console.error("Cloud Sync: Failed", err);
            // We don't show a toast on every autosave failure to avoid spamming
        }
    }
    static async initDB() {
        if (!this.dbPromise) {
            this.dbPromise = new Promise((resolve, reject) => {
                const request = indexedDB.open("MegaMinerDB", 2); // Version bumped to 2
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    // Full map data store
                    if (!db.objectStoreNames.contains("saves")) {
                        db.createObjectStore("saves", { keyPath: "id" });
                    }
                    // Metadata store for fast listing
                    if (!db.objectStoreNames.contains("save_meta")) {
                        db.createObjectStore("save_meta", { keyPath: "id" });
                    }
                };
                request.onsuccess = (event) => {
                    resolve(event.target.result);
                };
                request.onerror = (event) => {
                    console.error("IndexedDB initialization failed", event);
                    reject(event);
                };
            });
        }
        this.db = await this.dbPromise;
    }

    // --- CORE SAVE LOGIC ---

    static async createNewSave() {
        // PROTECTION: Only Admin can create/save games
        if (Network.client && Network.client.connected && !Game.isAdmin) {
            UI.showToast("Only Admin can create saves.", "error");
            return;
        }

        // --- MODAL REPLACEMENT ---
        const name = await CustomModal.show('prompt', "New Save", "Enter Save Name:", "New World " + new Date().toLocaleTimeString());
        if(!name) return;

        const id = Date.now();
        this.currentSaveId = id;
        await this.saveGame(id, name);
        this.renderSaveList();
        UI.showToast("Created New Save", "success");
    }

    static async saveCurrent() {
        // PROTECTION: Only Admin can save
        if (Network.client && Network.client.connected && !Game.isAdmin) {
            UI.showToast("Only Admin can save.", "error");
            return;
        }

        if(this.currentSaveId) {
            await this.saveGame(this.currentSaveId);
        } else {
            this.createNewSave();
        }
    }

    static async getMeta(id) {
        await this.initDB();
        return new Promise(resolve => {
            const req = this.db.transaction("save_meta", "readonly").objectStore("save_meta").get(id);
            req.onsuccess = () => resolve(req.result);
            req.onerror = () => resolve(null);
        });
    }

    static async loadGame(id, silent = false) {
        // PROTECTION: Only Admin can load saves
        if (Network.client && Network.client.connected && !Game.isAdmin) {
            if(!silent) UI.showToast("Only Admin (Host) can load saves.", "error");
            return;
        }

        await this.initDB();

        try {
            const data = await new Promise((resolve, reject) => {
                const tx = this.db.transaction(["saves"], "readonly");
                const store = tx.objectStore("saves");
                const req = store.get(id);

                req.onsuccess = () => resolve(req.result);
                req.onerror = (e) => reject(e);
            });

            if (!data) {
                if(!silent) UI.showToast("Corrupt or missing save data.", "error");
                return;
            }

            this.currentSaveId = id; // Set ID so autosave works correctly
            this.restoreData(data);
            if(!silent) UI.closeSettings();

        } catch (e) {
            if(!silent) UI.showToast("Failed to load save", "error");
            console.error(e);
        }
    }

    static async deleteGame(id) {
        const confirm = await CustomModal.show('confirm', "Delete Save", "Delete this save forever?");
        if(!confirm) return;

        await this.initDB();
        try {
            const tx = this.db.transaction(["saves", "save_meta"], "readwrite");
            tx.objectStore("saves").delete(id);
            tx.objectStore("save_meta").delete(id);

            tx.oncomplete = async () => {
                // Clean up cloud as well
                try{
                    await CloudManager.delete(id);
                }catch(e){
                    console.error(e);
                }

                UI.showToast("Save Deleted", "normal");
                this.renderSaveList();
                if(this.currentSaveId === id) this.currentSaveId = null;
            };
        } catch (e) {
            console.error(e);
        }
    }

    // --- RENDER LIST ---
    static async renderSaveList() {
        await this.initDB();
        const container = $('save-list-wrapper');
        container.innerHTML = 'Loading saves...';

        // Get all meta
        const metas = await new Promise(resolve => {
             const req = this.db.transaction("save_meta", "readonly").objectStore("save_meta").getAll();
             req.onsuccess = () => resolve(req.result);
             req.onerror = () => resolve([]);
        });

        container.innerHTML = '';
        if(metas.length === 0) {
            container.innerHTML = '<div style="padding:10px; color:#555;">No saves found.</div>';
            return;
        }

        // Sort by newest
        metas.sort((a,b) => b.timestamp - a.timestamp);

        metas.forEach(meta => {
            const div = document.createElement('div');
            const isActive = meta.id === this.currentSaveId;
            div.className = `save-slot ${isActive ? 'active' : ''}`;
            const dateStr = new Date(meta.timestamp).toLocaleString();

            div.innerHTML = `
                <div class="save-slot-info">
                    <strong>${meta.name}</strong> ${isActive ? '<span style="color:var(--success)">(Current)</span>' : ''}  ${Date.now() - meta.timestamp <= 30 * 60 * 1000 ? '<span style="color:var(--success)">(Recent)</span>' : ''}<br>
                    <span style="font-size: var(--fs-tiny); color:#999">${dateStr}</span>
                </div>
                <div class="save-slot-actions">
                    <button class="btn" style="background:#555;" onclick="SaveSystem.loadGame(${meta.id})">Load</button>
                    <button class="btn btn-danger" onclick="SaveSystem.deleteGame(${meta.id})">X</button>
                    <button class="btn" style="background:#444;" onclick="SaveSystem.exportGame(${meta.id})">Export</button>
                </div>
            `;
            container.appendChild(div);
        });
    }

    static async exportGame(id) {
         await this.initDB();
         const req = this.db.transaction("saves", "readonly").objectStore("saves").get(id);
         req.onsuccess = () => {
             const data = req.result;
             if(data) {
                const blob = new Blob([JSON.stringify(data)], { type: "application/json" });
                const a = document.createElement("a");
                a.href = URL.createObjectURL(blob);
                a.download = `mm_save_${id}.json`;
                a.click();
             }
         }
    }

    static importSave(input) {
        // PROTECTION: Only Admin can import saves
        if (Network.client && Network.client.connected && !Game.isAdmin) {
             UI.showToast("Only Admin (Host) can import saves.", "error");
             input.value = '';
             return;
        }

        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const data = JSON.parse(e.target.result);
                this.restoreData(data);
                // Create a new entry for this imported save
                this.currentSaveId = Date.now();
                this.saveGame(this.currentSaveId, "Imported " + new Date().toLocaleTimeString());
            } catch(e) { UI.showToast("Invalid File", "error"); }
        };
        if(input.files[0]) reader.readAsText(input.files[0]);
    }

    static restoreData(data) {
        // Stop the loop briefly? No, just atomic update.
        // Deep merge player stats
        if(data.player) {
            // Keep current Network Identity intact so we don't disconnect or ghost
            const currentId = Game.localPlayer.id;
            const currentJoinedAt = Game.localPlayer.joinedAt;

            Game.localPlayer = { ...Game.localPlayer, ...data.player };

            // Restore identity
            Game.localPlayer.id = currentId;
            Game.localPlayer.joinedAt = currentJoinedAt;

            // Ensure visual position matches grid
            Game.localPlayer.x = Game.localPlayer.gridX * CONSTANTS.TILE_SIZE;
            Game.localPlayer.y = Game.localPlayer.gridY * CONSTANTS.TILE_SIZE;
        }

        // Validate and Adapt map data
        if(data.map && Array.isArray(data.map) && data.map.length > 0) {
            // Exact match
            if (data.map.length === CONSTANTS.MAP_HEIGHT && data.map[0] && data.map[0].length === CONSTANTS.MAP_WIDTH) {
                Game.map = data.map;
            }
            // Dimension mismatch - Adapt (Trim or Extend)
            else {
                console.warn("Save map dimensions mismatch. Adapting...");
                UI.showToast("Map size changed. Adapting save data...", "normal");

                // Overlay saved map onto generated map
                // Note: Game.map is already populated with procedural terrain from init()
                for (let y = 0; y < CONSTANTS.MAP_HEIGHT; y++) {
                    if (y < data.map.length) {
                        const savedRow = data.map[y];
                        // Safety check for row existence
                        if (!savedRow) continue;

                        if (savedRow.length === CONSTANTS.MAP_WIDTH) {
                            Game.map[y] = savedRow;
                        } else {
                            // Width mismatch: copy what fits
                            const len = Math.min(savedRow.length, CONSTANTS.MAP_WIDTH);
                            for (let x = 0; x < len; x++) {
                                Game.map[y][x] = savedRow[x];
                            }
                        }
                    }
                }
            }
        } else {
            console.warn("Save data map invalid or empty. Keeping generated map.");
            if(data.map) UI.showToast("Map data corrupt. Generated new map. (This is normal for new worlds)", "error");
        }

        if(data.discovered && Array.isArray(data.discovered)) {
            // Adapt discovered array logic similarly
             for (let y = 0; y < CONSTANTS.MAP_HEIGHT; y++) {
                if (y < data.discovered.length) {
                    let savedRow = data.discovered[y];
                    if (!savedRow) continue;

                    // Convert from object (JSON serialization of TypedArray) if needed
                    if (!(savedRow instanceof Uint8Array)) savedRow = new Uint8Array(Object.values(savedRow));

                    if (savedRow.length === CONSTANTS.MAP_WIDTH) {
                        Game.discovered[y] = savedRow;
                    } else {
                        const len = Math.min(savedRow.length, CONSTANTS.MAP_WIDTH);
                        for (let x = 0; x < len; x++) {
                             Game.discovered[y][x] = savedRow[x];
                        }
                    }
                }
            }
        }

        if(data.banned) Game.bannedIds = data.banned;

        // Force refresh UI
        UI.showToast("Game Loaded!", "success");
        UI.updateDashboard();

        // Ensure map is redrawn correctly by resetting camera target slightly
        Game.camera.x = Game.localPlayer.x;
        Game.camera.y = Game.localPlayer.y;
    }
}

function generateCreditsHTML(data) {
    let html = "";

    for (const category in data) {
        html += `<div class="credits-section">`;
        html += `<h3>${category.replace(/([A-Z])/g, " $1").toUpperCase()}</h3>`;

        const section = data[category];

        // Simple string list (e.g., specialThanks)
        if (Array.isArray(section) && typeof section[0] === "string") {
            html += `<div class="credit-entry">`;
            html += `<ul class="simple-list">`;
            section.forEach(item => html += `<li>${item}</li>`);
            html += `</ul>`;
            html += `</div>`;
            continue;
        }

        // Object list (music, sfx, pictures, etc.)
        section.forEach(entry => {
            const key = Object.keys(entry)[0];
            const name = entry[key];
            const items = entry.items || entry.songs || [];

            html += `<div class="credit-entry">`;
            html += `<strong>${name}</strong>`;
            if (items.length > 0) {
                html += `<ul>`;
                items.forEach(i => html += `<li>${i}</li>`);
                html += `</ul>`;
            }
            html += `</div>`;
        });

        html += `</div>`;
    }

    return html;
}

function parseCSSCalc(calcString) {
    // Remove calc() wrapper and evaluate
    const expression = calcString.replace(/^calc\(|\)$/g, '');

    // Simple evaluation for basic multiplication
    if (expression.includes('*')) {
        const parts = expression.split('*').map(p => p.trim());
        const left = parseFloat(parts[0]);
        const right = parseFloat(parts[1]);
        return left * right;
    }
}

function getFontSize(varName) { return parseCSSCalc(getComputedStyle(document.documentElement).getPropertyValue(varName))+'px'; }

// --- INSTANTIATION ---
const Game = new GameEngine();
const Input = new InputManager();
const Network = new NetworkManager();
const UI = new UIManager();
const Admin = new AdminSystem();
const Shop = new ShopSystem();
const Cloud = new CloudManager();

// Init Save System
SaveSystem.init();

// Expose
window.Game = Game;
window.UI = UI;
window.SaveSystem = SaveSystem;
window.Admin = Admin;
window.Shop = Shop;
window.Cloud = Cloud;
window.Input = Input;
window.Sound = Sound;

const creditsData = {
    music: [
        {
            artist: "Patrick de Arteaga",
            songs: ["Chiptronical","Great Little Challenge", "Solve The Puzzle"]
        },
        {
            artist: "Kevin Macleod",
            songs: ["Sneaky Snitch"]
        },
        {
            artist: "VibeHorn (Pixabay)",
            songs: ["Cozy Lofi Relax"]
        },
        {
            artist: "DELOSound (Pixabay)",
            songs: ["LoFi Background Music 3"]
        },
        {
            artist: "CFL_TurningPages (Pixabay)",
            songs: ["Field Duel lofi"]
        }
    ],

    specialThanks: [
        "My friends",
        "Playtesters",
        "Contributors",
        "The laptops that were sacrificed in the making of this game"
    ]
};
// JANK AUDIO FIX
Sound.loadSettings()
// bruh
document.getElementById('credits').innerHTML = generateCreditsHTML(creditsData);
</script>
</body>
</html>

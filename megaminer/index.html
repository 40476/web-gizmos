<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <link rel="icon" type="image/png" href="img/amogus.png">
    <title>Mega Miner Online - Mobile & Warfare Update</title>
    <!-- MQTT.js Library -->
    <script src="https://unpkg.com/mqtt/dist/mqtt.min.js"></script>
    <style>
        /* CSS Reset & Normalization */
        * { box-sizing: border-box; margin: 0; padding: 0; outline: none; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; touch-action: none; }

        :root {
            --bg-color: #0d0d0d;
            --panel-bg: rgba(20, 25, 40, 0.95);
            --text-color: #eee;
            --accent: #2980b9;
            --highlight: #f39c12;
            --danger: #c0392b;
            --success: #27ae60;
            --control-height: 180px; /* Reserved space for mobile controls */
        }
        body { overflow:hidden; font-family: 'Segoe UI', Roboto, Helvetica, Arial, monospace; color: var(--text-color); user-select: none; background: #000; }

        /* Canvas resizing handled by JS, but default to full */
        canvas { display: block; width: 100vw; height: 100vh; }

        .noaliasing {
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-optimize-contrast;
        }

        /* UI Overlay */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        .pointer-events-auto { pointer-events: auto; }

        /* Mobile Controls Container */
        #mobile-controls {
            display: none; /* Hidden by default */
            z-index: 150;
        }

        /* --- MOBILE MODE LAYOUTS --- */

        /* Portrait: Controls at bottom, Canvas shorter */
        @media (orientation: portrait) {
            body #gear-btn{

            }
            body.mobile-mode #mobile-controls {
                position: fixed; bottom: 0; left: 0; width: 100%; height: var(--control-height);
                background: #111; border-top: 2px solid #333;
                display: flex; justify-content: space-between; align-items: center;
                padding: 10px 20px; pointer-events: auto;
            }
            body.mobile-mode canvas { height: calc(100vh - var(--control-height)); width: 100vw; }
            body.mobile-mode #chat-container { bottom: calc(var(--control-height) + 20px); }
        }

        /* Landscape: Controls on sides, Canvas narrower in middle */
        /* Landscape: Controls on sides, Canvas narrower in middle */
        @media (orientation: landscape) {
            body #gear-btn{

            }
            body.mobile-mode #mobile-controls {
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: transparent; pointer-events: none;
                display: flex; justify-content: space-between; align-items: flex-end;
                padding: 20px;
            }

            body.mobile-mode .d-pad, body.mobile-mode .action-pad {
                pointer-events: auto;
                background: rgba(20, 20, 20, 0.8);
                border: 1px solid #444;
                border-radius: 16px;
                padding: 15px;
                margin-bottom: 20px;
                backdrop-filter: blur(4px);
            }

            /* Shift Game Canvas to center, avoiding overlap */
            body.mobile-mode #gameCanvas {
                position: absolute; top: 0; left: 200px;
                width: calc(100vw - 400px); /* 200px buffer each side */
                height: 100vh;
            }

            /* Update: Chat in Left Panel for Mobile Landscape */
            body.mobile-mode #chat-container {
                left: 10px;
                bottom: 220px; /* Above the D-Pad */
                width: 180px;  /* Fit in the 200px sidebar */
                height: 120px;
            }
        }

        /* D-PAD */
        .d-pad {
            width: 150px;
            height: 150px;
            position: relative;
        }
        .d-btn {
            position: absolute;
            width: 50px;
            height: 50px;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.3);
            border-radius: 8px;
            color: #aaa;
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            -webkit-user-select: none;
        }
        .d-btn:active { background: var(--accent); color: white; }
        .d-up { top: 0; left: 50px; }
        .d-down { bottom: 0; left: 50px; }
        .d-left { top: 50px; left: 0; }
        .d-right { top: 50px; right: 0; }

        /* Action Buttons */
        .action-pad {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            width: 160px;
        }
        .act-btn {
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.3);
            border-radius: 50%;
            color: white;
            font-weight: bold;
            font-size: 12px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
        }
        .act-btn:active { background: var(--highlight); color: black; transform: scale(0.95); }
        .act-btn i { font-size: 16px; margin-bottom: 2px; font-style: normal;}

        /* Gear Icon */
        #gear-btn { position: absolute; top: 10px; left: 10px; font-size: 30px; color: rgba(255,255,255,0.5); cursor: pointer; pointer-events: auto; z-index: 50; transition: all 0.3s; }
        #gear-btn:hover { color: #fff; transform: rotate(90deg); }

        /* Coords Display */
        #coords-display { position: absolute; top: 10px; left: 60px; font-size: 14px; color: #aaa; font-family: monospace; display: none; text-shadow: 1px 1px 0 #000; }

        /* Mobile specific coords adjustment */
        body.mobile-mode #coords-display { top: 40px; left: 10px; }

        /* Overheat Overlay */
        #heat-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; box-shadow: inset 0 0 0px var(--danger); transition: box-shadow 0.2s; opacity: 0; }

        /* Connection Screens */
        #connection-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #050505; z-index: 300; display: none; flex-direction: column; align-items: center; justify-content: center; pointer-events: auto; }
        #connection-log { font-family: monospace; color: var(--success); margin-top: 20px; font-size: 14px; text-align: left; width: 300px; height: 100px; overflow-y: auto; border: 1px solid #333; padding: 10px; background: #000; }
        .log-line { margin: 2px 0; }
        .spinner { width: 40px; height: 40px; border: 4px solid #333; border-top: 4px solid var(--highlight); border-radius: 50%; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* Connection Lost Overlay */
        #disconnect-msg { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: var(--danger); font-size: 32px; font-weight: bold; background: rgba(0,0,0,0.8); padding: 20px; border: 2px solid var(--danger); display: none; z-index: 200; text-align: center; }

        /* Chat */
        #chat-container { position: absolute; bottom: 120px; left: 10px; width: 300px; height: 150px; display: flex; flex-direction: column; pointer-events: auto; opacity: 0.8; transition: opacity 0.3s; z-index: 10; }
        #chat-container:hover { opacity: 1; }
        #chat-messages { flex: 1; overflow-y: auto; background: rgba(0,0,0,0.6); padding: 5px; font-size: 12px; scrollbar-width: thin; text-shadow: 1px 1px 0 #000; border: 1px solid #444; }
        #chat-input { background: rgba(0,0,0,0.8); border: 1px solid #444; color: white; padding: 5px; width: 100%; box-sizing: border-box; }

        /* Minimap */
        #minimap-container { position: absolute; top: 10px; right: 10px; width: 150px; height: 150px; border: 2px solid #555; background: #000; z-index: 20; overflow: hidden; }
        #minimap { display: block; width: 100%; height: 100%; }

        /* Interaction Prompts */
        #prompt-msg { position: absolute; top: 100px; left: 50%; transform: translateX(-50%); color: var(--highlight); font-size: 20px; font-weight: bold; text-shadow: 0 2px 4px #000; display: none; pointer-events: none; text-align: center; }

        /* Modals */
        .modal { display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: var(--panel-bg); padding: 20px; border: 2px solid var(--accent); border-radius: 8px; width: 600px; max-height: 85vh; overflow-y: auto; pointer-events: auto; z-index: 100; box-shadow: 0 0 30px rgba(0,0,0,0.9); }
        .modal.active { display: block; }
        .modal h2 { margin-top: 0; color: var(--highlight); border-bottom: 1px solid #444; padding-bottom: 10px; text-transform: uppercase; letter-spacing: 1px; }

        .form-group { margin-bottom: 15px; }
        .form-group label { display: block; margin-bottom: 5px; font-size: 13px; color: #aaa; text-transform: uppercase; }
        .form-group input[type="text"], .form-group select { width: 100%; padding: 8px; background: #222; border: 1px solid #444; color: white; box-sizing: border-box; }
        .form-group input:disabled { opacity: 0.5; cursor: not-allowed; }
        input[type=range] { width: 100%; accent-color: var(--accent); }

        /* Shop Grid */
        .shop-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
        .shop-item { background: rgba(0,0,0,0.3); padding: 10px; border: 1px solid #444; display: flex; flex-direction: column; justify-content: space-between; }
        .shop-item h4 { margin: 0 0 5px 0; color: var(--accent); }
        .shop-item p { font-size: 12px; color: #ccc; margin: 0 0 5px 0; }
        .shop-item .cost { color: var(--highlight); font-weight: bold; font-size: 14px; }

        /* Sell List */
        .sell-list { max-height: 150px; overflow-y: auto; margin-bottom: 20px; border: 1px solid #444; background: #111; }
        .sell-row { display: flex; justify-content: space-between; align-items: center; padding: 5px 10px; border-bottom: 1px solid #333; font-size: 12px; }
        .sell-row:last-child { border-bottom: none; }
        .sell-actions button { margin-left: 5px; padding: 2px 8px; font-size: 10px; }

        /* Dashboard (Stats/Inventory) */
        .dash-cols { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
        .inv-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(60px, 1fr)); gap: 5px; max-height: 200px; overflow-y: auto; }
        .inv-item { background: #222; border: 1px solid #444; padding: 5px; text-align: center; cursor: pointer; font-size: 10px; position: relative; transition: all 0.2s; pointer-events: auto; }
        .inv-item:hover { border-color: #fff; background: #333; }
        .inv-item.active { border-color: gold; box-shadow: 0 0 8px gold; background: rgba(255, 215, 0, 0.1); transform: scale(1.05); z-index: 10; }
        .inv-count { position: absolute; bottom: 2px; right: 2px; font-weight: bold; color: #fff; }
        .inv-trash { position: absolute; top: 0; right: 0; background: #c0392b; color: white; width: 15px; height: 15px; font-size: 10px; line-height: 15px; display: none; cursor: pointer; }
        .inv-trash:hover { filter: brightness(1.2); }
        .inv-item:hover .inv-trash { display: block; }

        .inv-use-btn {
            position: absolute;
            bottom: 0; left: 0; width: 100%;
            background: var(--success); color: white;
            font-size: 9px; font-weight: bold;
            border: none; cursor: pointer;
            z-index: 20;
        }

        .stat-row { display: flex; justify-content: space-between; font-size: 12px; border-bottom: 1px solid #333; padding: 2px 0; }

        .btn { background: var(--accent); color: white; border: none; padding: 10px; cursor: pointer; transition: all 0.2s; width: 100%; margin-top: 5px; font-weight: bold; border-radius: 4px; }
        .btn:hover { background: #3498db; filter: brightness(1.2); }
        .btn:disabled { background: #555; cursor: not-allowed; filter: none; }
        .btn-small { width: auto; padding: 4px 8px; font-size: 12px; margin-right: 5px; }
        .btn-danger { background: var(--danger); }
        .btn-bind { background: #444; border: 1px solid #666; color: #fff; text-align: left; position: relative; }
        .btn-bind.binding { background: #c0392b; border-color: #e74c3c; animation: pulse-red 1s infinite; }
        @keyframes pulse-red { 0% { opacity: 1; } 50% { opacity: 0.7; } 100% { opacity: 1; } }

        /* Credits Modal */
        #credits-modal .credits-section { margin-bottom: 25px; }
        #credits-modal h3 { margin: 10px 0; color: var(--accent); font-size: 18px; border-bottom: 1px solid #333; padding-bottom: 5px; text-transform: uppercase; letter-spacing: 1px; }
        .credit-entry { margin-left: 15px; margin-top: 8px; }
        .credit-entry strong { color: var(--highlight); font-size: 14px; }
        .credit-entry ul { margin: 5px 0 10px 20px; padding: 0; }
        .credit-entry li { list-style: none; font-size: 12px; color: #ccc; margin: 2px 0; }

        /* Server Status */
        .server-option { display: flex; justify-content: space-between; font-size: 12px; padding: 2px; }
        .status-dot { width: 8px; height: 8px; border-radius: 50%; display: inline-block; background: #555; margin-right: 5px; }
        .status-dot.green { background: #2ecc71; box-shadow: 0 0 5px #2ecc71; }
        .status-dot.red { background: #e74c3c; }

        /* Save Slots */
        .save-list-wrapper { max-height: 200px; overflow-y: auto; border: 1px solid #444; background: #111; padding: 5px; margin-bottom: 10px; }
        .save-slot { background: rgba(0,0,0,0.4); padding: 8px; border: 1px solid #555; margin-bottom: 5px; display: flex; justify-content: space-between; align-items: center; }
        .save-slot:hover { background: rgba(255,255,255,0.05); }
        .save-slot.active { border-color: var(--highlight); box-shadow: inset 0 0 10px rgba(243, 156, 18, 0.2); }
        .save-slot-info { font-size: 12px; color: #ccc; flex: 1; }
        .save-slot-actions { display:flex; gap: 5px; }
        .save-slot-actions button { margin: 0; padding: 4px 8px; font-size: 10px; }

        /* Start Screen */
        #start-screen { position: absolute;
          background-image:
            linear-gradient(30deg, #683131 12%, transparent 12.5%, transparent 87%, #683131 87.5%, #683131),
            linear-gradient(150deg, #683131 12%, transparent 12.5%, transparent 87%, #683131 87.5%, #683131),
            linear-gradient(30deg, #683131 12%, transparent 12.5%, transparent 87%, #683131 87.5%, #683131),
            linear-gradient(150deg, #683131 12%, transparent 12.5%, transparent 87%, #683131 87.5%, #683131),
            linear-gradient(60deg, #68313180 25%, transparent 25.5%, transparent 75%, #68313180 75%, #68313180),
            linear-gradient(60deg, #68313180 25%, transparent 25.5%, transparent 75%, #68313180 75%, #68313180);
        	background-size: 20px 35px;
          background-position: 0 0, 0 0, 10px 17.5px, 10px 17.5px, 0 0, 10px 17.5px;
          background-color: #362520;
          top: 0; left: 0; width: 100%; height: 100%;
          display: flex; flex-direction: column; align-items: center; justify-content: center;
          z-index: 50; pointer-events: auto;
        }
        #start-screen h1 { font-size: 48px; color: var(--highlight); margin-bottom: 20px; text-transform: uppercase; letter-spacing: 4px; text-shadow: 0 0 10px var(--highlight); }

        .start-container { display:flex; gap:20px; background:rgba(20, 25, 40, 0.95); padding:20px; border-radius:10px; border:1px solid #444; max-width: 800px; max-height: 90vh; overflow-y:auto; }
        .start-panel { width:300px; }
        .server-panel { width:300px; border-left:1px solid #444; padding-left:20px; display:flex; flex-direction:column; }

        @media (max-width: 700px) {
            .start-container { flex-direction: column; }
            .server-panel { border-left: none; border-top: 1px solid #444; padding-left: 0; padding-top: 20px; }
        }

        /* Server List Styles */
        .server-list-item { background:rgba(0,0,0,0.3); padding:8px; margin-bottom:5px; border:1px solid #333; font-size:12px; cursor:pointer; display:flex; align-items:center; justify-content:space-between; transition:0.2s; }
        .server-list-item:hover { background:rgba(255,255,255,0.05); }
        .server-list-item.active { border-color:var(--highlight); box-shadow:inset 0 0 5px rgba(243, 156, 18, 0.2); }
        .server-status-icon { width:12px; height:12px; margin-right:8px; display:flex; align-items:center; justify-content:center; }
        .spin-loader { border: 2px solid #555; border-top: 2px solid #fff; border-radius: 50%; width: 10px; height: 10px; animation: spin 1s linear infinite; }
        .server-actions { display: flex; gap: 4px; opacity: 0.6; transition: opacity 0.2s; }
        .server-list-item:hover .server-actions { opacity: 1; }

        /* Notification/Error Popup */
        #notification-area { position: absolute; top: 20px; right: 180px; width: 300px; display: flex; flex-direction: column; gap: 10px; pointer-events: none; z-index: 200; }
        .toast { background: rgba(30, 30, 30, 0.95); border-left: 4px solid var(--accent); padding: 12px; color: white; pointer-events: auto; animation: slideIn 0.3s ease; box-shadow: 0 4px 10px rgba(0,0,0,0.5); font-size: 14px; }
        .toast.error { border-left-color: var(--danger); }
        .toast.warn { border-left-color: var(--highlight); }
        .toast.success { border-left-color: var(--success); }
        @keyframes slideIn { from { transform: translateX(100%); opacity: 0; } to { transform: translateX(0); opacity: 1; } }

        /* Admin Panel */
        #admin-panel { position: absolute; top: 165px; right: 10px; background: rgba(0,0,0,0.7); padding: 10px; display: none; pointer-events: auto; width: 150px; border: 1px solid #555; }
        .player-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px; font-size: 11px; }

        /* --- FIXES --- */

        /* 1. Mobile Toast Fix: prevent off-screen width causing overflow/glitches */
        @media (max-width: 600px) {
            #notification-area {
                right: 10px;
                left: 10px;
                width: auto;
                top: 60px;
            }
        }

        /* 2. Scroll Fix: Re-enable scrolling on containers that need it */
        .start-container,
        .modal,
        #server-list-sidebar,
        .sell-list,
        .inv-grid,
        #chat-messages,
        #connection-log,
        #save-list-wrapper,
        .save-list-wrapper {
            touch-action: pan-y !important;
        }

        /* 3. Animation Fix: Use Vertical slide instead of Horizontal to prevent layout thrashing */
        @keyframes slideIn {
            from { transform: translateY(-20px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <div id="mobile-controls">
        <div class="d-pad">
            <div class="d-btn d-up" data-key="up">&#8593;</div>
            <div class="d-btn d-left" data-key="left">&#8592;</div>
            <div class="d-btn d-right" data-key="right">&#8594;</div>
            <div class="d-btn d-down" data-key="down">&#8595;</div>
        </div>
        <div class="action-pad">
            <div class="act-btn" data-key="build" style="background:var(--highlight); color:black;"><i>B</i>BUILD</div>
            <div class="act-btn" data-key="interact" style="background:var(--success);"><i>E</i>MENU</div>
            <div class="act-btn" data-key="chat" style="background:#555;"><i>&#9166;</i>CHAT</div>
            <div class="act-btn" data-key="transfer" style="background:#8e44ad;"><i>F</i>GIVE</div>
        </div>
    </div>

    <div id="ui-layer">
        <div id="heat-overlay"></div>

        <!-- Gear Icon -->
        <div id="gear-btn" onclick="UI.openSettings()">&#9881;</div>

        <!-- Coords -->
        <div id="coords-display">X: 0 Y: 0</div>

        <!-- Connection Lost -->
        <div id="disconnect-msg">CONNECTION LOST<br><span style="font-size:16px; font-weight:normal; color:#fff;">Trying to reconnect...</span></div>

        <!-- Connection Screen -->
        <div id="connection-screen">
            <div class="spinner"></div>
            <h2 style="color:#fff; margin-top:20px;">ESTABLISHING UPLINK</h2>
            <div id="connection-log"></div>
        </div>

        <!-- Minimap -->
        <div id="minimap-container">
            <canvas id="minimap" class="noaliasing"></canvas>
        </div>

        <!-- Chat -->
        <div id="chat-container">
            <div id="chat-messages"></div>
            <input type="text" id="chat-input" placeholder="Press CHAT key to type...">
        </div>

        <!-- Admin Panel -->
        <div id="admin-panel">
            <h4 style="margin:0 0 10px 0; color:gold; font-size:12px;">Host Controls</h4>
            <div id="player-list"></div>
        </div>

        <!-- Prompt -->
        <div id="prompt-msg"></div>

        <!-- Start Screen -->
        <div id="start-screen">
            <h1>Mega Miner</h1>
            <div class="start-container">
                <div class="start-panel">
                    <div class="form-group">
                        <label>Username</label>
                        <div style="display:flex; gap:5px;">
                            <input type="text" id="start-username" placeholder="Enter Username" maxlength="12" style="flex:1;">
                            <button class="btn btn-small" style="width:auto; padding: 0 10px; font-size: 16px;" onclick="Game.randomizeUsername()" title="Randomize Username">&#127922;</button>
                        </div>
                    </div>
                    <div class="form-group">
                        <label>Room ID</label>
                        <input type="text" id="start-room" value="public-mine-1">
                    </div>
                    <div class="form-group">
                        <label>Vehicle Color</label>
                        <input type="color" id="start-color" value="#3498db" style="height:40px;">
                    </div>
                    <div class="form-group">
                        <label style="display:inline-flex; align-items:center;">
                            <input type="checkbox" id="mobile-toggle" onchange="Game.toggleMobile(this.checked)"> Enable Mobile Controls
                        </label>
                    </div>
                    <button class="btn" onclick="Game.init()">LAUNCH MISSION</button>
                    <button class="btn" style="margin-top:10px; background:#444;" onclick="UI.openSettings()">SETTINGS / IMPORT</button>
                </div>

                <div class="server-panel">
                    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
                        <label style="margin:0; font-size:12px; color:#aaa;">SERVER STATUS</label>
                        <button class="btn btn-small" style="width:auto; padding:2px 5px;" onclick="UI.refreshServerList()">&#8635;</button>
                    </div>
                    <div id="server-list-sidebar" style="flex:1; overflow-y:auto; max-height:200px; margin-bottom:10px;">
                        <!-- Injected via JS -->
                    </div>

                    <div class="form-group" style="margin-bottom:0;">
                        <label>Add Custom Server</label>
                        <div style="display:flex; gap:5px;">
                            <input type="text" id="custom-server-input" placeholder="wss://..." style="font-size:11px;">
                            <button class="btn btn-small" style="width:auto;" onclick="UI.addCustomServer()">+</button>
                        </div>
                    </div>
                    <div style="margin-top:10px; font-size:10px; color:#e74c3c; line-height:1.4; background:rgba(231, 76, 60, 0.1); padding:5px; border:1px solid #e74c3c;">
                        <strong>WARNING:</strong> You must select the SAME server as your friends to see them. Check status before joining.
                    </div>
                </div>
            </div>
        </div>

        <!-- Dashboard Modal (Inventory/Stats) -->
        <div id="dashboard-modal" class="modal">
            <h2>Pilot Dashboard</h2>
            <div class="dash-cols">
                <div>
                    <h4 style="color:#aaa; border-bottom:1px solid #444;">INVENTORY / BUILD</h4>
                    <p style="font-size:11px; color:#777;">Click item to Equip. Consumables have a [USE] button. Hover to Trash.</p>
                    <button class="btn btn-small" style="background:#c0392b; width:100%; margin-bottom:10px;" onclick="Game.trashJunk()">TRASH ALL JUNK (Dirt/Stone)</button>
                    <div id="inv-grid" class="inv-grid"></div>
                    <div id="station-btn-container" style="margin-top:20px; display:none;">
                        <button class="btn" style="background:var(--success);" onclick="Shop.open()">OPEN STATION SHOP</button>
                    </div>
                </div>
                <div>
                    <h4 style="color:#aaa; border-bottom:1px solid #444;">STATISTICS</h4>
                    <div id="stats-container"></div>

                    <h4 style="color:#aaa; border-bottom:1px solid #444; margin-top:20px;">LEADERBOARD (Local)</h4>
                    <div id="leaderboard-container"></div>
                </div>
            </div>
            <button class="btn" style="background:#555; margin-top:20px;" onclick="$('dashboard-modal').classList.remove('active')">Close</button>
        </div>

        <!-- Warp Modal -->
        <div id="warp-modal" class="modal">
            <h2>Teleporter Network</h2>
            <p style="font-size:12px; color:#ccc;">Select a destination. Discovered relays appear here automatically.</p>
            <div id="warp-list" class="warp-list"></div>
            <button class="btn" style="background:#555; margin-top:20px;" onclick="$('warp-modal').classList.remove('active')">Cancel</button>
        </div>

        <!-- Shop Modal -->
        <div id="shop-modal" class="modal">
            <h2>Service Station</h2>
            <div style="text-align:center; margin-bottom:15px; font-size:18px;">
                Wallet: <span id="shop-money" style="color:gold; font-weight:bold;">$0</span>
            </div>
            <button class="btn" style="margin-bottom:10px; background:var(--success);" onclick="Shop.sellAll()">SELL ALL ORES</button>
            <button class="btn" style="margin-bottom:10px; background:var(--success);" onclick="Shop.refuelRepair()">Refuel and Repair ($10)</button>

            <h4 style="color:#aaa; border-bottom:1px solid #444;">SELL MINERALS</h4>
            <div id="sell-list" class="sell-list"></div>

            <h4 style="color:#aaa; border-bottom:1px solid #444; margin-top:20px;">UPGRADES & SUPPLIES</h4>
            <div class="shop-grid">
                <!-- Upgrades -->
                <div class="shop-item">
                    <h4>Upgrade Drill</h4>
                    <p>Increases Mining Tier.</p>
                    <div class="cost" id="cost-drill"></div>
                    <button class="btn" id="btn-drill" onclick="Shop.buy('drill')">Upgrade</button>
                </div>
                <div class="shop-item">
                    <h4>Nanite Hull</h4>
                    <p>Increases Max HP.</p>
                    <div class="cost" id="cost-hull"></div>
                    <button class="btn" id="btn-hull" onclick="Shop.buy('hull')">Upgrade</button>
                </div>
                <div class="shop-item">
                    <h4>Fuel Compactor</h4>
                    <p>Increases Fuel Capacity.</p>
                    <div class="cost" id="cost-fuel"></div>
                    <button class="btn" id="btn-fuel" onclick="Shop.buy('fuel')">Upgrade</button>
                </div>
                <div class="shop-item">
                    <h4>Cargo Bay</h4>
                    <p>Increases Carrying Capacity.</p>
                    <div class="cost" id="cost-cargo"></div>
                    <button class="btn" id="btn-cargo" onclick="Shop.buy('cargo')">Upgrade</button>
                </div>
                <div class="shop-item">
                    <h4>Heat Shield</h4>
                    <p>Resist high temperatures.</p>
                    <div class="cost" id="cost-cool"></div>
                    <button class="btn" id="btn-cool" onclick="Shop.buy('cool')">Upgrade</button>
                </div>
                <div class="shop-item">
                    <h4>X-Ray Optics</h4>
                    <p>See minerals through walls.</p>
                    <div class="cost" id="cost-xray"></div>
                    <button class="btn" id="btn-xray" onclick="Shop.buy('xray')">Upgrade</button>
                </div>
                 <div class="shop-item">
                    <h4>Vehicle Paint</h4>
                    <p>Change your look.</p>
                    <input type="color" id="shop-color-picker" style="width:100%; height:30px; margin-bottom:5px;">
                    <button class="btn" onclick="Shop.buy('paint')">Repaint ($100)</button>
                </div>
                <!-- New Items -->
                 <div class="shop-item">
                    <h4>Repair Kit</h4>
                    <p>Restore 50 HP (Use in Inv).</p>
                    <div class="cost">$50</div>
                    <button class="btn" onclick="Shop.buy('repair_kit')">Buy</button>
                </div>
                <div class="shop-item">
                    <h4>Fuel Voucher</h4>
                    <p>Restore 50 Fuel (Use in Inv).</p>
                    <div class="cost">$50</div>
                    <button class="btn" onclick="Shop.buy('fuel_voucher')">Buy</button>
                </div>
                 <div class="shop-item">
                    <h4>TNT</h4>
                    <p>Explosive charge. Range: 3.</p>
                    <div class="cost">$200</div>
                    <button class="btn" onclick="Shop.buy('tnt')">Buy</button>
                </div>
                <div class="shop-item">
                    <h4>Nuke</h4>
                    <p>Massive destruction. Range: 10.</p>
                    <div class="cost" style="color:#c0392b;">$5000</div>
                    <button class="btn btn-danger" onclick="Shop.buy('nuke')">Buy</button>
                </div>
                <div class="shop-item">
                    <h4>Teleporter</h4>
                    <p>Fast travel to surface.</p>
                    <div class="cost">$1000</div>
                    <button class="btn" onclick="Shop.buy('teleporter')">Buy</button>
                </div>
            </div>
            <button class="btn" style="background:#555; margin-top:20px;" onclick="Shop.close()">Exit Station</button>
        </div>

        <!-- Settings Modal -->
        <div id="settings-modal" class="modal">
            <h2>Settings</h2>

            <div class="form-group">
                <label>Audio Mixer</label>
                <div style="font-size:12px; display:grid; grid-template-columns: 1fr 3fr 1fr; gap:10px; align-items:center;">
                    <span>Master</span> <input type="range" id="vol-master" min="0" max="1" step="0.01" value="0.5" oninput="Sound.setVolume('master', this.value)"> <span id="vol-disp-master">50%</span>
                    <span>Music</span> <input type="range" id="vol-music" min="0" max="1" step="0.01" value="0.1" oninput="Sound.setVolume('music', this.value)"> <span id="vol-disp-music">50%</span>
                    <span>SFX</span> <input type="range" id="vol-sfx" min="0" max="1" step="0.01" value="0.5" oninput="Sound.setVolume('sfx', this.value)"> <span id="vol-disp-sfx">50%</span>
                    <span>Engine</span> <input type="range" id="vol-engine" min="0" max="1" step="0.01" value="0.5" oninput="Sound.setVolume('engine', this.value)"> <span id="vol-disp-engine">50%</span>
                </div>
            </div>

            <div class="form-group">
                <label>Options</label>
                <div style="display:flex; gap:15px; flex-wrap:wrap;">
                    <label style="display:inline-flex; align-items:center; color:#eee;">
                        <input type="checkbox" id="autosave-toggle" checked onchange="SaveSystem.toggleAutosave(this.checked)"> Autosave
                    </label>
                    <label style="display:inline-flex; align-items:center; color:#eee;">
                        <input type="checkbox" id="coords-toggle" onchange="Game.toggleCoords(this.checked)"> Show Coordinates
                    </label>
                     <label style="display:inline-flex; align-items:center; color:#eee;">
                        <input type="checkbox" id="mobile-setting-toggle" onchange="Game.toggleMobile(this.checked)"> Mobile Controls
                    </label>
                    <label style="display:inline-flex; align-items:center; text-transform:none; color:#eee;">
                        <input type="checkbox" id="update-check-toggle" checked> Autocheck Updates (60s)
                    </label>
                </div>
            </div>

            <div class="form-group">
                <label>Update Checker</label>
                <div style="display:flex; gap:5px; margin-bottom:5px;">
                    <button class="btn btn-small" style="width:auto;" onclick="UI.checkForUpdates()">Check For Updates</button>
                </div>
                <div id="gh-status" style="font-size:11px; color:#aaa;">Check official repo for updates.</div>
            </div>

            <div class="form-group">
                <label>Active Broker (Set in Start Screen)</label>
                <input type="text" id="setting-broker" placeholder="wss://...t" disabled style="opacity:0.7">
                <small style="color:#777;">Reload to change connection.</small>
            </div>

            <div class="form-group">
                <label>Save Management (IndexedDB)</label>
                <div style="display:flex; gap:5px; margin-bottom:5px;">
                    <button class="btn" style="flex:1; background:var(--success);" onclick="SaveSystem.createNewSave()">+ NEW SAVE</button>
                    <button class="btn" style="flex:1;" onclick="SaveSystem.saveCurrent()">SAVE CURRENT</button>
                </div>
                <div id="save-list-wrapper" class="save-list-wrapper">
                    <!-- Saves injected here -->
                </div>
                <small style="color:#777;">Saves are unlimited. Green border indicates current session.</small>
            </div>
            <div class="form-group">
                <label>Controls</label>
                <div style="display:grid; grid-template-columns: 1fr 1fr; gap:5px; font-size:12px;">
                    <button id="btn-bind-up" class="btn btn-bind" onclick="Input.startBind('up')">UP</button>
                    <button id="btn-bind-left" class="btn btn-bind" onclick="Input.startBind('left')">LEFT</button>
                    <button id="btn-bind-down" class="btn btn-bind" onclick="Input.startBind('down')">DOWN</button>
                    <button id="btn-bind-right" class="btn btn-bind" onclick="Input.startBind('right')">RIGHT</button>
                    <button id="btn-bind-build" class="btn btn-bind" onclick="Input.startBind('build')">BUILD</button>
                    <button id="btn-bind-interact" class="btn btn-bind" onclick="Input.startBind('interact')">MENU/INTERACT</button>
                    <button id="btn-bind-transfer" class="btn btn-bind" onclick="Input.startBind('transfer')">TRANSFER</button>
                    <button id="btn-bind-chat" class="btn btn-bind" onclick="Input.startBind('chat')">CHAT</button>
                </div>
                <small>Hold BUILD + Arrow to place Equipped block. Mouse Wheel to Zoom.</small>
            </div>

            <div class="form-group">
                <label>Backup Data (File)</label>
                <div style="display: flex; gap: 5px; margin-bottom: 5px;">
                    <button class="btn" style="flex: 1; background:#444;" onclick="$('import-file').click()">Load Save from File</button>
                </div>
                <input type="file" id="import-file" style="margin-top:5px; display:none;" onchange="SaveSystem.importSave(this)">
            </div>
            <div id="credits"></div>
            <button class="btn" onclick="UI.closeSettings()">Close</button>
        </div>
    </div>

    <!-- Notification Area -->
    <div id="notification-area"></div>
<script>
const $ = id => document.getElementById(id);

// Robust UUID Generator (longer for collision avoidance)
const uuid = () => {
    if (typeof crypto !== 'undefined' && crypto.randomUUID) {
        return crypto.randomUUID();
    }
    // Fallback if crypto.randomUUID not available (older browsers/contexts)
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
        var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
        return v.toString(16);
    });
};

const now = () => Date.now();
const clamp = (num, min, max) => Math.min(Math.max(num, min), max);
const BUILD_TIMESTAMP = Date.now();

// --- SEEDED RNG ---
const pseudoRandom = (x, y) => {
    return Math.abs(Math.sin(x * 12.9898 + y * 78.233) * 43758.5453) % 1;
};

// --- CONFIG & STATE ---
const CONSTANTS = {
    TILE_SIZE: 32, CHUNK_SIZE: 16, SPEED_NORMAL: 1.75, SPEED_DRILL: 0.75,
    FUEL_CONSUMPTION: 0.125, MAP_WIDTH: 1000, MAP_HEIGHT: 2000, MIN_ZOOM: 0.5, MAX_ZOOM: 3.0
};


const TILE_TYPES = {
    EMPTY: 0, DIRT: 1, GRASS: 2, STONE: 3, HARD_STONE: 4, DEEP_SLATE: 5,
    COAL: 6, IRON: 7, GOLD: 8, DIAMOND: 9, EMERALD: 10, RUBY: 11,
    CASING: 20, BEDROCK: 99,
    // New Items
    TNT: 50, NUKE: 51, TELEPORTER: 52,
    REPAIR_KIT: 60, FUEL_VOUCHER: 61
};

const TILE_PROPS = {
    [TILE_TYPES.EMPTY]: { name: "Empty" },
    [TILE_TYPES.DIRT]: { name: "Dirt", color: '#5d4037', hardness: 1, value: 0, tier: 0 },
    [TILE_TYPES.GRASS]: { name: "Grass", color: '#388e3c', hardness: 1, value: 0, tier: 0 },
    [TILE_TYPES.STONE]: { name: "Stone", color: '#7f8c8d', hardness: 3, value: 0, tier: 1 },
    [TILE_TYPES.HARD_STONE]: { name: "Dense Stone", color: '#525a5b', hardness: 6, value: 0, tier: 2 },
    [TILE_TYPES.DEEP_SLATE]: { name: "Deep Slate", color: '#2c3e50', hardness: 10, value: 0, tier: 3 },
    [TILE_TYPES.COAL]: { name: "Coal", color: '#2c3e50', hardness: 2, value: 10, tier: 0 },
    [TILE_TYPES.IRON]: { name: "Iron", color: '#95a5a6', hardness: 4, value: 50, tier: 1 },
    [TILE_TYPES.GOLD]: { name: "Gold", color: '#f1c40f', hardness: 6, value: 150, tier: 2 },
    [TILE_TYPES.DIAMOND]: { name: "Diamond", color: '#3498db', hardness: 10, value: 500, tier: 3 },
    [TILE_TYPES.EMERALD]: { name: "Emerald", color: '#2ecc71', hardness: 12, value: 800, tier: 3 },
    [TILE_TYPES.RUBY]: { name: "Ruby", color: '#e74c3c', hardness: 15, value: 1200, tier: 4 },
    [TILE_TYPES.CASING]: { name: "Structure", color: '#95a5a6', hardness: 2, value: 0, tier: 0 },
    [TILE_TYPES.BEDROCK]: { name: "Bedrock", color: '#000000', hardness: 999, value: 0, tier: 99 },
    // New Items
    [TILE_TYPES.TNT]: { name: "TNT", color: '#e74c3c', hardness: 1, value: 0, tier: 0 },
    [TILE_TYPES.NUKE]: { name: "Nuke", color: '#2c3e50', hardness: 1, value: 0, tier: 0 },
    [TILE_TYPES.TELEPORTER]: { name: "Teleporter", color: '#9b59b6', hardness: 5, value: 0, tier: 0 },
    [TILE_TYPES.REPAIR_KIT]: { name: "Repair Kit", color: '#2ecc71', value: 0, consumable: true },
    [TILE_TYPES.FUEL_VOUCHER]: { name: "Fuel Voucher", color: '#e67e22', value: 0, consumable: true },
};

const MSGS = {
    join: [
        "spawned in.",
        "slid into the server.",
        "has entered the chat.",
        "is here to steal your ores.",
        "initialized connection.",
        "mounted their filesystem.",
        "is among us.",
        "has joined! Hide your snacks.",
        "*Record scratch* *Freeze frame* Yup, that's <user>. You're probably wondering how they got here.",
        "A wild <user> appeared!",
        "Everyone panic! <user> has arrived!",
        "<user> has joined. The quality of this room just went up by 0.0001%.",
        "<user> is now watching you. (Just kidding... probably.)"
    ],
    leave: [
        "rage quit.",
        "timed out (RIP).",
        "received SIGTERM.",
        "failed to compile.",
        "segfaulted.",
        "touched grass (Fatal Error).",
        "kernel panicked.",
        "unmounted themselves.",
        "decided to touch grass."
    ],
    kick: [
        "was yeeted.",
        "read the TOS wrong.",
        "was shown the door.",
        "forgot to pay rent."
    ],
    ban: [
        "has been banished to the shadow realm.",
        "caught the ban hammer.",
        "was added to the blacklist.",
        "was banished from this kingdom."
    ],
    death: [
        "forgot to breathe.",
        "became bedrock.",
        "needs a tutorial.",
        "rm -rf /'d themselves.",
        "experienced a stack overflow.",
        "dereferenced a null pointer.",
        "got rekt."
    ],
    rescue: ["is running on fumes!", "needs a fuel stim!", "is signaling SOS!"]
};

let initialTimestamp = null;

// --- SOUND ENGINE ---
class SoundManager {
    constructor() {
        this.ctx = null;
        this.nodes = {};
        this.volumes = { master: 0.5, music: 0.5, sfx: 0.5, engine: 0.3 };
        this.playlist = ['audio/Chiptronical.ogg', 'audio/Great_Little_Challenge.ogg', 'audio/Solve_The_Puzzle.ogg', 'audio/Sneaky_Snitch.mp3', 'audio/cozy-lofi-relax-468509.mp3', 'audio/field-duel-lofi-464436.mp3', 'audio/lofi-background-music-3-471122.mp3','audio/chill-lofi-beat-469069.mp3'];
        this.currentTrack = 0;
        this.noiseBuffer = null;
    }

    init() {
        if (!this.ctx) {
            this.ctx = new (window.AudioContext || window.webkitAudioContext)();
            this.noiseBuffer = this.createNoiseBuffer();
            this.setupNodes();
            this.setupEngineLoop();
            this.playNextMusic();
        } else if (this.ctx.state === 'suspended') {
            this.ctx.resume();
        }
    }

    setupNodes() {
        this.nodes.master = this.ctx.createGain();
        this.nodes.master.gain.value = this.volumes.master;
        this.nodes.master.connect(this.ctx.destination);

        this.nodes.music = this.ctx.createGain();
        this.nodes.music.gain.value = this.volumes.music;
        this.nodes.music.connect(this.nodes.master);

        this.nodes.sfx = this.ctx.createGain();
        this.nodes.sfx.gain.value = this.volumes.sfx;
        this.nodes.sfx.connect(this.nodes.master);

        this.nodes.engine = this.ctx.createGain();
        this.nodes.engine.gain.value = this.volumes.engine;
        this.nodes.engine.connect(this.nodes.master);
    }

    setVolume(type, val) {
        this.volumes[type] = parseFloat(val);
        if (this.nodes[type]) this.nodes[type].gain.setTargetAtTime(this.volumes[type], this.ctx.currentTime, 0.1);
        else if (type === 'master' && this.nodes.master) this.nodes.master.gain.setTargetAtTime(this.volumes[type], this.ctx.currentTime, 0.1);
        $(`vol-disp-${type}`).innerText = Math.round(val*100) + '%';
        localStorage.setItem(`mm_vol_${type}`, val);
    }

    createNoiseBuffer() {
        if (!this.ctx) return null;
        const bufSize = this.ctx.sampleRate * 2;
        const buffer = this.ctx.createBuffer(1, bufSize, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufSize; i++) data[i] = Math.random() * 2 - 1;
        return buffer;
    }

    setupEngineLoop() {
        const noise = this.ctx.createBufferSource();
        noise.buffer = this.noiseBuffer;
        noise.loop = true;
        const filter = this.ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 100;
        const gain = this.ctx.createGain();
        gain.gain.value = 0;
        noise.connect(filter);
        filter.connect(gain);
        gain.connect(this.nodes.engine);
        noise.start();

        this.nodes.engineRumbleGain = gain;
        this.nodes.engineFilter = filter;

        const grindNoise = this.ctx.createBufferSource();
        grindNoise.buffer = this.noiseBuffer;
        grindNoise.loop = true;
        grindNoise.playbackRate.value = 0.5;

        const grindFilter = this.ctx.createBiquadFilter();
        grindFilter.type = 'bandpass';
        grindFilter.frequency.value = 150;
        grindFilter.Q.value = 1.0;

        const grindGain = this.ctx.createGain();
        grindGain.gain.value = 0;

        grindNoise.connect(grindFilter);
        grindFilter.connect(grindGain);
        grindGain.connect(this.nodes.engine);
        grindNoise.start();

        this.nodes.drillGain = grindGain;
        this.nodes.drillFilter = grindFilter;
    }

    updateEngine(speed, isDrilling) {
        if (!this.ctx || !this.nodes.engineRumbleGain || !this.nodes.engineFilter || !this.nodes.drillGain || !this.nodes.drillFilter) return;

        const t = this.ctx.currentTime;
        let baseVol = (speed > 0.1) ? 0.3 : 0.05;
        let baseFreq = 60 + (speed * 30);

        this.nodes.engineRumbleGain.gain.setTargetAtTime(baseVol, t, 0.2);
        this.nodes.engineFilter.frequency.setTargetAtTime(baseFreq, t, 0.2);

        if (isDrilling) {
            this.nodes.drillGain.gain.setTargetAtTime(0.5, t, 0.05);
            this.nodes.drillFilter.frequency.setTargetAtTime(150 + Math.random()*100, t, 0.1);
        } else {
            this.nodes.drillGain.gain.setTargetAtTime(0, t, 0.1);
        }
    }

    playTone(freq, type, duration, vol = 0.1) {
        if (!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
        osc.connect(gain);
        gain.connect(this.nodes.sfx);
        osc.start();
        osc.stop(this.ctx.currentTime + duration);
    }

    playMining() {
        if (!this.ctx || !this.noiseBuffer) return;
        const t = this.ctx.currentTime;

        const src = this.ctx.createBufferSource();
        src.buffer = this.noiseBuffer;
        src.playbackRate.value = 0.4 + Math.random() * 0.2;

        const filter = this.ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 500;

        const gain = this.ctx.createGain();
        gain.gain.setValueAtTime(0.5, t);
        gain.gain.exponentialRampToValueAtTime(0.01, t + 0.15);

        src.connect(filter);
        filter.connect(gain);
        gain.connect(this.nodes.sfx);
        src.start();
        src.stop(t + 0.15);
    }

    playChat(type) {
        if (type==='join') { this.playTone(440, 'sine', 0.1); setTimeout(()=>this.playTone(880, 'sine', 0.2), 100); }
        else if (type==='leave') { this.playTone(440, 'sine', 0.1); setTimeout(()=>this.playTone(220, 'sine', 0.2), 100); }
        else if (type==='death') { this.playTone(100, 'sawtooth', 0.5, 0.2); }
        else this.playTone(600, 'triangle', 0.05);
    }
    playError() { this.playTone(150, 'sawtooth', 0.3, 0.1); }
    playSuccess() { this.playTone(800, 'sine', 0.1); setTimeout(()=>this.playTone(1200, 'sine', 0.2), 100); }
    playBuild() { this.playTone(300, 'square', 0.1); }
    playThud() { this.playTone(80, 'square', 0.1, 0.3); }

    playNextMusic() {
      try{
        if(this.musicSource) { this.musicSource.stop(); }
        this.currentTrack = Math.floor(Math.random() * 100) % this.playlist.length;
        const file = this.playlist[this.currentTrack];
        const audio = new Audio(file);
        const source = this.ctx.createMediaElementSource(audio);
        source.connect(this.nodes.music);
        audio.onended = () => this.playNextMusic();
        audio.onerror = () => { console.log("Music load failed, skipping"); this.playNextMusic(); };
        audio.play().catch(e=>console.log("Autoplay blocked"));
      }catch(e){
        console.error("Error playing music:", e);
      }
    }

    loadSettings() {
        ['master', 'music', 'sfx', 'engine'].forEach(t => {
            const v = localStorage.getItem(`mm_vol_${t}`);
            if(v !== null) {
                this.volumes[t] = parseFloat(v);
                $(`vol-${t}`).value = v;
                $(`vol-disp-${t}`).innerText = Math.round(v*100) + '%';
            }
        });
    }
}
const Sound = new SoundManager();

// --- GAME LOGIC ---

class GameEngine {
    constructor() {
        this.canvas = $('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.minimapCanvas = $('minimap');
        this.minimapCtx = this.minimapCanvas.getContext('2d');

        this.running = false;
        this.isMobile = false;

        this.settings = {
            username: '',
            color: '#3498db',
            broker: 'wss://broker.emqx.io:8084/mqtt',
            room: 'public',
            keys: {
                up: 'ArrowUp', left: 'ArrowLeft', right: 'ArrowRight', down: 'ArrowDown',
                build: 'b', interact: 'e', chat: 'Enter', transfer: 'f'
            }
        };

        this.localPlayer = {
            id: uuid(),
            gridX: CONSTANTS.MAP_WIDTH/2, gridY: 4,
            x: 0, y: 0,
            fuel: 100, maxFuel: 100,
            hull: 100, maxHull: 100,
            cargo: 0, maxCargo: 50,
            money: 0,
            temp: 0, maxTemp: 100,
            rotation: 0, isDrilling: false,
            drillTier: 0, heatResist: 0, xrayRange: 6,
            inventory: {},
            selectedBlock: TILE_TYPES.CASING,
            stats: { blocksMined: {}, totalMined: 0, startTime: now() },
            joinedAt: now()
        };

        this.map = [];
        this.discovered = [];
        this.remotePlayers = {};
        this.camera = { x: 0, y: 0 };
        this.zoom = 1.0;
        this.particles = [];
        this.explosives = []; // Track active TNT/Nuke timers
        this.isAdmin = false;
        this.hostId = null;
        this.bannedIds = JSON.parse(localStorage.getItem('mm_banned') || '[]');
        this.lastActionTime = 0;
        this.lastAutosave = 0;
        this.fallHeight = 0;
        this.stationGridX = CONSTANTS.MAP_WIDTH / 2;
        this.stationGridY = 4;
        this.lastHostHeartbeat = 0;

        this.loadStoredSettings();
    }

    // --- NEW: Persistent Stats (Wallet, Upgrades) ---
    saveLocalProgress() {
        if (!this.running) return;
        const data = {
            money: this.localPlayer.money,
            drillTier: this.localPlayer.drillTier,
            maxHull: this.localPlayer.maxHull,
            maxFuel: this.localPlayer.maxFuel,
            maxCargo: this.localPlayer.maxCargo,
            heatResist: this.localPlayer.heatResist,
            xrayRange: this.localPlayer.xrayRange,
            vehColor: this.settings.color
        };
        localStorage.setItem(`mm_stats_${this.settings.room}`, JSON.stringify(data));
    }

    loadLocalProgress() {
        try {
            const raw = localStorage.getItem(`mm_stats_${this.settings.room}`);
            if (raw) {
                const data = JSON.parse(raw);
                const p = this.localPlayer;
                if (data.money !== undefined) p.money = data.money;
                if (data.drillTier) p.drillTier = data.drillTier;
                if (data.maxHull) { p.maxHull = data.maxHull; p.hull = p.maxHull; }
                if (data.maxFuel) { p.maxFuel = data.maxFuel; p.fuel = p.maxFuel; }
                if (data.maxCargo) p.maxCargo = data.maxCargo;
                if (data.heatResist) p.heatResist = data.heatResist;
                if (data.xrayRange) p.xrayRange = data.xrayRange;
                if (data.vehColor) {
                    this.settings.color = data.vehColor;
                    $('start-color').value = data.vehColor;
                }
                console.log("Stats loaded from local storage.");
            }
        } catch(e) { console.error("Failed to load stats", e); }
    }

    // --- NEW: Stable Admin Logic ---
    checkHostHealth() {
        const nowTime = Date.now();

        // If I am Admin, I am the host.
        if (this.isAdmin) {
            this.hostId = this.localPlayer.id;
            this.lastHostHeartbeat = nowTime;
            return;
        }

        // If no host heard for 5 seconds, trigger election
        if (nowTime - this.lastHostHeartbeat > 5000) {
            this.electNewHost();
        }
    }

    electNewHost() {
        // Find oldest player including myself
        const all = Object.values(this.remotePlayers)
            .concat([this.localPlayer])
            .filter(p => p && p.joinedAt);

        // Sort by age
        all.sort((a, b) => a.joinedAt - b.joinedAt);

        // If I am the oldest survivor, I claim the throne
        if (all.length > 0 && all[0].id === this.localPlayer.id) {
            console.log("Host timed out. Claiming Host status.");
            this.isAdmin = true;
            this.hostId = this.localPlayer.id;
            this.lastHostHeartbeat = Date.now();
            Network.broadcastHostClaim(); // Tell everyone immediately
            UI.showToast("You are now the Admin (Host)", "success");
            UI.updateAdminPanel();
        }
    }
    loadStoredSettings() {

        if(localStorage.getItem('mm_username')) $('start-username').value = localStorage.getItem('mm_username');
        if(localStorage.getItem('mm_room_id')) $('start-room').value = localStorage.getItem('mm_room_id');
        if(localStorage.getItem('mm_veh_color')) $('start-color').value = localStorage.getItem('mm_veh_color');
        const showCoords = localStorage.getItem('mm_show_coords');
        if(showCoords === 'true') { $('coords-toggle').checked = true; this.toggleCoords(true); }

        // Load broker from storage or use default if none
        const storedBroker = localStorage.getItem('mm_broker_url');
        if (storedBroker) {
            this.settings.broker = storedBroker;
            $('setting-broker').value = storedBroker;
        } else {
            // Ensure input matches default if nothing stored
            $('setting-broker').value = this.settings.broker;
        }
        const binds = localStorage.getItem('mm_keybinds');
        if(binds) {
            try { this.settings.keys = {...this.settings.keys, ...JSON.parse(binds)}; } catch(e){console.error(e);}
        }

        // Mobile setting
        const mobile = localStorage.getItem('mm_mobile_mode') === 'true';
        $('mobile-toggle').checked = mobile;
        $('mobile-setting-toggle').checked = mobile;
        this.toggleMobile(mobile);
    }

    toggleMobile(enabled) {
        this.isMobile = enabled;
        localStorage.setItem('mm_mobile_mode', enabled);

        if (enabled) {
            document.body.classList.add('mobile-mode');
        } else {
            document.body.classList.remove('mobile-mode');
        }
        this.resize();
    }

    // Helper to get base procedural for syncing
    getProceduralTile(x, y) {
        if (y < 5) return TILE_TYPES.EMPTY;
        if (y === 5) return TILE_TYPES.GRASS;
        if (y === CONSTANTS.MAP_HEIGHT - 1) return TILE_TYPES.BEDROCK;

        let r = Game.getMapRandom(x, y);
        let type = TILE_TYPES.DIRT;
        if (y > 300) type = TILE_TYPES.DEEP_SLATE;
        else if (y > 100) type = TILE_TYPES.HARD_STONE;
        else if (y > 30) type = TILE_TYPES.STONE;

        if (r > 0.985) {
            if (y > 400) return TILE_TYPES.RUBY;
            else if (y > 250) return TILE_TYPES.EMERALD;
            else if (y > 150) return TILE_TYPES.DIAMOND;
        } else if (r > 0.96) {
            if (y > 100) return TILE_TYPES.GOLD;
        } else if (r > 0.92) {
            if (y > 50) return TILE_TYPES.IRON;
        } else if (r > 0.89) {
            return TILE_TYPES.COAL;
        }
        return type;
    }

    async randomizeUsername() {
        // UI feedback
        const btn = $('start-username').nextElementSibling;
        const originalText = btn.innerHTML;
        btn.innerHTML = '<div class="spin-loader" style="width:12px; height:12px; border-width:2px;"></div>';

        try {
            const res = await fetch('https://randomuser.me/api?inc=login');
            const data = await res.json();
            if (data.results && data.results[0]) {
                let name = data.results[0].login.username;
                // Clean up name slightly if it's too long
                if(name.length > 12) name = name.substring(0, 12);
                $('start-username').value = name;
            } else {
                throw new Error("Invalid API response");
            }
        } catch(e) {
            console.error("API Error, using fallback", e);
            $('start-username').value = 'Miner' + Math.floor(Math.random() * 1000);
        } finally {
             btn.innerHTML = originalText;
        }
    }

    init() {
        this.settings.username = $('start-username').value || 'Miner';
        this.localPlayer.username = this.settings.username;
        // FIX: Trim room ID to ensure seeds match perfectly across clients
        this.settings.room = ($('start-room').value || 'public').trim();
        this.settings.color = $('start-color').value;
        this.settings.broker = $('setting-broker').value;

        // Reset admin on init
        this.isAdmin = false;

        // --- STICKY TIMESTAMP LOGIC ---
        // Restore timestamp for this specific room if it exists
        const timeKey = `mm_joinedAt_${this.settings.room}`;
        const savedTime = localStorage.getItem(timeKey);

        if (savedTime) {
            // Restore previous session time to regain seniority
            this.localPlayer.joinedAt = parseInt(savedTime);
            console.log("Restored session time:", this.localPlayer.joinedAt);
        } else {
            // New session
            this.localPlayer.joinedAt = now();
            localStorage.setItem(timeKey, this.localPlayer.joinedAt);
        }

        localStorage.setItem('mm_username', this.settings.username);
        localStorage.setItem('mm_room_id', this.settings.room);
        localStorage.setItem('mm_veh_color', this.settings.color);
        localStorage.setItem('mm_broker_url', this.settings.broker);

        $('start-screen').style.display = 'none';
        $('connection-screen').style.display = 'flex';
        this.logConnection("Initializing System...");

        this.resize();
        window.addEventListener('resize', () => this.resize());
        window.addEventListener('wheel', (e) => {
            if (e.target.id === 'gameCanvas') {
                this.zoom = clamp(this.zoom - Math.sign(e.deltaY) * 0.1, CONSTANTS.MIN_ZOOM, CONSTANTS.MAX_ZOOM);
            }
        });

        this.minimapCanvas.width = 150;
        this.minimapCanvas.height = 150;

        let seed = 0;
        for (let i = 0; i < this.settings.room.length; i++) seed += this.settings.room.charCodeAt(i);
        this.roomSeed = seed * 12345;

        this.generateMap();
        Input.init();
        Sound.loadSettings();

        // Load stats before connecting
        this.loadLocalProgress();

        Network.connect();
        UI.refreshKeybindLabels();
        UI.checkForUpdates();

        // Start a new session tracking
        if (!SaveSystem.currentSaveId) SaveSystem.currentSaveId = Date.now();
    }

    logConnection(msg) {
        const d = document.createElement('div');
        d.className = 'log-line';
        d.innerText = `> ${msg}`;
        $('connection-log').appendChild(d);
        $('connection-log').scrollTop = $('connection-log').scrollHeight;
    }

    finishConnection() {
        // Critical: Do not re-initialize game state if we just reconnected
        if (this.running) {
            console.log("Reconnected to broker. Game state preserved.");
            $('connection-screen').style.display = 'none';
            // Just broadcast position to sync up
            Network.broadcastMove();
            return;
        }

        setTimeout(async () => {
            $('connection-screen').style.display = 'none';

            this.running = true;
            this.localPlayer.gridX = Math.floor(CONSTANTS.MAP_WIDTH / 2);
            this.localPlayer.gridY = 4;
            this.localPlayer.x = this.localPlayer.gridX * CONSTANTS.TILE_SIZE;
            this.localPlayer.y = this.localPlayer.gridY * CONSTANTS.TILE_SIZE;
            this.localPlayer.stats.startTime = now();
            Sound.init();

            // Initial Host Check: If I'm alone, I am Admin.
            if (Object.keys(this.remotePlayers).length === 0) {
                this.isAdmin = true;
                this.hostId = this.localPlayer.id;
                this.lastHostHeartbeat = Date.now();
                UI.showToast("Room Created. You are Admin.", "success");
                UI.updateAdminPanel();
            } else {
                // If others exist, wait for heartbeat.
                // If no heartbeat comes in loop(), checkHostHealth() will elect me if I'm oldest.
                this.isAdmin = false;
                UI.updateAdminPanel();
            }

            // ONLY load save if we are the host (Admin)
            if (this.isAdmin) {
                const lastId = localStorage.getItem('mm_last_save_id');
                if (lastId) {
                    console.log("Host detected, loading save:", lastId);
                    await SaveSystem.loadGame(parseInt(lastId), true);
                    UI.addMessage("System", "Auto-loaded previous save.", "#2ecc71");
                }
            } else {
                // If we are NOT admin (Client), ensure we rely on the procedural map + sync
                // We do NOT load any local saves to prevent overwriting the host's world
                Network.requestMap(null); // Request from host (broadcast if id is null or not found, see handler)
                UI.addMessage("System", "Waiting for Map Sync...", "#3498db");
            }

            this.loop();
            UI.addMessage("System", "Welcome. E for Menu/Shop. B to Build. F to Transfer.", "#FFFF00");
            Network.broadcastMove();
            // Removed updateAdminStatus call
        }, 1000);
    }

    resize() {
        if (this.isMobile) {
            if (window.innerWidth > window.innerHeight) {
                // Landscape: 200px buffer on each side (400px total)
                this.canvas.width = window.innerWidth - 400;
                this.canvas.height = window.innerHeight;
            } else {
                // Portrait: Bottom bar
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight - 180; // 180px for controls
            }
        } else {
            this.canvas.width = window.innerWidth;
            this.canvas.height = window.innerHeight;
        }
    }

    generateMap() {
        for (let y = 0; y < CONSTANTS.MAP_HEIGHT; y++) {
            this.map[y] = [];
            this.discovered[y] = new Uint8Array(CONSTANTS.MAP_WIDTH);
            for (let x = 0; x < CONSTANTS.MAP_WIDTH; x++) {
                if (y < 5) {
                    this.map[y][x] = TILE_TYPES.EMPTY;
                    this.discovered[y][x] = 1;
                }
                else if (y === 5) {
                     this.map[y][x] = TILE_TYPES.GRASS;
                     this.discovered[y][x] = 1;
                }
                else if (y === CONSTANTS.MAP_HEIGHT - 1) this.map[y][x] = TILE_TYPES.BEDROCK;
                else {
                    this.map[y][x] = this.getProceduralTile(x,y);
                }
            }
        }
    }

    getMapRandom(x, y) {
        const s = Math.sin(x * 12.9898 + y * 78.233 + this.roomSeed) * 43758.5453;
        return s - Math.floor(s);
    }

    toggleCoords(show) {
        $('coords-display').style.display = show ? 'block' : 'none';
        localStorage.setItem('mm_show_coords', show);
    }

    update() {
        if (!this.running) return;
        const p = this.localPlayer;
        const TS = CONSTANTS.TILE_SIZE;

        let targetX = p.gridX * TS;
        let targetY = p.gridY * TS;
        let dx = targetX - p.x;
        let dy = targetY - p.y;
        let dist = Math.sqrt(dx*dx + dy*dy);
        let speed = this.localPlayer.fuel > 0 ? (this.localPlayer.isDrilling ? CONSTANTS.SPEED_DRILL : CONSTANTS.SPEED_NORMAL) : 0.3;
        let isMoving = false;

        if (dist > speed) {
            let angle = Math.atan2(dy, dx);
            p.x += Math.cos(angle) * speed; p.y += Math.sin(angle) * speed;
            isMoving = true;
        } else {
            p.x = targetX; p.y = targetY; p.isDrilling = false;
            let ix = 0, iy = 0;
            // Input combining Keys + Virtual
            if (Input.keys[this.settings.keys.up] || Input.virtual.up) iy = -1;
            else if (Input.keys[this.settings.keys.down] || Input.virtual.down) iy = 1;
            else if (Input.keys[this.settings.keys.left] || Input.virtual.left) ix = -1;
            else if (Input.keys[this.settings.keys.right] || Input.virtual.right) ix = 1;

            // Build logic
            const buildPressed = Input.keys[this.settings.keys.build] || Input.virtual.build;

            if (buildPressed && (ix || iy)) {
                if (now() - this.lastActionTime > 200) {
                    this.tryBuild(p.gridX + ix, p.gridY + iy);
                    this.lastActionTime = now();
                }
            } else if (ix || iy) {
                if (ix === 1) p.rotation = -90 * (Math.PI/180);
                if (ix === -1) p.rotation = 90 * (Math.PI/180);
                if (iy === 1) p.rotation = 0;
                if (iy === -1) p.rotation = 180 * (Math.PI/180);

                let nx = p.gridX + ix;
                let ny = p.gridY + iy;
                if (nx >= 0 && nx < CONSTANTS.MAP_WIDTH && ny >= 4 && ny < CONSTANTS.MAP_HEIGHT) {
                    let tile = (ny < 0) ? TILE_TYPES.EMPTY : this.map[ny][nx];

                    // --- TELEPORTER LOGIC (Instant Travel) ---
                    if (tile === TILE_TYPES.TELEPORTER) {
                        $('prompt-msg').style.display = 'block';
                        $('prompt-msg').innerText = "PRESS E TO WARP";

                        // Check if we discovered this?
                        const known = p.teleporters.find(t => t.x === nx && t.y === ny);
                        if(!known) {
                            p.teleporters.push({ x: nx, y: ny, name: `Discovered Relay [${nx},${ny}]` });
                            UI.showToast("New Teleporter Discovered!", "success");
                            this.saveLocalProgress();
                        }
                    }

                    if (tile === TILE_TYPES.EMPTY || tile === TILE_TYPES.TELEPORTER) {
                        p.gridX = nx; p.gridY = ny;
                        if (p.gridY > 5 && p.fuel > 0) p.fuel -= CONSTANTS.FUEL_CONSUMPTION;
                        Network.broadcastMove();
                    } else if (tile !== TILE_TYPES.BEDROCK) {
                        if (now() - this.lastActionTime > 150) {
                            if (this.tryMine(nx, ny)) {
                                p.gridX = nx; p.gridY = ny;
                                p.isDrilling = true;
                                if (p.gridY > 5 && p.fuel > 0) p.fuel -= CONSTANTS.FUEL_CONSUMPTION;
                                Network.broadcastMove();
                            }
                            this.lastActionTime = now();
                        }
                    }
                }
            }
        }

        // Explosive Logic (Host Only)
        if (this.isAdmin && this.explosives.length > 0) {
            for (let i = this.explosives.length - 1; i >= 0; i--) {
                let e = this.explosives[i];
                e.timer--;
                if (e.timer <= 0) {
                    // BOOM
                    Network.broadcastExplosion(e.x, e.y, e.range);
                    this.explosives.splice(i, 1);
                }
            }
        }

        Sound.updateEngine(isMoving ? speed : 0, p.isDrilling);

        // Remote Interpolation
        Object.values(this.remotePlayers).forEach(rp => {
            if (rp.targetX !== undefined) {
                let rdx = rp.targetX - rp.x; let rdy = rp.targetY - rp.y;
                let rDist = Math.sqrt(rdx*rdx + rdy*rdy);
                let rSpeed = rp.isDrilling ? CONSTANTS.SPEED_DRILL : CONSTANTS.SPEED_NORMAL;
                if (rDist > rSpeed) {
                    let rAngle = Math.atan2(rdy, rdx);
                    rp.x += Math.cos(rAngle) * rSpeed; rp.y += Math.sin(rAngle) * rSpeed;
                } else { rp.x = rp.targetX; rp.y = rp.targetY; }
            }
        });

        // Heat & Prompt
        let depth = Math.max(0, p.gridY - 5);
        let heatThreshold = 100 + (p.heatResist * 50);
        if (depth > heatThreshold) {
            p.temp += 0.05;
            if (p.temp > 100) { p.temp = 100; p.hull -= 0.1; $('heat-overlay').style.opacity = (Math.sin(now()/100)+1)/4 + 0.3; }
        } else { p.temp = Math.max(0, p.temp - 0.2); $('heat-overlay').style.opacity = 0; }

        $('prompt-msg').style.display = 'none';

        // Check Teleporter interaction
        if (this.map[p.gridY][p.gridX] === TILE_TYPES.TELEPORTER) {
             $('prompt-msg').style.display = 'block';
             $('prompt-msg').innerText = "PRESS E TO TELEPORT HOME";
        }

        if (p.gridY === this.stationGridY && Math.abs(p.gridX - this.stationGridX) < 3) {
             $('prompt-msg').style.display = 'block';
             $('prompt-msg').innerText = "PRESS E TO OPEN DASHBOARD/SHOP";
        }

        const interactPressed = Input.keys[this.settings.keys.interact] || Input.virtual.interact;
        if (interactPressed && now() - this.lastActionTime > 500) {
            // Priority: Teleporter -> Station -> Dashboard
            if (this.map[p.gridY][p.gridX] === TILE_TYPES.TELEPORTER) {
                p.gridX = this.stationGridX; p.gridY = this.stationGridY;
                p.x = p.gridX * TS; p.y = p.gridY * TS;
                UI.showToast("Teleported to Surface", "success");
                Sound.playSuccess();
                Network.broadcastMove();
            } else {
                UI.toggleDashboard();
            }
            this.lastActionTime = now();
            Input.virtual.interact = false; // consume
        }

        // Transfer Check
        const transferPressed = Input.keys[this.settings.keys.transfer] || Input.virtual.transfer;
        if (transferPressed && now() - this.lastActionTime > 1000) {
            // Find nearest player
            let nearest = null;
            let minDst = 100; // range
            Object.values(this.remotePlayers).forEach(rp => {
                let d = Math.sqrt((rp.x - p.x)**2 + (rp.y - p.y)**2);
                if(d < minDst) { minDst = d; nearest = rp; }
            });

            if(nearest) {
                this.tryTransferFuel(nearest.id);
            } else {
                UI.showToast("No one nearby to transfer to!", "error");
            }
            this.lastActionTime = now();
            Input.virtual.transfer = false;
        }

        // Mobile Action consumption
        if (Input.virtual.chat && now() - this.lastActionTime > 200) {
            $('chat-input').focus();
            Input.virtual.chat = false;
        }

        p.fuel = clamp(p.fuel, 0, p.maxFuel); p.hull = clamp(p.hull, 0, p.maxHull);
        if (p.hull <= 0) this.respawn();

        this.camera.x += (p.x - this.camera.x) * 0.1;
        this.camera.y += (p.y - this.camera.y) * 0.1;

        if (now() % 5000 < 20) this.saveLocalProgress();
        if (SaveSystem.autosaveEnabled && now() - this.lastAutosave > 60000 && Game.isAdmin && SaveSystem.currentSaveId) {
            SaveSystem.saveGame(SaveSystem.currentSaveId, null, true); this.lastAutosave = now();
        }

        Network.update();
        this.checkHostHealth();

        if (this.lastCoordsX !== p.gridX || this.lastCoordsY !== p.gridY) {
            $('coords-display').innerText = `X: ${p.gridX} Y: ${depth}`;
            this.lastCoordsX = p.gridX; this.lastCoordsY = p.gridY;
        }
    }

    tryTransferFuel(targetId) {
        if (this.localPlayer.fuel > 10) {
            this.localPlayer.fuel -= 10;
            Network.sendFuel(targetId, 10);
            UI.showToast("Sent 10 Fuel!", "success");
            Sound.playSuccess();
        } else {
            UI.showToast("Not enough fuel!", "error");
            Sound.playError();
        }
    }

    tryBuild(tx, ty) {
        if (tx < 0 || tx >= CONSTANTS.MAP_WIDTH || ty < 4 || ty >= CONSTANTS.MAP_HEIGHT) return;
        if (this.map[ty][tx] === TILE_TYPES.EMPTY) {
            const type = this.localPlayer.selectedBlock;
            let count = this.localPlayer.inventory[type] || 0;

            if (count > 0) {
                // If placing a Teleporter, name it!
                if(type === TILE_TYPES.TELEPORTER) {
                    const name = prompt("Name this Teleporter:", `Relay ${tx}-${ty}`);
                    if(!name) return; // Cancel build if canceled

                    this.localPlayer.teleporters.push({
                        x: tx, y: ty, name: name || `Relay ${tx}-${ty}`
                    });
                    this.saveLocalProgress();
                }

                this.localPlayer.inventory[type]--;
                this.localPlayer.cargo--;
                this.map[ty][tx] = type;
                Network.sendTileUpdate(tx, ty, type);
                this.spawnParticle(tx * 32 + 16, ty * 32 + 16, '#95a5a6', 5);
                Sound.playBuild();
                // Host logic: Register explosive timer
                if (this.isAdmin) {
                    if (type === TILE_TYPES.TNT) this.explosives.push({x:tx, y:ty, range:3, timer: 120}); // 2s
                    if (type === TILE_TYPES.NUKE) this.explosives.push({x:tx, y:ty, range:10, timer: 300}); // 5s
                }
                UI.showToast("Block Placed", "success");
                UI.updateDashboard();
            } else {
                UI.showToast("Out of blocks!", "error");
                Sound.playError();
            }
        }
    }

    // --- EXPLOSION ---
    explode(cx, cy, radius) {
        Sound.playExplosion();
        // Shake camera
        const shake = setInterval(() => {
            this.camera.x += (Math.random()-0.5)*10;
            this.camera.y += (Math.random()-0.5)*10;
        }, 20);
        setTimeout(() => clearInterval(shake), 300);

        for (let y = cy - radius; y <= cy + radius; y++) {
            for (let x = cx - radius; x <= cx + radius; x++) {
                if (y > 4 && x >= 0 && x < CONSTANTS.MAP_WIDTH && y < CONSTANTS.MAP_HEIGHT) {
                    if (Math.sqrt((x-cx)**2 + (y-cy)**2) <= radius) {
                        if (this.map[y][x] !== TILE_TYPES.BEDROCK) {
                            this.map[y][x] = TILE_TYPES.EMPTY;
                            this.discovered[y][x] = 1; // Reveal area
                            this.spawnParticle(x*32+16, y*32+16, '#ffaa00', 3);
                        }
                    }
                }
            }
        }

        // Damage players
        const p = this.localPlayer;
        if (Math.abs(p.gridX - cx) < radius && Math.abs(p.gridY - cy) < radius) {
            p.hull -= 50;
            UI.showToast("CAUGHT IN EXPLOSION!", "error");
        }
    }

    trashBlock(type, all=false) {
        const p = this.localPlayer;
        if(p.inventory[type] > 0) {
            let amount = all ? p.inventory[type] : 1;
            p.inventory[type] -= amount;
            p.cargo -= amount;

            if(p.inventory[type] < 0) p.inventory[type] = 0; // sanity
            if(p.cargo < 0) p.cargo = 0;

            const name = TILE_PROPS[type].name;
            UI.showToast(`Trashed ${amount} ${name}`, "normal");
            UI.updateDashboard();
        }
    }

    trashJunk() {
        const p = this.localPlayer;
        let totalTrashed = 0;

        for (let key in p.inventory) {
            let type = parseInt(key);
            let count = p.inventory[type];
            let prop = TILE_PROPS[type];

            // Trash if value is 0, but keep Casings (building blocks)
            if (count > 0 && prop.value === 0 && type !== TILE_TYPES.CASING) {
                p.inventory[type] = 0;
                p.cargo -= count;
                totalTrashed += count;
            }
        }

        if (p.cargo < 0) p.cargo = 0;

        if(totalTrashed > 0) {
            UI.showToast(`Trashed ${totalTrashed} Junk Items`, "success");
            Sound.playChat('death'); // Reuse sound for impact
        } else {
            UI.showToast("No Junk Found", "normal");
        }
        UI.updateDashboard();
    }

    tryMine(tx, ty) {
        let tile = this.map[ty][tx];
        if (tile !== TILE_TYPES.EMPTY && tile !== TILE_TYPES.BEDROCK && this.localPlayer.fuel > 0) {
            let props = TILE_PROPS[tile];
            if (this.localPlayer.drillTier < props.tier) { UI.showToast(`Need Tier ${props.tier} Drill`, "error"); Sound.playError(); return false; }
            if (this.localPlayer.cargo < this.localPlayer.maxCargo) {
                if (!this.localPlayer.inventory[tile]) this.localPlayer.inventory[tile] = 0;
                this.localPlayer.inventory[tile]++;
                this.localPlayer.cargo++;

                if (!this.localPlayer.stats.blocksMined[tile]) this.localPlayer.stats.blocksMined[tile] = 0;
                this.localPlayer.stats.blocksMined[tile]++;
                this.localPlayer.stats.totalMined++;

                this.map[ty][tx] = TILE_TYPES.EMPTY;
                this.discovered[ty][tx] = 1;
                this.spawnParticle(tx * 32 + 16, ty * 32 + 16, props.color, 8);
                Sound.playMining();
                Network.sendTileUpdate(tx, ty, TILE_TYPES.EMPTY);
                UI.updateDashboard();
                return true;
            } else { UI.showToast("Cargo Full!", "error"); Sound.playError(); return false; }
        }
        return false;
    }

    spawnParticle(x, y, color, count) {
        for(let i=0; i<count; i++) {
            this.particles.push({x, y, vx: (Math.random()-0.5)*6, vy: (Math.random()-0.5)*6, life: 1.0, color});
        }
    }

    respawn() {
        this.localPlayer.gridX = Math.floor(CONSTANTS.MAP_WIDTH / 2);
        this.localPlayer.gridY = 4;
        this.localPlayer.x = this.localPlayer.gridX * CONSTANTS.TILE_SIZE;
        this.localPlayer.y = this.localPlayer.gridY * CONSTANTS.TILE_SIZE;
        this.localPlayer.hull = this.localPlayer.maxHull;
        this.localPlayer.fuel = this.localPlayer.maxFuel;
        this.localPlayer.cargo = 0;
        this.localPlayer.inventory = {};
        this.localPlayer.money = Math.floor(this.localPlayer.money * 0.7);
        Network.broadcastDeath();
        Sound.playChat('death');
        $('heat-overlay').style.opacity = 0;
        UI.updateDashboard();
    }

    draw() {
        if (!this.running) return;
        this.ctx.resetTransform();
        this.ctx.fillStyle = '#050505';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        let cx = this.canvas.width / 2;
        let cy = this.canvas.height / 2;
        this.ctx.translate(cx, cy);
        this.ctx.scale(this.zoom, this.zoom);
        this.ctx.translate(-Math.floor(this.camera.x), -Math.floor(this.camera.y));

        const viewW = (this.canvas.width / this.zoom);
        const viewH = (this.canvas.height / this.zoom);
        const startCol = Math.floor((this.camera.x - viewW/2) / CONSTANTS.TILE_SIZE) - 1;
        const endCol = Math.floor((this.camera.x + viewW/2) / CONSTANTS.TILE_SIZE) + 1;
        const startRow = Math.floor((this.camera.y - viewH/2) / CONSTANTS.TILE_SIZE) - 1;
        const endRow = Math.floor((this.camera.y + viewH/2) / CONSTANTS.TILE_SIZE) + 1;

        const pcx = this.localPlayer.gridX;
        const pcy = this.localPlayer.gridY;
        const visionRad = this.localPlayer.xrayRange;

        /// -------------------------------
        // WORLD TIME (host-based)
        // -------------------------------
        const allPlayers = Object.values(this.remotePlayers)
            .concat([this.localPlayer])
            .filter(p => typeof p.joinedAt === "number" && !isNaN(p.joinedAt));
        if (allPlayers.length === 0) {
            // fallback: treat local player as host
            allPlayers.push({ ...this.localPlayer, joinedAt: Date.now() });
        }
        const host = allPlayers.sort((a,b)=>a.joinedAt - b.joinedAt)[0] || this.localPlayer;
        const worldTime = Date.now() - host.joinedAt;

        const dayLength = 20 * 60 * 1000;
        const t = (worldTime % dayLength) / dayLength;

        // Rotate so sunrise = 0.25, noon = 0.5, sunset = 0.75
        const sunAngle = (t * Math.PI * 2) - Math.PI / 2;

        // Smooth daylight curve (no flicker)
        const daylight = (() => {
            const x = (Math.cos(sunAngle) + 1) / 2; // 010
            return x * x * (3 - 2 * x);            // smoothstep
        })();

        // -------------------------------
        // SKY COLOR (above ground level y=5)
        // -------------------------------
        const baseSky = { r: 135, g: 206, b: 235 };
        const groundY = 5 * CONSTANTS.TILE_SIZE;

        const sunrise = Math.max(0, 1 - Math.abs(t - 0.25) * 20);
        const sunset  = Math.max(0, 1 - Math.abs(t - 0.75) * 20);
        const warm = sunrise + sunset;

        const r = Math.round(baseSky.r * (0.3 + daylight*0.7) - warm * 80);
        const g = Math.round(baseSky.g * (0.3 + daylight*0.7) - warm * 40);
        const b = Math.round(baseSky.b * (0.3 + daylight*0.7) - warm * 20);

        this.ctx.fillStyle = `rgb(${r},${g},${b})`;
        this.ctx.fillRect(
            this.camera.x - viewW,
            -2000,
            viewW * 2,
            groundY + 2000
        );

        // Sunrise/sunset gradient
        if (warm > 0) {
            const grad = this.ctx.createLinearGradient(0, -2000, 0, groundY);
            grad.addColorStop(0, `rgba(255,120,50,${warm * 0.6})`);
            grad.addColorStop(1, `rgba(255,180,120,${warm * 0.3})`);
            this.ctx.fillStyle = grad;
            this.ctx.fillRect(
                this.camera.x - viewW,
                -2000,
                viewW * 2,
                groundY + 2000
            );
        }

        // -------------------------------
        // SUN & MOON POSITIONS
        // -------------------------------
        const skyRadius = 900;
        const centerX = this.camera.x;
        // Fix: Pivot exactly at ground level so sunrise/sunset looks correct
        const centerY = groundY;

        const sunX = centerX + Math.cos(sunAngle) * skyRadius;
        const sunY = centerY + Math.sin(sunAngle) * skyRadius;

        const moonX = centerX + Math.cos(sunAngle + Math.PI) * skyRadius;
        const moonY = centerY + Math.sin(sunAngle + Math.PI) * skyRadius;

        // -------------------------------
        // SUN (always drawn)
        // -------------------------------
        {
            const sunSize = 70;
            const grd = this.ctx.createRadialGradient(sunX, sunY, 0, sunX, sunY, sunSize);
            grd.addColorStop(0, "rgba(255,255,200,1)");
            grd.addColorStop(1, "rgba(255,180,0,0.2)");

            this.ctx.fillStyle = grd;
            this.ctx.beginPath();
            this.ctx.arc(sunX, sunY, sunSize, 0, Math.PI*2);
            this.ctx.fill();
        }

        // -------------------------------
        // MOON (one draw call, 3 phases)
        // -------------------------------
        {
            const moonSize = 55;
            const moonCycle = 60 * 60 * 1000;
            const moonPhase = (worldTime % moonCycle) / moonCycle; // 0=new, 0.5=full

            this.ctx.fillStyle = "#e0e0e0";
            this.ctx.beginPath();

            // Outer circle
            this.ctx.arc(moonX, moonY, moonSize, 0, Math.PI * 2);

            // Phase curve (one quadratic curve)
            const curveOffset = (moonPhase - 0.5) * moonSize * 1.6;

            this.ctx.moveTo(moonX - moonSize, moonY);
            this.ctx.quadraticCurveTo(
                moonX + curveOffset,
                moonY,
                moonX - moonSize,
                moonY
            );

            this.ctx.fill();
        }

        // -------------------------------
        // STARS
        // -------------------------------
        if (!this.starField) {
            this.starField = [];
            for (let i = 0; i < 200; i++) {
                this.starField.push({
                    x: Math.random() * 5000 - 2500,
                    y: Math.random() * 2000 - 2000,
                    b: Math.random() * 0.8 + 0.2
                });
            }
        }

        {
            const starAlpha = (0.4 - daylight) / 0.4;
            if (starAlpha > 0) {
                this.ctx.fillStyle = "#fff";
                for (const s of this.starField) {
                    this.ctx.globalAlpha = s.b * starAlpha;
                    this.ctx.fillRect(s.x, s.y, 2, 2);
                }
                this.ctx.globalAlpha = 1;
            }
        }

        // -------------------------------
        // BLACK RECTANGLE (drawn LAST in sky section)
        // -------------------------------
        this.ctx.fillStyle = "#000";
        this.ctx.fillRect(
            this.camera.x - viewW,
            groundY,
            viewW * 2,
            5000
        );

        this.drawStation();

        for (let y = Math.max(0, startRow); y <= Math.min(CONSTANTS.MAP_HEIGHT-1, endRow); y++) {
            for (let x = Math.max(0, startCol); x <= Math.min(CONSTANTS.MAP_WIDTH-1, endCol); x++) {
                let dx = x - pcx; let dy = y - pcy;
                let dist = Math.sqrt(dx*dx + dy*dy);
                let visible = dist <= visionRad;
                if (dist <= this.localPlayer.xrayRange) this.discovered[y][x] = 1;
                let tile = this.map[y][x];

                if (visible) this.drawProceduralTile(x, y, tile, !visible);
                else if (this.discovered[y][x]) {
                    this.ctx.globalAlpha = 0.9;
                    this.drawProceduralTile(x, y, tile, false);
                    this.ctx.globalAlpha = 1.0;
                }
            }
        }

        Object.values(this.remotePlayers).forEach(p => this.drawPlayer(p, false));
        this.drawPlayer(this.localPlayer, true);

        for (let i = this.particles.length - 1; i >= 0; i--) {
            let p = this.particles[i];
            p.x += p.vx; p.y += p.vy; p.life -= 0.05;
            this.ctx.globalAlpha = p.life; this.ctx.fillStyle = p.color;
            this.ctx.fillRect(p.x, p.y, 4, 4); this.ctx.globalAlpha = 1.0;
            if (p.life <= 0) this.particles.splice(i, 1);
        }

        this.drawLocalMinimap();
        this.ctx.resetTransform();
        this.drawHUD();
    }


    drawStation() {
        const ts = CONSTANTS.TILE_SIZE;

        // Station top-left corner in pixels
        const baseX = (this.stationGridX * ts)+ts;
        const baseY = (this.stationGridY * ts)-ts;

        const ctx = this.ctx;

        // -------------------------------
        // BUILDING DIMENSIONS (in tiles)
        // -------------------------------
        const buildingW = 2 * ts;   // 2 tiles wide
        const buildingH = 2 * ts;   // 2 tiles tall

        const roofH = ts * 0.4;     // roof height
        const doorW = ts * 0.5;
        const doorH = ts * 0.9;

        // -------------------------------
        // MAIN BUILDING
        // -------------------------------
        ctx.fillStyle = "#7f8c8d"; // concrete walls
        ctx.fillRect(baseX, baseY, buildingW, buildingH);

        // Wall bevel
        ctx.fillStyle = "rgba(0,0,0,0.25)";
        ctx.fillRect(baseX, baseY + buildingH - 4, buildingW, 4);
        ctx.fillRect(baseX + buildingW - 4, baseY, 4, buildingH);

        ctx.fillStyle = "rgba(255,255,255,0.15)";
        ctx.fillRect(baseX, baseY, buildingW, 3);
        ctx.fillRect(baseX, baseY, 3, buildingH);

        // -------------------------------
        // ROOF (tile-aligned)
        // -------------------------------
        ctx.fillStyle = "#c0392b";
        ctx.fillRect(baseX - ts * 0.25, baseY - roofH, buildingW + ts * 0.5, roofH);

        // Roof trim
        ctx.fillStyle = "#922b21";
        ctx.fillRect(baseX - ts * 0.25, baseY - roofH, buildingW + ts * 0.5, 4);

        // -------------------------------
        // DOOR (centered)
        // -------------------------------
        const doorX = baseX + buildingW / 2 - doorW / 2;
        const doorY = baseY + buildingH - doorH;

        ctx.fillStyle = "#2c3e50";
        ctx.fillRect(doorX, doorY, doorW, doorH);

        // Door handle
        ctx.fillStyle = "#ecf0f1";
        ctx.fillRect(doorX + doorW - 8, doorY + doorH / 2, 6, 2);

        // -------------------------------
        // WINDOWS
        // -------------------------------
        const winW = ts * 0.7;
        const winH = ts * 0.6;

        ctx.fillStyle = "#3498db";

        // Left window
        ctx.fillRect(baseX + ts * 0.2, baseY + ts * 0.3, winW, winH);

        // Right window
        ctx.fillRect(baseX + buildingW - winW - ts * 0.2, baseY + ts * 0.3, winW, winH);

        // Window shine
        ctx.fillStyle = "rgba(255,255,255,0.25)";
        ctx.fillRect(baseX + ts * 0.25, baseY + ts * 0.35, winW * 0.4, winH * 0.2);
        ctx.fillRect(baseX + buildingW - winW - ts * 0.15, baseY + ts * 0.35, winW * 0.4, winH * 0.2);

        // -------------------------------
        // SIGNAGE
        // -------------------------------
        ctx.fillStyle = `hsl(${(Date.now()*0.05)%360}, 100%, 60%)`;
        ctx.font = `${ts * 0.5}px Arial`;
        ctx.textAlign = "center";
        ctx.fillText("SHOP", baseX + buildingW / 2, baseY - roofH * 0.4);

        // -------------------------------
        // GAS PUMPS (tile-aligned, left side)
        // -------------------------------
        const pumpW = ts * 0.5;
        const pumpH = ts * 1.2;

        // Pumps should sit to the LEFT of the building
        const pumpX = baseX - ts*2;   // 1.2 tiles left of building
        const pumpY = baseY + buildingH - pumpH;  // same Y-level for both pumps


        // Pump hoses
        ctx.strokeStyle = "#000";
        ctx.lineWidth = 3;

        ctx.beginPath();
        ctx.moveTo(pumpX + pumpW, pumpY - ts * 0.3 + pumpH * 0.6);
        ctx.lineTo(pumpX + pumpW + ts * 0.3, pumpY - ts * 0.3 + pumpH * 0.8);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(pumpX + pumpW - ts, pumpY - ts * 0.3 + pumpH * 0.6);
        ctx.lineTo(pumpX + pumpW + ts * 0.3 - ts, pumpY - ts * 0.3 + pumpH * 0.8);
        ctx.stroke();

        ctx.fillStyle = "#bdc3c7";

        // Pump 1 (front)
        ctx.fillRect(pumpX, pumpY, pumpW, pumpH);

        // Pump 2 (behind it, slightly offset upward)
        ctx.fillRect(pumpX - ts, pumpY, pumpW, pumpH);

        // Pump screens
        ctx.fillStyle = "#2c3e50";
        ctx.fillRect(pumpX + pumpW * 0.2, pumpY + ts * 0.2, pumpW * 0.6, pumpH * 0.3);
        ctx.fillRect(pumpX + pumpW * 0.2 - ts, pumpY + ts * 0.2, pumpW * 0.6, pumpH * 0.3);
    }


    drawProceduralTile(x, y, type) {
        let ts = CONSTANTS.TILE_SIZE;
        let px = x * ts; let py = y * ts;
        let prop = TILE_PROPS[type];

        // Detailed Texture Patterns

        const n1 = (pseudoRandom(x, y) % 1);
        const n2 = ((pseudoRandom(x, y) * 10) % 1);

        let bevel = true;
        let isOre = false;

        // --- ORE RENDERING (Detailed) ---
        if (type >= TILE_TYPES.COAL && type <= TILE_TYPES.RUBY) {
        isOre=true
            // Stone background
            this.ctx.fillStyle = TILE_PROPS[TILE_TYPES.STONE].color;
            this.ctx.fillRect(px, py, ts, ts);


            // Ore color
            this.ctx.fillStyle = prop.color;

            // Use your seeded RNG
            const r0 = pseudoRandom(x, y);
            const r1 = pseudoRandom(x + 17, y + 3);
            const r2 = pseudoRandom(x - 9, y + 11);
            const r3 = pseudoRandom(x + 4, y - 6);

            // Cluster center
            const cx = px + 8 + r0 * 16;
            const cy = py + 8 + r1 * 16;

            // Main chunk
            this.ctx.fillRect(cx - 3, cy - 3, 6, 6);

            // Satellite specks
            const specks = [
                { dx: (r1 - 0.5) * 12, dy: (r2 - 0.5) * 12, s: 3 },
                { dx: (r2 - 0.5) * 14, dy: (r3 - 0.5) * 14, s: 4 },
                { dx: (r3 - 0.5) * 16, dy: (r0 - 0.5) * 16, s: 3 }
            ];

            for (const sp of specks) {
                this.ctx.fillRect(cx + sp.dx, cy + sp.dy, sp.s, sp.s);
            }

            if ((now() + Math.floor(pseudoRandom(x, y) * 2000)) % 2000 < 200) {
                this.ctx.fillStyle = 'rgba(255,255,255,0.9)';
                this.ctx.fillRect(cx - 1, cy - 1, 2, 2);
            }
        }

        if(!isOre){
            // --- STANDARD BLOCKS ---
            this.ctx.fillStyle = prop.color;
            this.ctx.fillRect(px, py, ts, ts);

            if (type === TILE_TYPES.EMPTY && y>=5) {
                this.ctx.fillStyle = 'rgba(50, 25, 15, 1)';
                this.ctx.fillRect(px, py, ts, ts);

                // Add some small pebbles/debris
                this.ctx.fillStyle = 'rgba(120, 90, 70, 0.4)';
                if(n1 > 0.7) this.ctx.fillRect(px + 8, py + 8, 3, 3);
                if(n2 > 0.6) this.ctx.fillRect(px + 20, py + 12, 2, 2);
                if(n1 < 0.3) this.ctx.fillRect(px + 15, py + 20, 4, 2);
                bevel=false;
            }
            else if (type === TILE_TYPES.EMPTY && y<5) {
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0)';
                return
            }
            else if (type === TILE_TYPES.DIRT) {
                this.ctx.fillStyle = 'rgba(0,0,0,0.15)';
                if(n1 > 0.5) this.ctx.fillRect(px+4, py+4, 4, 4);
                if(n2 < 0.5) this.ctx.fillRect(px+20, py+20, 5, 5);
                if(n1 < 0.2) this.ctx.fillRect(px+12, py+10, 3, 3);
            } else if (type === TILE_TYPES.GRASS) {
                this.ctx.fillStyle = '#2ecc71'; this.ctx.fillRect(px, py, ts, 6);
                this.ctx.fillStyle = 'rgba(0,0,0,0.1)'; this.ctx.fillRect(px, py+6, ts, ts-6);
            } else if (type === TILE_TYPES.STONE || type === TILE_TYPES.HARD_STONE) {
                const r0 = pseudoRandom(x, y);
                const r1 = pseudoRandom(x + 17, y + 3);
                const r2 = pseudoRandom(x - 9, y + 11);
                const r3 = pseudoRandom(x + 4, y - 6);
                this.ctx.fillStyle = 'rgba(0,0,0,0.2)';
                if(n1 > 0.3) { this.ctx.fillRect(px+(r0*5), py+(r2*5), 10, 6); this.ctx.fillRect(px+(r1*18), py+(r3*18), 10, 6); }
                this.ctx.strokeStyle = 'rgba(0,0,0,0.1)';
                this.ctx.beginPath(); this.ctx.moveTo(px+(ts*r2), py+(ts*r1)); this.ctx.lineTo(px+(ts*r3), py+(ts*r0)); this.ctx.stroke();
            } else if (type === TILE_TYPES.CASING) {
                this.ctx.strokeStyle = '#555'; this.ctx.lineWidth = 4;
                this.ctx.strokeRect(px+2, py+2, ts-4, ts-4);
                this.ctx.beginPath(); this.ctx.moveTo(px, py); this.ctx.lineTo(px+ts, py+ts); this.ctx.moveTo(px+ts, py); this.ctx.lineTo(px, py+ts); this.ctx.stroke();
                return;
            }else if(type === TILE_TYPES.TNT) {
                this.ctx.fillStyle = "#c0392b"; this.ctx.fillRect(px,py,ts,ts);
                this.ctx.fillStyle = "white"; this.ctx.font="10px Arial"; this.ctx.textAlign="center"; this.ctx.fillText("TNT", px+16, py+20);
                return;
            }else if(type === TILE_TYPES.NUKE) {
                this.ctx.fillStyle = "#2c3e50"; this.ctx.fillRect(px,py,ts,ts);
                this.ctx.fillStyle = "#f1c40f"; this.ctx.beginPath(); this.ctx.arc(px+16,py+16,8,0,Math.PI*2); this.ctx.fill();
                return;
            }else if(type === TILE_TYPES.TELEPORTER) {
                this.ctx.fillStyle = "#8e44ad"; this.ctx.fillRect(px,py,ts,ts);
                this.ctx.strokeStyle = "#fff"; this.ctx.lineWidth=2; this.ctx.beginPath(); this.ctx.arc(px+16,py+16,10,0,Math.PI*2); this.ctx.stroke();
                return;
            }
        }

        // Bevel for all
        if(bevel){
          this.ctx.fillStyle = 'rgba(0,0,0,0.2)'; this.ctx.fillRect(px, py+ts-2, ts, 2); this.ctx.fillRect(px+ts-2, py, 2, ts);
          this.ctx.fillStyle = 'rgba(255,255,255,0.1)'; this.ctx.fillRect(px, py, ts, 2); this.ctx.fillRect(px, py, 2, ts);
        }
    }

    drawPlayer(p, isLocal) {
        let size = CONSTANTS.TILE_SIZE;
        let cx = p.x + size/2; let cy = p.y + size/2;
        this.ctx.save(); this.ctx.translate(cx, cy); this.ctx.rotate(p.rotation || 0);
        let color = isLocal ? this.settings.color : (p.color || '#fff');

        this.ctx.fillStyle = color; this.ctx.fillRect(-12, -12, 24, 24);
        this.ctx.strokeStyle = '#111'; this.ctx.lineWidth = 2; this.ctx.strokeRect(-12, -12, 24, 24);
        this.ctx.fillStyle = '#bdc3c7';
        let drillOffset = (p.isDrilling && now() % 200 > 100) ? 2 : 0;
        this.ctx.beginPath(); this.ctx.moveTo(-6, 12); this.ctx.lineTo(0, 20 + drillOffset); this.ctx.lineTo(6, 12); this.ctx.fill();
        this.ctx.fillStyle = '#2c3e50'; this.ctx.fillRect(-16, -10, 4, 20); this.ctx.fillRect(12, -10, 4, 20);
        this.ctx.fillStyle = '#3498db'; this.ctx.fillRect(-6, -6, 12, 8);
        if (!isLocal) {
            this.ctx.rotate(-p.rotation); this.ctx.fillStyle = '#fff'; this.ctx.font = '10px Arial'; this.ctx.textAlign = 'center';
            this.ctx.shadowColor="black"; this.ctx.shadowBlur=2;
            this.ctx.fillText(p.username || "Unknown", 0, -20);
            this.ctx.shadowBlur=0;
        }
        this.ctx.restore();
    }

    drawLocalMinimap() {
        const ctx = this.minimapCtx;
        const width = 150;
        const height = 150;
        ctx.fillStyle = '#000'; ctx.fillRect(0, 0, width, height);

        // Fixed Minimap Settings (Independent of Zoom)
        const range = 25; // 25 tile radius = 50 tile diameter view
        const pixelSize = width / (range * 2); // 150 / 50 = 3px per tile exact
        const center = width / 2;

        const pX = this.localPlayer.gridX;
        const pY = this.localPlayer.gridY;

        for (let dy = -range; dy < range; dy++) {
            for (let dx = -range; dx < range; dx++) {
                let mx = pX + dx;
                let my = pY + dy;
                // Boundary checks
                if (mx >= 0 && mx < CONSTANTS.MAP_WIDTH && my >= 0 && my < CONSTANTS.MAP_HEIGHT) {
                    if (this.discovered[my][mx]) {
                        let tile = this.map[my][mx];
                        ctx.fillStyle = tile === TILE_TYPES.EMPTY ? '#111' : TILE_PROPS[tile].color;
                        // Use 3x3 pixel rects
                        ctx.fillRect(Math.floor(center + dx * pixelSize), Math.floor(center + dy * pixelSize), pixelSize, pixelSize);
                    }
                }
            }
        }

        // Viewport Border calculation needs to map GAME View to MINIMAP Coordinates
        // Game View Width (in tiles) = CanvasWidth / (TileSize * Zoom)
        ctx.strokeStyle = "rgba(255,255,255,0.5)";
        ctx.lineWidth = 1;

        const gameViewTilesW = this.canvas.width / (CONSTANTS.TILE_SIZE * this.zoom);
        const gameViewTilesH = this.canvas.height / (CONSTANTS.TILE_SIZE * this.zoom);

        // Convert tiles to pixels on the minimap
        const miniMapRectW = gameViewTilesW * pixelSize;
        const miniMapRectH = gameViewTilesH * pixelSize;

        ctx.strokeRect(center - miniMapRectW/2, center - miniMapRectH/2, miniMapRectW, miniMapRectH);

        // Player Dot (Always Center)
        ctx.fillStyle = Game.settings.color;
        ctx.fillRect(center, center, 3, 3);

        // Remote players... mapped to minimap scale
        Object.values(this.remotePlayers).forEach(rp => {
            let dx = rp.gridX - pX;
            let dy = rp.gridY - pY;

            // Only draw if within minimap range
            if(Math.abs(dx) < range && Math.abs(dy) < range) {
                const screenX = center + dx * pixelSize;
                const screenY = center + dy * pixelSize;
                ctx.fillStyle = rp.color;
                ctx.fillRect(screenX, screenY, 3, 3);
            }
        });
    }

    drawHUD() {
        const p = this.localPlayer;
        const w = this.canvas.width;
        const h = this.canvas.height;

        // Adjust gauge scale and position for mobile
        const gaugeR = this.isMobile ? 30 : 40;
        const fontSize = this.isMobile ? "10px" : "12px";
        const yPos = h - (gaugeR * 1.5); // Sits just above bottom of canvas
        const xStep = this.isMobile ? (w / 4) : 100; // Spread evenly or fixed

        if (this.isMobile) {
            // Even spread across top of controls
            this.drawGauge(w*0.15, yPos, gaugeR, p.fuel, p.maxFuel, "FUEL", "#d35400");
            this.drawGauge(w*0.38, yPos, gaugeR, p.hull, p.maxHull, "HULL", "#c0392b");
            this.drawGauge(w*0.62, yPos, gaugeR, p.cargo, p.maxCargo, "CARGO", "#27ae60");
            this.drawGauge(w*0.85, yPos, gaugeR, p.temp, 100, "TEMP", "#e74c3c");

            // Money top center
            this.ctx.fillStyle = "#f1c40f"; this.ctx.font = "bold 16px monospace"; this.ctx.textAlign = "center";
            this.ctx.fillText("$ " + Math.floor(p.money), w/2, 30);
        } else {
            // Desktop layout (bottom corners)
            this.drawGauge(60, h - 60, 40, p.fuel, p.maxFuel, "FUEL", "#d35400");
            this.drawGauge(160, h - 60, 40, p.hull, p.maxHull, "HULL", "#c0392b");
            this.drawGauge(w - 60, h - 60, 40, p.cargo, p.maxCargo, "CARGO", "#27ae60");
            this.drawGauge(w - 160, h - 60, 40, p.temp, 100, "TEMP", "#e74c3c");

            this.ctx.fillStyle = "#f1c40f"; this.ctx.font = "bold 20px monospace"; this.ctx.textAlign = "center";
            this.ctx.fillText("$ " + Math.floor(p.money), w/2, h - 30);
        }
    }

    drawGauge(x, y, r, val, max, label, color) { /* Same as before */
        const ctx = this.ctx;
        ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.fillStyle = "rgba(0,0,0,0.7)"; ctx.fill();
        ctx.lineWidth = 3; ctx.strokeStyle = "#444"; ctx.stroke();
        const start = Math.PI * 0.7; const end = Math.PI * 2.3;
        const pct = clamp(val / max, 0, 1);
        const current = start + (end - start) * pct;
        ctx.beginPath(); ctx.arc(x, y, r - 5, start, current); ctx.strokeStyle = color; ctx.lineWidth = 6; ctx.stroke();
        ctx.fillStyle = "#fff"; ctx.font = "bold 10px Arial"; ctx.textAlign = "center";
        ctx.fillText(label, x, y + 15); ctx.fillText(Math.floor(val), x, y - 5);
    }

    loop() {
        this.update();
        this.draw();
        requestAnimationFrame(() => this.loop());
    }
}

// --- HELPER FOR COLORS ---
const Qt = { lighter: (hex, factor) => hex };

// --- SHOP SYSTEM ---
class ShopSystem {
    constructor() {
        this.prices = {
            drill: [500, 2000, 10000, 50000],
            hull: 200, fuel: 200, cargo: 100, cool: 1000, xray: 2000,
            repair_kit: 50, fuel_voucher: 50, tnt: 200, nuke: 5000, teleporter: 1000
        };
    }
    open() { $('shop-modal').classList.add('active'); this.updateUI(); }
    close() { $('shop-modal').classList.remove('active'); }

    sellAll() {
        let total = 0;
        const p = Game.localPlayer;
        for (let type in p.inventory) {
            let count = p.inventory[type];
            if (count > 0 && TILE_PROPS[type].value > 0) {
                total += count * TILE_PROPS[type].value;
                p.inventory[type] = 0;
            }
        }
        if (total > 0) {
            p.money += total;
            p.cargo = 0;
            for(let t in p.inventory) p.cargo += p.inventory[t];
            UI.showToast(`Sold all for $${total}`, "success");
            Sound.playSuccess();
            Game.saveLocalProgress(); // Save on transaction
        } else {
            UI.showToast("Nothing valuable to sell.", "normal");
        }
        this.updateUI();
        UI.updateDashboard();
    }

    sellItem(type, amount) {
        const p = Game.localPlayer;
        if(p.inventory[type] >= amount) {
            let val = TILE_PROPS[type].value * amount;
            p.inventory[type] -= amount;
            p.cargo -= amount;
            p.money += val;
            UI.showToast(`Sold ${amount} ${TILE_PROPS[type].name}`, "success");
            Sound.playSuccess();
            Game.saveLocalProgress(); // Save on transaction
            this.updateUI();
            UI.updateDashboard();
        }
    }

    refuelRepair() {
        const p = Game.localPlayer;
        if(p.money >= 10) {
            p.money -= 10;
            p.fuel = p.maxFuel;
            p.hull = p.maxHull;
            UI.showToast("Refueled & Repaired!", "success");
            Sound.playSuccess();
            Game.saveLocalProgress(); // Save on transaction
            this.updateUI();
        } else {
            UI.showToast("Not enough money!", "error");
            Sound.playError();
        }
    }

    updateUI() {
        const p = Game.localPlayer;
        $('shop-money').innerText = "$" + Math.floor(p.money);
        $('shop-color-picker').value = Game.settings.color;

        const sellContainer = $('sell-list');
        sellContainer.innerHTML = '';
        let hasItems = false;

        Object.keys(p.inventory).forEach(key => {
            let type = parseInt(key);
            let count = p.inventory[type];
            let val = TILE_PROPS[type].value;

            if (count > 0 && val > 0) {
                hasItems = true;
                let div = document.createElement('div');
                div.className = 'sell-row';
                div.innerHTML = `
                    <span style="color:${TILE_PROPS[type].color}">${TILE_PROPS[type].name} (x${count})</span>
                    <span style="color:gold">$${val}/ea</span>
                    <div class="sell-actions">
                        <button class="btn" onclick="Shop.sellItem(${type}, 1)">Sell 1</button>
                        <button class="btn" onclick="Shop.sellItem(${type}, ${count})">All</button>
                    </div>
                `;
                sellContainer.appendChild(div);
            }
        });

        if(!hasItems) sellContainer.innerHTML = '<div style="padding:10px; color:#555; text-align:center;">No valuable ore to sell.</div>';

        const check = (type, level) => {
            let cost = this.prices[type];
            if(Array.isArray(cost)) cost = cost[level] || 999999;
            else cost = Math.floor(cost * (1 + level));
            $(`cost-${type}`).innerText = "$" + cost;
            $(`btn-${type}`).disabled = p.money < cost;
            if(Array.isArray(this.prices[type]) && !this.prices[type][level]) {
                 $(`cost-${type}`).innerText = "MAX";
                 $(`btn-${type}`).disabled = true;
            }
        };
        check('drill', p.drillTier);
        check('hull', (p.maxHull-100)/20);
        check('fuel', (p.maxFuel-100)/20);
        check('cargo', (p.maxCargo-50)/10);
        check('cool', p.heatResist);
        check('xray', p.xrayRange);
    }

    buy(item) {
        const p = Game.localPlayer;
        let cost = 0;
        let success = false;

        // Item specific logic
        if (item === 'repair_kit' || item === 'fuel_voucher') {
            cost = this.prices[item];
            if (p.money >= cost) {
                p.money -= cost;
                let type = (item === 'repair_kit') ? TILE_TYPES.REPAIR_KIT : TILE_TYPES.FUEL_VOUCHER;
                p.inventory[type] = (p.inventory[type] || 0) + 1;
                UI.showToast(`Bought ${item.replace('_', ' ')}`, "success");
                success = true;
            }
        } else if (item === 'tnt' || item === 'nuke' || item === 'teleporter') {
            cost = this.prices[item];
            if (p.money >= cost) {
                p.money -= cost;
                let type = (item === 'tnt') ? TILE_TYPES.TNT : (item === 'nuke' ? TILE_TYPES.NUKE : TILE_TYPES.TELEPORTER);
                // Explosives count towards cargo weight? Yes.
                p.cargo++;
                p.inventory[type] = (p.inventory[type] || 0) + 1;
                UI.showToast(`Bought ${item.toUpperCase()}`, "success");
                success = true;
            }
        } else {
             // Standard upgrades...
             this.buyUpgrade(item);
             return;
        }

        if(success) {
            Game.saveLocalProgress();
            this.updateUI();
            UI.updateDashboard();
        } else {
             if (item !== 'drill' && item !== 'hull') UI.showToast("Not enough money!", "error");
        }
    }

    buyUpgrade(item) {
        const p = Game.localPlayer;
        let cost = 0;
        let success = false;
        if (item === 'paint') { if (p.money >= 100) { p.money -= 100; Game.settings.color = $('shop-color-picker').value; UI.showToast("Repainted!", "success"); success=true; } }
        else if (item === 'drill') { cost = this.prices.drill[p.drillTier]; if (p.money >= cost) { p.money -= cost; p.drillTier++; UI.showToast("Drill Upgraded!", "success"); Sound.playSuccess(); success=true; } }
        else {
            let level = 0;
            if (item === 'hull') level = (p.maxHull-100)/20;
            if (item === 'fuel') level = (p.maxFuel-100)/20;
            if (item === 'cargo') level = (p.maxCargo-50)/10;
            if (item === 'cool') level = p.heatResist;
            if (item === 'xray') level = p.xrayRange;
            cost = Math.floor(this.prices[item] * (1 + level));
            if (p.money >= cost) {
                p.money -= cost;
                if (item === 'hull') { p.maxHull += 20; p.hull = p.maxHull; }
                if (item === 'fuel') { p.maxFuel += 20; p.fuel = p.maxFuel; }
                if (item === 'cargo') p.maxCargo += 20;
                if (item === 'cool') p.heatResist++;
                if (item === 'xray') p.xrayRange++;
                UI.showToast(`You bought ${item} for \$${cost}!`, "success");
                Sound.playSuccess();
                success = true;
            }
        }
        if(success) Game.saveLocalProgress(); // Save on buy
        this.updateUI();
    }
}

// --- NETWORK (MQTT) ---
class NetworkManager {
    constructor() {
        this.client = null;
        this.baseTopic = 'mm_online/';
        this.lastHeartbeat = 0;
        this.lastSyncToast = 0;
    }

    connect() {
        Game.logConnection(`Connecting to broker ${Game.settings.broker}...`);

        const broker = Game.settings.broker;
        const options = { clientId: 'mm_' + Game.localPlayer.id, keepalive: 60, clean: true, reconnectPeriod: 1000 };
        try { this.client = mqtt.connect(broker, options); } catch (e) { Game.logConnection("Error creating client: " + e); }

        this.client.on('connect', () => {
            Game.logConnection("Connected. Subscribing...");
            this.client.subscribe(`${this.baseTopic}${Game.settings.room}/#`, (err) => {
                if(!err) {
                    Game.logConnection("Subscribed. Joining room...");
                    this.publish('ctrl', { type: 'join', id: Game.localPlayer.id, username: Game.settings.username, color: Game.settings.color, joinedAt: Game.localPlayer.joinedAt, /*ver: BUILD_TIMESTAMP*/ });
                    Game.finishConnection();
                    Sound.playSuccess();
                    // BROADCAST MOVE immediately so everyone sees new player
                    this.broadcastMove();
                } else {
                    Game.logConnection("Sub Error: " + err);
                }
            });
        });

        this.client.on('offline', () => { $('disconnect-msg').style.display = 'block'; });
        this.client.on('reconnect', () => { $('disconnect-msg').style.display = 'none'; });
        this.client.on('message', (topic, message) => this.handleMessage(topic, message));
    }

    update() {
        let n = now();
        Object.keys(Game.remotePlayers).forEach(id => {
            if (n - Game.remotePlayers[id].lastSeen > 10000) {
            const msg = UI.formatMsg(Game.remotePlayers[id].username, 'leave');
            UI.addMessage("System", msg, "#888");
            Sound.playChat('leave');
            delete Game.remotePlayers[id];
            UI.updatePlayerList();
            // Removed updateAdminStatus, checking health in Game loop
        }
    });
    if (n - this.lastHeartbeat > 1000) {
        this.publish('pos', { type: 'heartbeat', id: Game.localPlayer.id, username: Game.settings.username, joinedAt: Game.localPlayer.joinedAt });

        // --- NEW: Admin Heartbeat ---
        if (Game.isAdmin) {
             this.publish('ctrl', { type: 'host_heartbeat', id: Game.localPlayer.id });
        }

        this.lastHeartbeat = n;
    }
}

broadcastHostClaim() {
    this.publish('ctrl', { type: 'claim_host', id: Game.localPlayer.id });
}

broadcastPromote(targetId) {
    this.publish('ctrl', { type: 'promote_host', target: targetId, from: Game.localPlayer.id });
    Game.isAdmin = false;
    Game.hostId = targetId;
    Game.lastHostHeartbeat = Date.now(); // Trust the new guy
    UI.showToast("Admin Transferred", "normal");
    UI.updateAdminPanel();
}

broadcastMove() {
        const p = Game.localPlayer;
        // FIX: Added joinedAt to move packets so late joiners see my timestamp
        this.publish('pos', {
            type: 'move', id: p.id,
            sx: p.x, sy: p.y, tx: p.gridX * CONSTANTS.TILE_SIZE, ty: p.gridY * CONSTANTS.TILE_SIZE,
            gx: p.gridX, gy: p.gridY, r: p.rotation, col: Game.settings.color, drill: p.isDrilling,
            username: Game.settings.username,
            joinedAt: p.joinedAt,
            isAdmin: Game.isAdmin // FLAG ADMIN STATUS
        });
        this.lastHeartbeat = now();
    }

    broadcastDeath() { this.publish('chat', { type: 'death', id: Game.localPlayer.id, name: Game.settings.username }); }
    sendFuel(targetId, amount) { this.publish('ctrl', { type: 'fuel', to: targetId, from: Game.settings.username, amt: amount }); }
    sendTileUpdate(x, y, type) { this.publish('map', { type: 'tile', x, y, val: type, id: Game.localPlayer.id }); }
    sendChat(msg) { this.publish('chat', { type: 'chat', id: Game.localPlayer.id, name: Game.settings.username, msg }); }
    kickUser(id) { this.publish('ctrl', { type: 'kick', target: id }); }
    transferAdmin(id) { this.publish('ctrl', { type: 'transfer_admin', to: id }); }

    // Add missing Map Request logic
    requestMap(fromId) {
        UI.showToast("Requesting Map...", "normal");
        this.publish('ctrl', { type: 'map_req', from: Game.localPlayer.id, to: fromId || null });
    }

    sendMapDiff(toId) {
        // Optimization: Use Arrays [x,y,v] instead of Objects {x,y,v} to reduce JSON size by ~40%
        let diffs = [];
        for (let y = 0; y < CONSTANTS.MAP_HEIGHT; y++) {
            for (let x = 0; x < CONSTANTS.MAP_WIDTH; x++) {
                let base = Game.getProceduralTile(x, y);
                // Note: Game.map is the truth. If it differs from procedural base, send it.
                if (Game.map[y][x] !== base) {
                    diffs.push([x, y, Game.map[y][x]]);
                }
            }
        }

        console.log(`Sending Map Diff: ${diffs.length} tiles to ${toId}`);

        // Protocol: Start -> Chunks -> End
        this.publish('map', { type: 'map_start', to: toId, count: diffs.length });

        if(diffs.length > 0) {
            // FIX: Throttled sending to prevent network flood
            // Lowered chunk size and increased delay for stability
            const CHUNK_SIZE = 32;
            let i = 0;

            const sendLoop = setInterval(() => {
                if (i >= diffs.length) {
                    clearInterval(sendLoop);
                    this.publish('map', { type: 'map_end', to: toId });
                    return;
                }
                const chunk = diffs.slice(i, i+CHUNK_SIZE);
                this.publish('map', { type: 'sync', data: chunk, to: toId });
                i += CHUNK_SIZE;
            }, 30); // 30ms delay
        } else {
             // Small delay to ensure order in some brokers even if empty
             setTimeout(() => {
                 this.publish('map', { type: 'map_end', to: toId });
             }, 100);
        }
    }

    publish(sub, payload) { if (this.client && this.client.connected) this.client.publish(`${this.baseTopic}${Game.settings.room}/${sub}`, JSON.stringify(payload)); }

    handleMessage(topic, message) {
        let msg;
        try { msg = JSON.parse(message.toString()); } catch(e) { return; }
        if (msg.id === Game.localPlayer.id && msg.type !== 'kick') return;

        if (msg.type === 'move' || msg.type === 'heartbeat') {
            if (!Game.remotePlayers[msg.id]) {
                Game.remotePlayers[msg.id] = {
                    id: msg.id, x: msg.sx || 0, y: msg.sy || 0, targetX: msg.tx, targetY: msg.ty,
                    username: msg.username || "Unknown", color: msg.col || '#fff', lastSeen: now(),
                    joinedAt: msg.joinedAt // FIX: Capture timestamp on first sight
                };
            }
            let rp = Game.remotePlayers[msg.id];
            rp.lastSeen = now();
            if(msg.username && rp.username === "Unknown") rp.username = msg.username;

            // FIX: Ensure timestamp is synced if it comes in late, but sanity check it
            // Must be a valid timestamp > year 2021 to prevent "0" exploits
            if (msg.joinedAt && (!rp.joinedAt || rp.joinedAt > msg.joinedAt)) {
                if (msg.joinedAt > 1769977740008) {
                    rp.joinedAt = msg.joinedAt;
                }
            }

            // HOST ID / ADMIN STATUS TRACKING
            if (msg.isAdmin) {
                Game.hostId = msg.id;

                // CONFLICT RESOLUTION: If I think I'm admin, but I see another admin...
                if (Game.isAdmin && msg.id !== Game.localPlayer.id) {
                    // Respect the elder (First Joiner Rule)
                    if (msg.joinedAt < Game.localPlayer.joinedAt) {
                        console.log("Admin Conflict: Demoting self in favor of older host.");
                        Game.demoteFromAdmin();
                    }
                }
            }

            if (msg.type === 'move') {
                rp.color = msg.col; rp.rotation = msg.r; rp.isDrilling = msg.drill; rp.gridX = msg.gx; rp.gridY = msg.gy;
                rp.targetX = msg.tx; rp.targetY = msg.ty;
                if (Math.abs(rp.x - rp.targetX) > 100 || Math.abs(rp.y - rp.targetY) > 100) { rp.x = rp.targetX; rp.y = rp.targetY; }
        }
        // Removed updateAdminStatus
    }
    else if (msg.type === 'join') {
        if (Game.bannedIds.includes(msg.id) && Game.isAdmin) this.kickUser(msg.id);
        else {
            if(!Game.remotePlayers[msg.id]) {
                UI.addMessage("System", UI.formatMsg(msg.username, 'join'), "#aaa");
                Sound.playChat('join');
            }
            Game.remotePlayers[msg.id] = {
                id: msg.id, username: msg.username, color: msg.color, x: 0, y: 0, targetX: 0, targetY: 0, joinedAt: msg.joinedAt, lastSeen: now()
            };
            UI.updatePlayerList();
            // Removed updateAdminStatus

            if(Game.isAdmin) {
                this.sendMapDiff(msg.id);
                // Also assert dominance immediately so they know I'm host
                this.publish('ctrl', { type: 'host_heartbeat', id: Game.localPlayer.id });
            }
            this.broadcastMove();
        }
    }
    // --- NEW: Admin Messages ---
    else if (msg.type === 'host_heartbeat') {
        Game.hostId = msg.id;
        Game.lastHostHeartbeat = now();

        // Glitch prevention: If I thought *I* was admin, but someone else is pulsing...
        if (Game.isAdmin && msg.id !== Game.localPlayer.id) {
            // Tie breaker: Who claimed it first? Or just yield.
            // Simple yield:
            console.warn("Host conflict detected. Yielding to " + msg.id);
            Game.isAdmin = false;
            UI.updateAdminPanel();
        }
    }
    else if (msg.type === 'claim_host') {
        Game.hostId = msg.id;
        Game.lastHostHeartbeat = now();
        if (msg.id !== Game.localPlayer.id) {
            Game.isAdmin = false;
            UI.updateAdminPanel();
            UI.showToast("New Host Claimed: " + (Game.remotePlayers[msg.id]?.username || "Unknown"), "normal");
        }
    }
    else if (msg.type === 'promote_host') {
        if (msg.target === Game.localPlayer.id) {
            Game.isAdmin = true;
            Game.hostId = Game.localPlayer.id;
            Game.lastHostHeartbeat = now();
            UI.showToast("You have been Promoted to Admin!", "success");
            Sound.playSuccess();
            UI.updateAdminPanel();
            this.broadcastHostClaim();
        } else {
             // Handle case where someone else was promoted
             Game.hostId = msg.target;
             Game.lastHostHeartbeat = now();
             Game.isAdmin = false;
             UI.updateAdminPanel();
        }
    }
    else if (msg.type === 'tile') {
             if (Game.map[msg.y]) { Game.map[msg.y][msg.x] = msg.val; Game.discovered[msg.y][msg.x] = 1; }
        }
        else if (msg.type === 'map_start' && msg.to === Game.localPlayer.id) {
             const count = msg.count || "Unknown";
             UI.showToast(`Receiving Map Data (${count} tiles)...`, "normal");
        }
        else if (msg.type === 'sync' && msg.to === Game.localPlayer.id) {
            // Apply Map Sync
            if (Array.isArray(msg.data)) {
                msg.data.forEach(d => {
                    // Optimized: d is now [x, y, v]
                    // We handle both object (legacy) and array (new) just in case
                    let x, y, v;
                    if (Array.isArray(d)) { [x, y, v] = d; }
                    else { x = d.x; y = d.y; v = d.v; }

                    if (Game.map[y] !== undefined && Game.map[y][x] !== undefined) {
                        Game.map[y][x] = v;
                        // Auto discover synced changes so we can see them on minimap
                        Game.discovered[y][x] = 1;
                    }
                });
            }
        }
        else if (msg.type === 'map_end' && msg.to === Game.localPlayer.id) {
             UI.showToast("Map Synced!", "success");
        }
        else if (msg.type === 'map_req' && Game.isAdmin) {
            this.sendMapDiff(msg.from);
        }
        else if (msg.type === 'chat') { UI.addMessage(msg.name, msg.msg); Sound.playChat('msg'); }
        else if (msg.type === 'death') { UI.addMessage("System", UI.formatMsg(msg.name, 'death'), "#f55"); Sound.playChat('death'); }
        else if (msg.type === 'kick') {
            if (msg.target === Game.localPlayer.id) { alert(UI.formatMsg('You', 'kick')); location.reload(); }
            else {
                if(Game.remotePlayers[msg.target]) UI.addMessage("System", UI.formatMsg(Game.remotePlayers[msg.target].username, 'kick'), "red");
                delete Game.remotePlayers[msg.target];
            }
        }
        else if (msg.type === 'fuel' && msg.to === Game.localPlayer.id) {
            Game.localPlayer.fuel = Math.min(Game.localPlayer.maxFuel, Game.localPlayer.fuel + msg.amt);
            UI.showToast(`Received ${msg.amt} Fuel from ${msg.from}`, "success");
            Sound.playSuccess();
            if (Game.localPlayer.fuel < 20) UI.addMessage("System", UI.formatMsg(Game.settings.username, 'rescue'), "orange");
        }
        else if (msg.type === 'ctrl' && msg.type === 'transfer_admin' && msg.to === Game.localPlayer.id) {
            Game.promoteToAdmin();
        }
        else if (msg.type === 'explode') {
            Game.explode(msg.x, msg.y, msg.r)
        }
    }
}

// --- INPUT ---

class InputManager {
    constructor() {
        this.keys = {};
        this.virtual = { up: false, down: false, left: false, right: false, build: false, interact: false, chat: false, transfer: false };
        this.bindMode = null;
    }

    init() {
        window.addEventListener('keydown', e => {
            Sound.init();

            // --- FIX: Ignore game inputs while typing in chat ---
            if (document.activeElement === $('chat-input')) {
                if (e.key === 'Escape') $('chat-input').blur(); // Allow ESC to exit chat
                return; // Stop processing game keys
            }

            if (this.bindMode) {
                Game.settings.keys[this.bindMode] = e.key;
                localStorage.setItem('mm_keybinds', JSON.stringify(Game.settings.keys));
                UI.showToast(`Bound ${this.bindMode.toUpperCase()} to ${e.key}`, "success");
                this.bindMode = null;
                UI.refreshKeybindLabels();
                return;
            }
            this.keys[e.key] = true;
            if (e.key === Game.settings.keys.chat && document.activeElement !== $('chat-input')) {
                e.preventDefault();
                $('chat-input').focus();
            }
            if (Object.values(Game.settings.keys).includes(e.key) && e.key !== Game.settings.keys.chat) e.preventDefault();
        });
        window.addEventListener('keyup', e => this.keys[e.key] = false);

        // --- CHAT FIX: Handle Enter key on the input itself ---
        $('chat-input').addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.stopPropagation(); // Prevent game from re-focusing or doing other keybinds
                const msg = e.target.value.trim();
                if (msg.length > 0) {
                    Network.sendChat(msg);
                    e.target.value = '';
                    e.target.blur(); // Close keyboard / unfocus
                }
            }
        });

        // Touch / Mouse Events for Virtual Controls
        const bindTouch = (elem, key) => {
            const start = (e) => { e.preventDefault(); this.virtual[key] = true; elem.style.opacity = '0.5'; };
            const end = (e) => { e.preventDefault(); this.virtual[key] = false; elem.style.opacity = '1'; };
            elem.addEventListener('mousedown', start); elem.addEventListener('mouseup', end); elem.addEventListener('mouseleave', end);
            elem.addEventListener('touchstart', start); elem.addEventListener('touchend', end);
        };

        document.querySelectorAll('.d-btn, .act-btn').forEach(btn => {
            bindTouch(btn, btn.getAttribute('data-key'));
        });
    }

    handleCommand(cmd) {
        let parts = cmd.split(' ');
        if (parts[0] === '/tp' && Game.isAdmin) {
            if (parts.length === 3) {
                let x = parseInt(parts[1]); let y = parseInt(parts[2]);
                if (!isNaN(x) && !isNaN(y)) {
                    Game.localPlayer.gridX = x; Game.localPlayer.gridY = y;
                    Game.localPlayer.x = x * CONSTANTS.TILE_SIZE; Game.localPlayer.y = y * CONSTANTS.TILE_SIZE;
                    UI.showToast(`Teleported to ${x}, ${y}`, "success");
                    Network.broadcastMove();
                }
            } else if (parts.length === 2) {
                let target = Object.values(Game.remotePlayers).find(p => p.username === parts[1]);
                if (target) {
                    Game.localPlayer.gridX = target.gridX; Game.localPlayer.gridY = target.gridY;
                    Game.localPlayer.x = target.x; Game.localPlayer.y = target.y;
                    UI.showToast(`Teleported to ${target.username}`, "success");
                    Network.broadcastMove();
                } else UI.showToast("Player not found", "error");
            }
        }
        else if (parts[0] === '/op' && Game.isAdmin) {
            if (parts.length === 2) {
                let target = Object.values(Game.remotePlayers).find(p => p.username === parts[1]);
                if (target) {
                     Network.transferAdmin(target.id);
                     Game.demoteFromAdmin();
                     UI.showToast(`Transferred Admin to ${target.username}`, "success");
                } else {
                    UI.showToast("Player not found (case sensitive)", "error");
                }
            } else {
                UI.showToast("Usage: /op [Username]", "normal");
            }
        }
        else {
            UI.showToast("Unknown command or not admin", "error");
        }
    }

    startBind(action) { this.bindMode = action; UI.refreshKeybindLabels(); }
}

// --- UI & SAVES ---

class UIManager {
    constructor() {
        this.defaultServers = [
            "wss://broker.emqx.io:8084/mqtt",
            "wss://broker.hivemq.com:8884/mqtt",
            "wss://test.mosquitto.org:8081"
        ];
        this.customServers = JSON.parse(localStorage.getItem('mm_custom_servers') || '[]');

        // Init server list on load
        setTimeout(() => this.refreshServerList(), 500);
    }

    rndMsg(type) { const arr = MSGS[type]; return arr[Math.floor(Math.random() * arr.length)]; }

    formatMsg(username, type) {
        let msg = this.rndMsg(type);
        if (msg.includes('<user>')) {
            return msg.replace(/<user>/g, username);
        }
        return `${username} ${msg}`;
    }

    addMessage(name, text, color='#fff') {
        const div = document.createElement('div');
        div.innerHTML = `<span style="color:${color}; font-weight:bold;">${name}:</span> ${text}`;
        $('chat-messages').appendChild(div);
        $('chat-messages').scrollTop = $('chat-messages').scrollHeight;
    }
    showToast(msg, type='normal',timeout=4000) {
        const area = $('notification-area');
        const el = document.createElement('div');
        el.className = `toast ${type}`;
        el.innerText = msg;
        area.appendChild(el);
        setTimeout(() => el.remove(), timeout);
    }
    openSettings() {
        $('settings-modal').classList.add('active');
        this.refreshKeybindLabels();
        SaveSystem.renderSaveList();
    }
    closeSettings() { $('settings-modal').classList.remove('active'); }
    refreshKeybindLabels() {
        const keys = Game.settings.keys;
        const map = { up: 'btn-bind-up', down: 'btn-bind-down', left: 'btn-bind-left', right: 'btn-bind-right', build: 'btn-bind-build', interact: 'btn-bind-interact', transfer: 'btn-bind-transfer', chat: 'btn-bind-chat' };
        for (let action in map) {
            let btn = $(map[action]);
            if (Input.bindMode === action) { btn.classList.add('binding'); btn.innerText = `PRESS KEY...`; }
            else { btn.classList.remove('binding'); btn.innerText = `${action.toUpperCase()}: ${keys[action]}`; }
        }
    }

    async randomizeName() {
        try {
            const btn = document.querySelector('button[title="Randomize"]');
            const originalText = btn.innerHTML;
            btn.innerHTML = '...';
            btn.disabled = true;

            const res = await fetch('https://randomuser.me/api?inc=login');
            const data = await res.json();
            const name = data.results[0].login.username;
            $('start-username').value = name;

            btn.innerHTML = originalText;
            btn.disabled = false;
        } catch(e) {
            console.error(e);
            UI.showToast("Failed to fetch name", "error");
            document.querySelector('button[title="Randomize"]').disabled = false;
        }
    }

    // --- SERVER LIST LOGIC ---
    refreshServerList() {
        const list = $('server-list-sidebar');
        list.innerHTML = '';

        // Render helper
        const renderItem = (url, isCustom) => {
            const isActive = url === Game.settings.broker;
            const item = document.createElement('div');
            item.className = `server-list-item ${isActive ? 'active' : ''}`;

            let buttonsHtml = '';
            if(isCustom) {
                buttonsHtml = `
                   <div class="server-actions">
                       <button class="btn btn-small" style="padding:2px 5px; background:#444; font-size:10px; margin:0;" onclick="event.stopPropagation(); UI.editCustomServer('${url}')" title="Edit">&#9998;</button>
                       <button class="btn btn-small" style="padding:2px 5px; background:#c0392b; font-size:10px; margin:0;" onclick="event.stopPropagation(); UI.removeCustomServer('${url}')" title="Remove">&times;</button>
                   </div>
                `;
            }

            item.innerHTML = `
                <div style="display:flex; align-items:center; overflow:hidden; flex:1;">
                    <div class="server-status-icon" id="status-${btoa(url).replace(/=/g,'')}"><div class="spin-loader"></div></div>
                    <span style="white-space:nowrap; overflow:hidden; text-overflow:ellipsis; margin-right:5px;" title="${url}">${url}</span>
                </div>
                ${buttonsHtml}
            `;
            item.onclick = () => this.selectServer(url);
            list.appendChild(item);
            this.checkServerStatus(url);
        };

        // Render Defaults
        this.defaultServers.forEach(url => renderItem(url, false));

        // Render Custom
        this.customServers.forEach(url => {
            if(!this.defaultServers.includes(url)) renderItem(url, true);
        });
    }

    removeCustomServer(url) {
        if(!confirm(`Remove custom server?\n${url}`)) return;
        this.customServers = this.customServers.filter(s => s !== url);
        localStorage.setItem('mm_custom_servers', JSON.stringify(this.customServers));

        // If the removed server was the active one, switch to default
        if(Game.settings.broker === url) {
            this.selectServer(this.defaultServers[0]);
        } else {
            this.refreshServerList();
        }
        this.showToast("Server Removed", "normal");
    }

    editCustomServer(oldUrl) {
        const newUrl = prompt("Edit Server URL:", oldUrl);
        if(newUrl && newUrl !== oldUrl) {
            if(newUrl.startsWith('ws://') || newUrl.startsWith('wss://')) {
                const idx = this.customServers.indexOf(oldUrl);
                if(idx !== -1) {
                    this.customServers[idx] = newUrl;
                    localStorage.setItem('mm_custom_servers', JSON.stringify(this.customServers));

                    if(Game.settings.broker === oldUrl) {
                        this.selectServer(newUrl); // Update active selection
                    } else {
                        this.refreshServerList();
                    }
                    this.showToast("Server Updated", "success");
                }
            } else {
                this.showToast("Invalid URL (Must start with ws:// or wss://)", "error");
            }
        }
    }

    selectServer(url) {
        Game.settings.broker = url;
        localStorage.setItem('mm_broker_url', url);
        $('setting-broker').value = url;
        this.refreshServerList(); // Redraw to update active class
        this.showToast("Server Selected. Launch to Connect.", "normal");
    }

    addCustomServer() {
        const input = $('custom-server-input');
        const url = input.value.trim();
        if(url && (url.startsWith('ws://') || url.startsWith('wss://'))) {
            if(!this.customServers.includes(url) && !this.defaultServers.includes(url)) {
                this.customServers.push(url);
                localStorage.setItem('mm_custom_servers', JSON.stringify(this.customServers));
                input.value = '';
                this.refreshServerList();
                this.showToast("Server Added", "success");
                this.selectServer(url);
            } else {
                this.showToast("Server already exists", "error");
            }
        } else {
            this.showToast("Invalid URL (Must start with ws:// or wss://)", "error");
        }
    }

    removeCustomServer(url) {
        const index = this.customServers.indexOf(url);
        if (index > -1) {
            if (confirm(`Remove custom server: ${url}?`)) {
                this.customServers.splice(index, 1);
                localStorage.setItem('mm_custom_servers', JSON.stringify(this.customServers));

                // If the deleted server was active, switch to default
                if (Game.settings.broker === url) {
                    Game.settings.broker = this.defaultServers[0];
                    localStorage.setItem('mm_broker_url', Game.settings.broker);
                    $('setting-broker').value = Game.settings.broker;
                }

                this.refreshServerList();
                this.showToast("Server Removed", "normal");
            }
        }
    }

    checkServerStatus(url) {
        const id = `status-${btoa(url).replace(/=/g,'')}`;
        const el = $(id);
        if(!el) return;


        const client = mqtt.connect(url, { connectTimeout: 9500, reconnectPeriod: 0 });

        let failedTimeout = setTimeout(() => { if(!client.connected) setStatus(false); }, 10000);

        const setStatus = (success) => {
            if(el) {
                el.innerHTML = success
                    ? `<span style="color:#2ecc71; font-weight:bold;">&#10003;</span>`
                    : `<span style="color:#e74c3c; font-weight:bold;">&#10007;</span>`;
            }
            client.end();
        };

        client.on('connect', () => {setStatus(true);clearTimeout(failedTimeout);});
        client.on('error', () => setStatus(false));
        client.on('close', () => {clearTimeout(failedTimeout);}); // silent

    }

    checkServers() {
        // Legacy settings modal check
        this.refreshServerList();
    }

    async checkForUpdates() {
        try {
            if (location.protocol!=='file:'){
                if (!initialTimestamp) {
                    const url = new URL(window.location.href);
                    url.searchParams.set('_t', Date.now());
                    const headRes = await fetch(url.toString(), { method: 'HEAD' });
                    initialTimestamp = headRes.headers.get('last-modified');
                    console.log("current version is :", initialTimestamp);
                }else{
                    const url = new URL(window.location.href);
                    url.searchParams.set('_t', Date.now());
                    const headRes = await fetch(url.toString(), { method: 'HEAD' });
                    const currentTimestamp = headRes.headers.get('last-modified');

                    if (currentTimestamp && currentTimestamp !== initialTimestamp) {
                        UI.showToast("New Version Available!", "normal");
                        UI.addMessage("System", `Update detected! (${currentTimestamp}) Please save and refresh.`, "#0f0", 9999999);
                    }
                }
            } else {
                UI.showToast("Can't check updates on file:// URLs", "normal");
            }
        } catch (e) { console.error('Update check error:', e); }
    }

    toggleDashboard() {
        const dash = $('dashboard-modal');
        if (dash.classList.contains('active')) {
            dash.classList.remove('active');
        } else {
            dash.classList.add('active');
            this.updateDashboard();
        }
    }

    // Use Consumable Logic
    useItem(type) {
        const p = Game.localPlayer;
        if ((p.inventory[type] || 0) > 0) {
            p.inventory[type]--;
            if (type === TILE_TYPES.REPAIR_KIT) {
                p.hull = Math.min(p.maxHull, p.hull + 50);
                this.showToast("Used Repair Kit (+50 HP)", "success");
            } else if (type === TILE_TYPES.FUEL_VOUCHER) {
                p.fuel = Math.min(p.maxFuel, p.fuel + 50);
                this.showToast("Used Fuel Voucher (+50 Fuel)", "success");
            }
            this.updateDashboard();
        }
    }

    updateDashboard() {
        const p = Game.localPlayer;
        const grid = $('inv-grid');
        grid.innerHTML = '';

        let types = Object.keys(p.inventory).map(Number);
        if(!types.includes(TILE_TYPES.CASING)) types.push(TILE_TYPES.CASING);

        types.forEach(type => {
            let count = p.inventory[type] || 0;
            if (count > 0 || type === TILE_TYPES.CASING) {
                let div = document.createElement('div');
                div.className = `inv-item ${p.selectedBlock == type ? 'active' : ''}`;
                div.style.color = TILE_PROPS[type].color || '#fff';

                let html = `${TILE_PROPS[type].name}<span class="inv-count">${count}</span>`;
                html += `<div class="inv-trash" onclick="event.stopPropagation(); Game.trashBlock(${type}, event.shiftKey)">x</div>`;

                // Add USE button for consumables
                if (TILE_PROPS[type].consumable) {
                    html += `<button class="inv-use-btn" onclick="event.stopPropagation(); UI.useItem(${type})">USE</button>`;
                }

                div.innerHTML = html;

                // Only equip non-consumables
                if (!TILE_PROPS[type].consumable) {
                    div.onclick = () => { p.selectedBlock = parseInt(type); UI.updateDashboard(); };
                }
                grid.appendChild(div);
            }
        });

        // Stats update
        $('stats-container').innerHTML = `
            <div class="stat-row"><span>Mined:</span><span>${p.stats.totalMined}</span></div>
            <div class="stat-row"><span>Depth:</span><span>${Math.floor(Math.max(0, p.gridY-5))}m</span></div>
        `;
        // Leaderboard
        let players = Object.values(Game.remotePlayers).concat(p);
        players.sort((a,b)=>(b.gridY||0)-(a.gridY||0));
        $('leaderboard-container').innerHTML = players.map((pl, i)=>`<div class="stat-row"><span>${i+1}.${pl.username}</span><span>${pl.gridY||0}m</span></div>`).join('');
        $('station-btn-container').style.display = (p.gridY === Game.stationGridY && Math.abs(p.gridX - Game.stationGridX) < 3) ? 'block' : 'none';
    }

    updatePlayerList() {
        if (!Game.isAdmin) {
            $('admin-panel').style.display = 'none';
            return;
        }
        $('admin-panel').style.display = 'block';
        const list = $('player-list');
        list.innerHTML = '';
        Object.values(Game.remotePlayers).forEach(p => {
            const row = document.createElement('div');
            row.className = 'player-row';
            // Added Promote Button (P)
            row.innerHTML = `
                <span>${p.username}</span>
                <div style="display:flex; gap:2px;">
                    <button class="btn btn-small" style="background:#2980b9; padding:0 4px; width:20px;" title="Promote to Admin" onclick="Admin.promote('${p.id}')">P</button>
                    <button class="btn btn-small btn-danger" style="padding:0 4px; width:20px;" title="Kick" onclick="Admin.kick('${p.id}')">K</button>
                </div>`;
            list.appendChild(row);
        });
    }
    updateAdminPanel() { this.updatePlayerList(); }
}

class AdminSystem {
    kick(id) { Network.kickUser(id); delete Game.remotePlayers[id]; UI.updatePlayerList(); }
    promote(id) {
        if(confirm("Pass Admin privileges to this user? You will lose Admin status.")) {
            Network.broadcastPromote(id);
        }
    }
}

class SaveSystem {
    static autosaveEnabled = true;
    static currentSaveId = null;
    static db = null;
    static dbPromise = null;

    static async initDB() {
        if (!this.dbPromise) {
            this.dbPromise = new Promise((resolve, reject) => {
                const request = indexedDB.open("MegaMinerDB", 2); // Version bumped to 2
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    // Full map data store
                    if (!db.objectStoreNames.contains("saves")) {
                        db.createObjectStore("saves", { keyPath: "id" });
                    }
                    // Metadata store for fast listing
                    if (!db.objectStoreNames.contains("save_meta")) {
                        db.createObjectStore("save_meta", { keyPath: "id" });
                    }
                };
                request.onsuccess = (event) => {
                    resolve(event.target.result);
                };
                request.onerror = (event) => {
                    console.error("IndexedDB initialization failed", event);
                    reject(event);
                };
            });
        }
        this.db = await this.dbPromise;
    }

    static init() {
        const as = localStorage.getItem('mm_autosave_setting');
        if(as !== null) this.autosaveEnabled = (as === 'true');
        $('autosave-toggle').checked = this.autosaveEnabled;
    }

    static toggleAutosave(val) {
        this.autosaveEnabled = val;
        localStorage.setItem('mm_autosave_setting', val);
    }

    // --- CORE SAVE LOGIC ---

    static async createNewSave() {
        // PROTECTION: Only Admin can create/save games
        if (Network.client && Network.client.connected && !Game.isAdmin) {
            UI.showToast("Only Admin can create saves.", "error");
            return;
        }

        const name = prompt("Enter Save Name:", "New World " + new Date().toLocaleTimeString());
        if(!name) return;

        const id = Date.now();
        this.currentSaveId = id;
        await this.saveGame(id, name);
        this.renderSaveList();
        UI.showToast("Created New Save", "success");
    }

    static async saveCurrent() {
        // PROTECTION: Only Admin can save
        if (Network.client && Network.client.connected && !Game.isAdmin) {
            UI.showToast("Only Admin can save.", "error");
            return;
        }

        if(this.currentSaveId) {
            await this.saveGame(this.currentSaveId);
        } else {
            this.createNewSave();
        }
    }

    static async saveGame(id, name = null, isAuto = false) {
        // PROTECTION: Redundant check for internal calls
        if (Network.client && Network.client.connected && !Game.isAdmin) {
            return;
        }

        try {
            await this.initDB();

            // If name is null, try to fetch existing name or default
            let finalName = name;
            if(!finalName) {
                const existing = await this.getMeta(id);
                finalName = existing ? existing.name : `Save ${id}`;
            }

            const cleanPlayer = JSON.parse(JSON.stringify(Game.localPlayer));
            const cleanMap = JSON.parse(JSON.stringify(Game.map));
            const cleanDiscovered = Game.discovered.map(r => Array.from(r));

            const fullData = {
                id: id,
                player: cleanPlayer,
                map: cleanMap,
                discovered: cleanDiscovered,
                banned: Game.bannedIds,
                timestamp: Date.now()
            };

            const metaData = {
                id: id,
                name: finalName,
                timestamp: Date.now()
            };

            await new Promise((resolve, reject) => {
                const tx = this.db.transaction(["saves", "save_meta"], "readwrite");

                // Save heavy data
                tx.objectStore("saves").put(fullData);
                // Save meta data
                tx.objectStore("save_meta").put(metaData);

                tx.oncomplete = () => resolve();
                tx.onerror = (e) => reject(e);
            });

            // Remember this as the last used save
            localStorage.setItem('mm_last_save_id', id);

            if (!isAuto) {
                UI.showToast(`Saved "${finalName}"`, "success");
                this.renderSaveList();
            }

        } catch (e) {
            console.error("Error saving game", e);
            if (!isAuto) UI.showToast("Save Failed", "error");
        }
    }

    static async getMeta(id) {
        await this.initDB();
        return new Promise(resolve => {
            const req = this.db.transaction("save_meta", "readonly").objectStore("save_meta").get(id);
            req.onsuccess = () => resolve(req.result);
            req.onerror = () => resolve(null);
        });
    }

    static async loadGame(id, silent = false) {
        // PROTECTION: Only Admin can load saves
        if (Network.client && Network.client.connected && !Game.isAdmin) {
            if(!silent) UI.showToast("Only Admin (Host) can load saves.", "error");
            return;
        }

        await this.initDB();

        try {
            const data = await new Promise((resolve, reject) => {
                const tx = this.db.transaction(["saves"], "readonly");
                const store = tx.objectStore("saves");
                const req = store.get(id);

                req.onsuccess = () => resolve(req.result);
                req.onerror = (e) => reject(e);
            });

            if (!data) {
                if(!silent) UI.showToast("Corrupt or missing save data.", "error");
                return;
            }

            this.currentSaveId = id; // Set ID so autosave works correctly
            this.restoreData(data);
            if(!silent) UI.closeSettings();

        } catch (e) {
            if(!silent) UI.showToast("Failed to load save", "error");
            console.error(e);
        }
    }

    static async deleteGame(id) {
        if(!confirm("Delete this save forever?")) return;
        await this.initDB();
        try {
            const tx = this.db.transaction(["saves", "save_meta"], "readwrite");
            tx.objectStore("saves").delete(id);
            tx.objectStore("save_meta").delete(id);
            tx.oncomplete = () => {
                UI.showToast("Save Deleted", "normal");
                this.renderSaveList();
                if(this.currentSaveId === id) this.currentSaveId = null;
            };
        } catch (e) {
            console.error(e);
        }
    }

    // --- RENDER LIST ---
    static async renderSaveList() {
        await this.initDB();
        const container = $('save-list-wrapper');
        container.innerHTML = 'Loading saves...';

        // Get all meta
        const metas = await new Promise(resolve => {
             const req = this.db.transaction("save_meta", "readonly").objectStore("save_meta").getAll();
             req.onsuccess = () => resolve(req.result);
             req.onerror = () => resolve([]);
        });

        container.innerHTML = '';
        if(metas.length === 0) {
            container.innerHTML = '<div style="padding:10px; color:#555;">No saves found.</div>';
            return;
        }

        // Sort by newest
        metas.sort((a,b) => b.timestamp - a.timestamp);

        metas.forEach(meta => {
            const div = document.createElement('div');
            const isActive = meta.id === this.currentSaveId;
            div.className = `save-slot ${isActive ? 'active' : ''}`;
            const dateStr = new Date(meta.timestamp).toLocaleString();

            div.innerHTML = `
                <div class="save-slot-info">
                    <strong>${meta.name}</strong> ${isActive ? '<span style="color:var(--success)">(Current)</span>' : ''}<br>
                    <span style="font-size:10px; color:#999">${dateStr}</span>
                </div>
                <div class="save-slot-actions">
                    <button class="btn" style="background:#555;" onclick="SaveSystem.loadGame(${meta.id})">Load</button>
                    <button class="btn btn-danger" onclick="SaveSystem.deleteGame(${meta.id})">X</button>
                    <button class="btn" style="background:#444;" onclick="SaveSystem.exportGame(${meta.id})">Export</button>
                </div>
            `;
            container.appendChild(div);
        });
    }

    static async exportGame(id) {
         await this.initDB();
         const req = this.db.transaction("saves", "readonly").objectStore("saves").get(id);
         req.onsuccess = () => {
             const data = req.result;
             if(data) {
                const blob = new Blob([JSON.stringify(data)], { type: "application/json" });
                const a = document.createElement("a");
                a.href = URL.createObjectURL(blob);
                a.download = `mm_save_${id}.json`;
                a.click();
             }
         }
    }

    static importSave(input) {
        // PROTECTION: Only Admin can import saves
        if (Network.client && Network.client.connected && !Game.isAdmin) {
             UI.showToast("Only Admin (Host) can import saves.", "error");
             input.value = '';
             return;
        }

        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const data = JSON.parse(e.target.result);
                this.restoreData(data);
                // Create a new entry for this imported save
                this.currentSaveId = Date.now();
                this.saveGame(this.currentSaveId, "Imported " + new Date().toLocaleTimeString());
            } catch(e) { UI.showToast("Invalid File", "error"); }
        };
        if(input.files[0]) reader.readAsText(input.files[0]);
    }

    static restoreData(data) {
        // Stop the loop briefly? No, just atomic update.
        // Deep merge player stats
        if(data.player) {
            // Keep current Network Identity intact so we don't disconnect or ghost
            const currentId = Game.localPlayer.id;
            const currentJoinedAt = Game.localPlayer.joinedAt;

            Game.localPlayer = { ...Game.localPlayer, ...data.player };

            // Restore identity
            Game.localPlayer.id = currentId;
            Game.localPlayer.joinedAt = currentJoinedAt;

            // Ensure visual position matches grid
            Game.localPlayer.x = Game.localPlayer.gridX * CONSTANTS.TILE_SIZE;
            Game.localPlayer.y = Game.localPlayer.gridY * CONSTANTS.TILE_SIZE;
        }

        // Validate and Adapt map data
        if(data.map && Array.isArray(data.map) && data.map.length > 0) {
            // Exact match
            if (data.map.length === CONSTANTS.MAP_HEIGHT && data.map[0] && data.map[0].length === CONSTANTS.MAP_WIDTH) {
                Game.map = data.map;
            }
            // Dimension mismatch - Adapt (Trim or Extend)
            else {
                console.warn("Save map dimensions mismatch. Adapting...");
                UI.showToast("Map size changed. Adapting save data...", "normal");

                // Overlay saved map onto generated map
                // Note: Game.map is already populated with procedural terrain from init()
                for (let y = 0; y < CONSTANTS.MAP_HEIGHT; y++) {
                    if (y < data.map.length) {
                        const savedRow = data.map[y];
                        // Safety check for row existence
                        if (!savedRow) continue;

                        if (savedRow.length === CONSTANTS.MAP_WIDTH) {
                            Game.map[y] = savedRow;
                        } else {
                            // Width mismatch: copy what fits
                            const len = Math.min(savedRow.length, CONSTANTS.MAP_WIDTH);
                            for (let x = 0; x < len; x++) {
                                Game.map[y][x] = savedRow[x];
                            }
                        }
                    }
                }
            }
        } else {
            console.warn("Save data map invalid or empty. Keeping generated map.");
            if(data.map) UI.showToast("Map data corrupt. Generated new map. (This is normal for new worlds)", "error");
        }

        if(data.discovered && Array.isArray(data.discovered)) {
            // Adapt discovered array logic similarly
             for (let y = 0; y < CONSTANTS.MAP_HEIGHT; y++) {
                if (y < data.discovered.length) {
                    let savedRow = data.discovered[y];
                    if (!savedRow) continue;

                    // Convert from object (JSON serialization of TypedArray) if needed
                    if (!(savedRow instanceof Uint8Array)) savedRow = new Uint8Array(Object.values(savedRow));

                    if (savedRow.length === CONSTANTS.MAP_WIDTH) {
                        Game.discovered[y] = savedRow;
                    } else {
                        const len = Math.min(savedRow.length, CONSTANTS.MAP_WIDTH);
                        for (let x = 0; x < len; x++) {
                             Game.discovered[y][x] = savedRow[x];
                        }
                    }
                }
            }
        }

        if(data.banned) Game.bannedIds = data.banned;

        // Force refresh UI
        UI.showToast("Game Loaded!", "success");
        UI.updateDashboard();

        // Ensure map is redrawn correctly by resetting camera target slightly
        Game.camera.x = Game.localPlayer.x;
        Game.camera.y = Game.localPlayer.y;
    }
}

function generateCreditsHTML(data) {
    let html = "";

    for (const category in data) {
        html += `<div class="credits-section">`;
        html += `<h3>${category.replace(/([A-Z])/g, " $1").toUpperCase()}</h3>`;

        const section = data[category];

        // Simple string list (e.g., specialThanks)
        if (Array.isArray(section) && typeof section[0] === "string") {
            html += `<div class="credit-entry">`;
            html += `<ul class="simple-list">`;
            section.forEach(item => html += `<li>${item}</li>`);
            html += `</ul>`;
            html += `</div>`;
            continue;
        }

        // Object list (music, sfx, pictures, etc.)
        section.forEach(entry => {
            const key = Object.keys(entry)[0];
            const name = entry[key];
            const items = entry.items || entry.songs || [];

            html += `<div class="credit-entry">`;
            html += `<strong>${name}</strong>`;
            if (items.length > 0) {
                html += `<ul>`;
                items.forEach(i => html += `<li>${i}</li>`);
                html += `</ul>`;
            }
            html += `</div>`;
        });

        html += `</div>`;
    }

    return html;
}

// --- INSTANTIATION ---
const Game = new GameEngine();
const Input = new InputManager();
const Network = new NetworkManager();
const UI = new UIManager();
const Admin = new AdminSystem();
const Shop = new ShopSystem();

// Init Save System
SaveSystem.init();

// Expose
window.Game = Game;
window.UI = UI;
window.SaveSystem = SaveSystem;
window.Admin = Admin;
window.Shop = Shop;
window.Input = Input;
window.Sound = Sound;
//patrickdearteaga.com,
const creditsData = {
    music: [
        {
            artist: "Patrick de Arteaga",
            songs: ["Chiptronical","Great Little Challenge", "Solve The Puzzle"]
        },
        {
            artist: "Kevin Macleod",
            songs: ["Sneaky Snitch"]
        },
        {
            artist: "VibeHorn (Pixabay)",
            songs: ["Cozy Lofi Relax"]
        },
        {
            artist: "DELOSound (Pixabay)",
            songs: ["LoFi Background Music 3"]
        },
        {
            artist: "CFL_TurningPages (Pixabay)",
            songs: ["Field Duel lofi"]
        }
    ],

    specialThanks: [
        "My friends",
        "Playtesters",
        "Contributors",
        "The laptops that were sacrificed in the making of this game"
    ]
};
// JANK AUDIO FIX
Sound.loadSettings()
// bruh
document.getElementById('credits').innerHTML = generateCreditsHTML(creditsData);
</script>
</body>
</html>


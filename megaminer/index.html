<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mega Miner Online - MQTT Multiplayer</title>
    <!-- MQTT.js Library -->
    <script src="https://unpkg.com/mqtt/dist/mqtt.min.js"></script>
    <style>
        /* CSS Reset & Normalization */
        * { box-sizing: border-box; margin: 0; padding: 0; outline: none; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; }

        :root {
            --bg-color: #0d0d0d;
            --panel-bg: rgba(20, 25, 40, 0.95);
            --text-color: #eee;
            --accent: #2980b9;
            --highlight: #f39c12;
            --danger: #c0392b;
            --success: #27ae60;
            
        }
        body { overflow: hidden; font-family: 'Segoe UI', Roboto, Helvetica, Arial, monospace; color: var(--text-color); user-select: none; }
        
        canvas { display: block; width: 100vw; height: 100vh; }
        
        /* UI Overlay */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        .pointer-events-auto { pointer-events: auto; }
        
        /* Gear Icon */
        #gear-btn { position: absolute; top: 10px; left: 10px; font-size: 30px; color: rgba(255,255,255,0.5); cursor: pointer; pointer-events: auto; z-index: 50; transition: all 0.3s; }
        #gear-btn:hover { color: #fff; transform: rotate(90deg); }

        /* Coords Display */
        #coords-display { position: absolute; top: 10px; left: 60px; font-size: 14px; color: #aaa; font-family: monospace; display: none; text-shadow: 1px 1px 0 #000; }

        /* Overheat Overlay */
        #heat-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; box-shadow: inset 0 0 0px var(--danger); transition: box-shadow 0.2s; opacity: 0; }

        /* Connection Screens */
        #connection-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #050505; z-index: 300; display: none; flex-direction: column; align-items: center; justify-content: center; pointer-events: auto; }
        #connection-log { font-family: monospace; color: var(--success); margin-top: 20px; font-size: 14px; text-align: left; width: 300px; height: 100px; overflow-y: auto; border: 1px solid #333; padding: 10px; background: #000; }
        .log-line { margin: 2px 0; }
        .spinner { width: 40px; height: 40px; border: 4px solid #333; border-top: 4px solid var(--highlight); border-radius: 50%; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* Connection Lost Overlay */
        #disconnect-msg { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: var(--danger); font-size: 32px; font-weight: bold; background: rgba(0,0,0,0.8); padding: 20px; border: 2px solid var(--danger); display: none; z-index: 200; text-align: center; }

        /* Chat */
        #chat-container { position: absolute; bottom: 120px; left: 10px; width: 300px; height: 150px; display: flex; flex-direction: column; pointer-events: auto; opacity: 0.8; transition: opacity 0.3s; z-index: 10; }
        #chat-container:hover { opacity: 1; }
        #chat-messages { flex: 1; overflow-y: auto; background: rgba(0,0,0,0.6); padding: 5px; font-size: 12px; scrollbar-width: thin; text-shadow: 1px 1px 0 #000; border: 1px solid #444; }
        #chat-input { background: rgba(0,0,0,0.8); border: 1px solid #444; color: white; padding: 5px; width: 100%; box-sizing: border-box; }

        /* Minimap */
        #minimap-container { position: absolute; top: 10px; right: 10px; width: 150px; height: 150px; border: 2px solid #555; background: #000; z-index: 20; overflow: hidden; }
        #minimap { display: block; width: 100%; height: 100%; }

        /* Interaction Prompts */
        #prompt-msg { position: absolute; top: 100px; left: 50%; transform: translateX(-50%); color: var(--highlight); font-size: 20px; font-weight: bold; text-shadow: 0 2px 4px #000; display: none; pointer-events: none; text-align: center; }

        /* Modals */
        .modal { display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: var(--panel-bg); padding: 20px; border: 2px solid var(--accent); border-radius: 8px; width: 600px; max-height: 85vh; overflow-y: auto; pointer-events: auto; z-index: 100; box-shadow: 0 0 30px rgba(0,0,0,0.9); }
        .modal.active { display: block; }
        .modal h2 { margin-top: 0; color: var(--highlight); border-bottom: 1px solid #444; padding-bottom: 10px; text-transform: uppercase; letter-spacing: 1px; }
        
        .form-group { margin-bottom: 15px; }
        .form-group label { display: block; margin-bottom: 5px; font-size: 13px; color: #aaa; text-transform: uppercase; }
        .form-group input[type="text"], .form-group select { width: 100%; padding: 8px; background: #222; border: 1px solid #444; color: white; box-sizing: border-box; }
        .form-group input:disabled { opacity: 0.5; cursor: not-allowed; }
        input[type=range] { width: 100%; accent-color: var(--accent); }

        /* Shop Grid */
        .shop-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
        .shop-item { background: rgba(0,0,0,0.3); padding: 10px; border: 1px solid #444; display: flex; flex-direction: column; justify-content: space-between; }
        .shop-item h4 { margin: 0 0 5px 0; color: var(--accent); }
        .shop-item p { font-size: 12px; color: #ccc; margin: 0 0 5px 0; }
        .shop-item .cost { color: var(--highlight); font-weight: bold; font-size: 14px; }
        
        /* Sell List */
        .sell-list { max-height: 150px; overflow-y: auto; margin-bottom: 20px; border: 1px solid #444; background: #111; }
        .sell-row { display: flex; justify-content: space-between; align-items: center; padding: 5px 10px; border-bottom: 1px solid #333; font-size: 12px; }
        .sell-row:last-child { border-bottom: none; }
        .sell-actions button { margin-left: 5px; padding: 2px 8px; font-size: 10px; }

        /* Dashboard (Stats/Inventory) */
        .dash-cols { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
        .inv-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(60px, 1fr)); gap: 5px; max-height: 200px; overflow-y: auto; }
        .inv-item { background: #222; border: 1px solid #444; padding: 5px; text-align: center; cursor: pointer; font-size: 10px; position: relative; transition: all 0.2s; pointer-events: auto; }
        .inv-item:hover { border-color: #fff; background: #333; }
        .inv-item.active { border-color: gold; box-shadow: 0 0 8px gold; background: rgba(255, 215, 0, 0.1); transform: scale(1.05); z-index: 10; }
        .inv-count { position: absolute; bottom: 2px; right: 2px; font-weight: bold; color: #fff; }
        .inv-trash { position: absolute; top: 0; right: 0; background: #c0392b; color: white; width: 15px; height: 15px; font-size: 10px; line-height: 15px; display: none; }
        .inv-item:hover .inv-trash { display: block; }
        .stat-row { display: flex; justify-content: space-between; font-size: 12px; border-bottom: 1px solid #333; padding: 2px 0; }

        .btn { background: var(--accent); color: white; border: none; padding: 10px; cursor: pointer; transition: all 0.2s; width: 100%; margin-top: 5px; font-weight: bold; border-radius: 4px; }
        .btn:hover { background: #3498db; filter: brightness(1.2); }
        .btn:disabled { background: #555; cursor: not-allowed; filter: none; }
        .btn-small { width: auto; padding: 4px 8px; font-size: 12px; margin-right: 5px; }
        .btn-bind { background: #444; border: 1px solid #666; color: #fff; text-align: left; position: relative; }
        .btn-bind.binding { background: #c0392b; border-color: #e74c3c; animation: pulse-red 1s infinite; }
        @keyframes pulse-red { 0% { opacity: 1; } 50% { opacity: 0.7; } 100% { opacity: 1; } }
        
        /* Credits Modal */
        #credits-modal .credits-section {
            margin-bottom: 25px;
        }

        #credits-modal h3 {
            margin: 10px 0;
            color: var(--accent);
            font-size: 18px;
            border-bottom: 1px solid #333;
            padding-bottom: 5px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .credit-entry {
            margin-left: 15px;
            margin-top: 8px;
        }

        .credit-entry strong {
            color: var(--highlight);
            font-size: 14px;
        }

        .credit-entry ul {
            margin: 5px 0 10px 20px;
            padding: 0;
        }

        .credit-entry li {
            list-style: none;
            font-size: 12px;
            color: #ccc;
            margin: 2px 0;
        }

        #credits-modal .simple-list li {
            list-style: none;
            margin: 4px 0;
            color: #ccc;
            font-size: 13px;
        }

        /* Server Status */
        .server-option { display: flex; justify-content: space-between; font-size: 12px; padding: 2px; }
        .status-dot { width: 8px; height: 8px; border-radius: 50%; display: inline-block; background: #555; margin-right: 5px; }
        .status-dot.green { background: #2ecc71; box-shadow: 0 0 5px #2ecc71; }
        .status-dot.red { background: #e74c3c; }

        /* Save Slots */
        .save-slot { background: rgba(0,0,0,0.4); padding: 10px; border: 1px solid #555; margin-bottom: 5px; display: flex; justify-content: space-between; align-items: center; }
        .save-slot-info { font-size: 12px; color: #ccc; }
        .save-slot-actions button { margin-left: 5px; padding: 5px 10px; font-size: 11px; }

        /* Start Screen */
        #start-screen { position: absolute; 
          background-image: 
            linear-gradient(30deg, #683131 12%, transparent 12.5%, transparent 87%, #683131 87.5%, #683131),
            linear-gradient(150deg, #683131 12%, transparent 12.5%, transparent 87%, #683131 87.5%, #683131),
            linear-gradient(30deg, #683131 12%, transparent 12.5%, transparent 87%, #683131 87.5%, #683131),
            linear-gradient(150deg, #683131 12%, transparent 12.5%, transparent 87%, #683131 87.5%, #683131),
            linear-gradient(60deg, #68313180 25%, transparent 25.5%, transparent 75%, #68313180 75%, #68313180),
            linear-gradient(60deg, #68313180 25%, transparent 25.5%, transparent 75%, #68313180 75%, #68313180);
        	background-size: 20px 35px;
          background-position: 0 0, 0 0, 10px 17.5px, 10px 17.5px, 0 0, 10px 17.5px;
          background-color: #362520;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          display: flex;
          flex-direction: column;
          align-items: center;
          justify-content: center;
          z-index: 50;
          pointer-events: auto;
        }
        #start-screen h1 { font-size: 48px; color: var(--highlight); margin-bottom: 20px; text-transform: uppercase; letter-spacing: 4px; text-shadow: 0 0 10px var(--highlight); }
        /* Notification/Error Popup */
        #notification-area { position: absolute; top: 20px; right: 180px; width: 300px; display: flex; flex-direction: column; gap: 10px; pointer-events: none; z-index: 200; }
        .toast { background: rgba(30, 30, 30, 0.95); border-left: 4px solid var(--accent); padding: 12px; color: white; pointer-events: auto; animation: slideIn 0.3s ease; box-shadow: 0 4px 10px rgba(0,0,0,0.5); font-size: 14px; }
        .toast.error { border-left-color: var(--danger); }
        .toast.success { border-left-color: var(--success); }
        @keyframes slideIn { from { transform: translateX(100%); opacity: 0; } to { transform: translateX(0); opacity: 1; } }

        /* Admin Panel */
        #admin-panel { position: absolute; top: 165px; right: 10px; background: rgba(0,0,0,0.7); padding: 10px; display: none; pointer-events: auto; width: 150px; border: 1px solid #555; }
        .player-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px; font-size: 11px; }
    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>
    
    <div id="ui-layer">
        <div id="heat-overlay"></div>
        
        <!-- Gear Icon -->
        <div id="gear-btn" onclick="UI.openSettings()">&#9881;</div>
        
        <!-- Coords -->
        <div id="coords-display">X: 0 Y: 0</div>

        <!-- Connection Lost -->
        <div id="disconnect-msg">CONNECTION LOST<br><span style="font-size:16px; font-weight:normal; color:#fff;">Trying to reconnect...</span></div>

        <!-- Connection Screen -->
        <div id="connection-screen">
            <div class="spinner"></div>
            <h2 style="color:#fff; margin-top:20px;">ESTABLISHING UPLINK</h2>
            <div id="connection-log"></div>
        </div>

        <!-- Minimap -->
        <div id="minimap-container">
            <canvas id="minimap"></canvas>
        </div>

        <!-- Chat -->
        <div id="chat-container">
            <div id="chat-messages"></div>
            <input type="text" id="chat-input" placeholder="Press CHAT key to type...">
        </div>

        <!-- Admin Panel -->
        <div id="admin-panel">
            <h4 style="margin:0 0 10px 0; color:gold; font-size:12px;">ADMIN PANEL</h4>
            <div id="player-list"></div>
        </div>

        <!-- Prompt -->
        <div id="prompt-msg"></div>

        <!-- Start Screen -->
        <div id="start-screen">
            <h1>Mega Miner</h1>
            <div style="background: var(--panel-bg); padding: 30px; border-radius: 10px; width: 300px; border: 1px solid #444;">
                <div class="form-group">
                    <label>Username</label>
                    <input type="text" id="start-username" value="Miner1" maxlength="12">
                </div>
                <div class="form-group">
                    <label>Room ID</label>
                    <input type="text" id="start-room" value="public-mine-1">
                </div>
                <div class="form-group">
                    <label>Vehicle Color</label>
                    <input type="color" id="start-color" value="#3498db" style="height:40px;">
                </div>
                <button class="btn" onclick="Game.init()">LAUNCH MISSION</button>
                <button class="btn" style="margin-top:10px; background:#444;" onclick="UI.openSettings()">SETTINGS / IMPORT</button>
            </div>
        </div>

        <!-- Dashboard Modal (Inventory/Stats) -->
        <div id="dashboard-modal" class="modal">
            <h2>Pilot Dashboard</h2>
            <div class="dash-cols">
                <div>
                    <h4 style="color:#aaa; border-bottom:1px solid #444;">INVENTORY / BUILD</h4>
                    <p style="font-size:11px; color:#777;">Click item to Equip for Building (B). Hover to Trash.</p>
                    <div id="inv-grid" class="inv-grid"></div>
                    <div id="station-btn-container" style="margin-top:20px; display:none;">
                        <button class="btn" style="background:var(--success);" onclick="Shop.open()">OPEN STATION SHOP</button>
                    </div>
                </div>
                <div>
                    <h4 style="color:#aaa; border-bottom:1px solid #444;">STATISTICS</h4>
                    <div id="stats-container"></div>
                    
                    <h4 style="color:#aaa; border-bottom:1px solid #444; margin-top:20px;">LEADERBOARD (Local)</h4>
                    <div id="leaderboard-container"></div>
                </div>
            </div>
            <button class="btn" style="background:#555; margin-top:20px;" onclick="$('dashboard-modal').classList.remove('active')">Close</button>
        </div>

        <!-- Shop Modal -->
        <div id="shop-modal" class="modal">
            <h2>Service Station</h2>
            <div style="text-align:center; margin-bottom:15px; font-size:18px;">
                Wallet: <span id="shop-money" style="color:gold; font-weight:bold;">$0</span>
            </div>
            <button class="btn" style="margin-bottom:10px; background:var(--success);" onclick="Shop.sellAll()">SELL ALL ORES</button>
            <button class="btn" style="margin-bottom:10px; background:var(--success);" onclick="Shop.refuelRepair()">Refuel and Repair ($10)</button>
            
            <h4 style="color:#aaa; border-bottom:1px solid #444;">SELL MINERALS</h4>
            <div id="sell-list" class="sell-list"></div>
            
            <h4 style="color:#aaa; border-bottom:1px solid #444; margin-top:20px;">UPGRADES</h4>
            <div class="shop-grid">
                <div class="shop-item">
                    <h4>Diamond Drill</h4>
                    <p>Increases Mining Tier.</p>
                    <div class="cost" id="cost-drill"></div>
                    <button class="btn" id="btn-drill" onclick="Shop.buy('drill')">Upgrade</button>
                </div>
                <div class="shop-item">
                    <h4>Nanite Hull</h4>
                    <p>Increases Max HP.</p>
                    <div class="cost" id="cost-hull"></div>
                    <button class="btn" id="btn-hull" onclick="Shop.buy('hull')">Upgrade</button>
                </div>
                <div class="shop-item">
                    <h4>Fuel Compactor</h4>
                    <p>Increases Fuel Capacity.</p>
                    <div class="cost" id="cost-fuel"></div>
                    <button class="btn" id="btn-fuel" onclick="Shop.buy('fuel')">Upgrade</button>
                </div>
                <div class="shop-item">
                    <h4>Cargo Bay</h4>
                    <p>Increases Carrying Capacity.</p>
                    <div class="cost" id="cost-cargo"></div>
                    <button class="btn" id="btn-cargo" onclick="Shop.buy('cargo')">Upgrade</button>
                </div>
                <div class="shop-item">
                    <h4>Heat Shield</h4>
                    <p>Resist high temperatures.</p>
                    <div class="cost" id="cost-cool"></div>
                    <button class="btn" id="btn-cool" onclick="Shop.buy('cool')">Upgrade</button>
                </div>
                <div class="shop-item">
                    <h4>X-Ray Optics</h4>
                    <p>See minerals through walls.</p>
                    <div class="cost" id="cost-xray"></div>
                    <button class="btn" id="btn-xray" onclick="Shop.buy('xray')">Upgrade</button>
                </div>
                 <div class="shop-item">
                    <h4>Vehicle Paint</h4>
                    <p>Change your look.</p>
                    <input type="color" id="shop-color-picker" style="width:100%; height:30px; margin-bottom:5px;">
                    <button class="btn" onclick="Shop.buy('paint')">Repaint ($100)</button>
                </div>
            </div>
            <button class="btn" style="background:#555; margin-top:20px;" onclick="Shop.close()">Exit Station</button>
        </div>

        <!-- Settings Modal -->
        <div id="settings-modal" class="modal">
            <h2>Settings</h2>
            
            <div class="form-group">
                <label>Audio Mixer</label>
                <div style="font-size:12px; display:grid; grid-template-columns: 1fr 3fr 1fr; gap:10px; align-items:center;">
                    <span>Master</span> <input type="range" id="vol-master" min="0" max="1" step="0.01" value="0.5" oninput="Sound.setVolume('master', this.value)"> <span id="vol-disp-master">50%</span>
                    <span>Music</span> <input type="range" id="vol-music" min="0" max="1" step="0.01" value="0.1" oninput="Sound.setVolume('music', this.value)"> <span id="vol-disp-music">50%</span>
                    <span>SFX</span> <input type="range" id="vol-sfx" min="0" max="1" step="0.01" value="0.5" oninput="Sound.setVolume('sfx', this.value)"> <span id="vol-disp-sfx">50%</span>
                    <span>Engine</span> <input type="range" id="vol-engine" min="0" max="1" step="0.01" value="0.5" oninput="Sound.setVolume('engine', this.value)"> <span id="vol-disp-engine">50%</span>
                </div>
            </div>

            <div class="form-group">
                <label>Update Checker</label>
                <div style="display:flex; gap:5px; margin-bottom:5px;">
                    <button class="btn btn-small" style="width:auto;" onclick="UI.checkForUpdates()">Check For Updates</button>
                </div>
                <div id="gh-status" style="font-size:11px; color:#aaa;">Check official repo for updates.</div>
            </div>

            <div class="form-group">
                <label>Multiplayer Broker</label>
                <div style="display:flex; gap:5px; margin-bottom:5px;">
                    <select id="server-list" onchange="$('setting-broker').value = this.value" style="flex:1;">
                        <option value="wss://broker.emqx.io:8084/mqtt">EMQX Public (WSS)</option>
                        <option value="ws://broker.emqx.io:8083/mqtt">EMQX Public (WS)</option>
                        <option value="wss://broker.hivemq.com:8000">HiveMQ Public (WSS)</option>
                        <option value="wss://mqtt.eclipseprojects.io:443/mqtt">Eclipse (WSS)</option>
                        <option value="wss://test.mosquitto.org:8081">Mosquitto (WSS)</option>
                        <option value="wss://cloud.mqtt.cool/mqtt">MQTT.cool (WSS)</option>
                        <option value="ws://localhost:8083/mqtt">Localhost (WS)</option>
                    </select>
                    <button class="btn btn-small" style="width:auto;" onclick="UI.checkServers()">Check Status</button>
                </div>
                <div id="server-status-display" style="margin-bottom:5px; font-size:11px; max-height:60px; overflow-y:auto; background:#222; padding:5px; display:none;"></div>
                <input type="text" id="setting-broker" placeholder="wss://broker.emqx.io:8084/mqtt">
                <small style="color:#777;">No effect while playing. Reload to change.</small>
            </div>

            <div class="form-group">
                <label>Options</label>
                <div style="display:flex; gap:15px;">
                    <label style="display:inline-flex; align-items:center; text-transform:none; color:#eee;">
                        <input type="checkbox" id="autosave-toggle" checked onchange="SaveSystem.toggleAutosave(this.checked)"> Autosave (60s)
                    </label>
                    <label style="display:inline-flex; align-items:center; text-transform:none; color:#eee;">
                        <input type="checkbox" id="update-check-toggle" checked> Autocheck Updates (60s)
                    </label>
                    <label style="display:inline-flex; align-items:center; text-transform:none; color:#eee;">
                        <input type="checkbox" id="coords-toggle" onchange="Game.toggleCoords(this.checked)"> Show Coordinates
                    </label>
                </div>
                <button class="btn btn-small" style="margin-top:5px; background:#444;" onclick="Network.requestMap(Game.localPlayer.id)">Force Map Sync</button>
            </div>

            <div class="form-group">
                <label>Save Games (LocalStorage) (1st slot does not work, some browsers clear localstorage/indexedDB so back up your saves)</label>
                <div id="save-slots-container"></div>
                <button class="btn" style="background:#555; margin-top:5px;" onclick="SaveSystem.saveAndReload()">Save & Reload Page</button>
            </div>

            <div class="form-group">
                <label>Controls</label>
                <div style="display:grid; grid-template-columns: 1fr 1fr; gap:5px; font-size:12px;">
                    <button id="btn-bind-up" class="btn btn-bind" onclick="Input.startBind('up')">UP</button>
                    <button id="btn-bind-left" class="btn btn-bind" onclick="Input.startBind('left')">LEFT</button>
                    <button id="btn-bind-down" class="btn btn-bind" onclick="Input.startBind('down')">DOWN</button>
                    <button id="btn-bind-right" class="btn btn-bind" onclick="Input.startBind('right')">RIGHT</button>
                    <button id="btn-bind-build" class="btn btn-bind" onclick="Input.startBind('build')">BUILD</button>
                    <button id="btn-bind-interact" class="btn btn-bind" onclick="Input.startBind('interact')">MENU/INTERACT</button>
                    <button id="btn-bind-transfer" class="btn btn-bind" onclick="Input.startBind('transfer')">TRANSFER</button>
                    <button id="btn-bind-chat" class="btn btn-bind" onclick="Input.startBind('chat')">CHAT</button>
                </div>
                <small>Hold BUILD + Arrow to place Equipped block. Mouse Wheel to Zoom.</small>
            </div>

            <div class="form-group">
                <label>Backup Data (File)</label>
                <div style="display: flex; gap: 5px; margin-bottom: 5px;">
                    <button class="btn" style="flex: 1; background:#444;" onclick="$('import-file').click()">Load Save from File</button>
                </div>
                <input type="file" id="import-file" style="margin-top:5px; display:none;" onchange="SaveSystem.importSave(this)">
            </div>
            <div id="credits"></div>
            <button class="btn" onclick="UI.closeSettings()">Close</button>
        </div>
    </div>

    <!-- Notification Area -->
    <div id="notification-area"></div>

<script>
/**
 * MEGA MINER ONLINE v3.4
 * Updates: Timestamp/Header Update Checker
 */

// --- UTILS ---
const $ = id => document.getElementById(id);
const uuid = () => Math.random().toString(36).substr(2, 9);
const now = () => Date.now();
const clamp = (num, min, max) => Math.min(Math.max(num, min), max);
const BUILD_TIMESTAMP = Date.now(); 

// --- SEEDED RNG ---
const pseudoRandom = (x, y) => {
    return Math.abs(Math.sin(x * 12.9898 + y * 78.233) * 43758.5453) % 1;
};

// --- CONFIG & STATE ---
const CONSTANTS = {
    TILE_SIZE: 32, CHUNK_SIZE: 16, SPEED_NORMAL: 2, SPEED_DRILL: 1, 
    FUEL_CONSUMPTION: 0.5, MAP_WIDTH: 200, MAP_HEIGHT: 600, MIN_ZOOM: 0.5, MAX_ZOOM: 3.0
};

const TILE_TYPES = {
    EMPTY: 0, DIRT: 1, GRASS: 2, STONE: 3, HARD_STONE: 4, DEEP_SLATE: 5,
    COAL: 6, IRON: 7, GOLD: 8, DIAMOND: 9, EMERALD: 10, RUBY: 11,
    CASING: 20, BEDROCK: 99
};

const TILE_PROPS = {
    [TILE_TYPES.EMPTY]: { name: "Empty" },
    [TILE_TYPES.DIRT]: { name: "Dirt", color: '#5d4037', hardness: 1, value: 0, tier: 0 },
    [TILE_TYPES.GRASS]: { name: "Grass", color: '#388e3c', hardness: 1, value: 0, tier: 0 },
    [TILE_TYPES.STONE]: { name: "Stone", color: '#7f8c8d', hardness: 3, value: 0, tier: 1 },
    [TILE_TYPES.HARD_STONE]: { name: "Dense Stone", color: '#525a5b', hardness: 6, value: 0, tier: 2 },
    [TILE_TYPES.DEEP_SLATE]: { name: "Deep Slate", color: '#2c3e50', hardness: 10, value: 0, tier: 3 },
    [TILE_TYPES.COAL]: { name: "Coal", color: '#2c3e50', hardness: 2, value: 10, tier: 0 },
    [TILE_TYPES.IRON]: { name: "Iron", color: '#95a5a6', hardness: 4, value: 50, tier: 1 },
    [TILE_TYPES.GOLD]: { name: "Gold", color: '#f1c40f', hardness: 6, value: 150, tier: 2 },
    [TILE_TYPES.DIAMOND]: { name: "Diamond", color: '#3498db', hardness: 10, value: 500, tier: 3 },
    [TILE_TYPES.EMERALD]: { name: "Emerald", color: '#2ecc71', hardness: 12, value: 800, tier: 3 },
    [TILE_TYPES.RUBY]: { name: "Ruby", color: '#e74c3c', hardness: 15, value: 1200, tier: 4 },
    [TILE_TYPES.CASING]: { name: "Structure", color: '#95a5a6', hardness: 2, value: 0, tier: 0 },
    [TILE_TYPES.BEDROCK]: { name: "Bedrock", color: '#000000', hardness: 999, value: 0, tier: 99 }
};

const MSGS = {
    join: ["spawned in.", "is here to steal your ores.", "slid into the server.", "woke up.", "has entered the chat."],
    leave: ["rage quit.", "went to touch grass.", "timed out (RIP).", "vanished.", "was consumed by the void."],
    kick: ["was yeeted.", "read the TOS wrong.", "was shown the door."],
    ban: ["has been banished to the shadow realm.", "caught the ban hammer."],
    death: ["forgot to breathe.", "became bedrock.", "was crushed by capitalism.", "needs a tutorial."],
    rescue: ["is running on fumes!", "needs a fuel stim!", "is signaling SOS!"]
};

let initialTimestamp = null;
let currentSaveId = 0;
// --- SOUND ENGINE ---
class SoundManager {
    constructor() {
        this.ctx = null;
        this.nodes = {};
        this.volumes = { master: 0.5, music: 0.5, sfx: 0.5, engine: 0.3 };
        this.playlist = ['audio/Chiptronical.ogg', 'audio/Great_Little_Challenge.ogg', 'audio/Solve_The_Puzzle.ogg', 'audio/Sneaky_Snitch.mp3', 'audio/cozy-lofi-relax-468509.mp3', 'audio/field-duel-lofi-464436.mp3', 'audio/lofi-background-music-3-471122.mp3','audio/chill-lofi-beat-469069.mp3'];
        this.currentTrack = 0;
        this.noiseBuffer = null;
    }

    init() {
        if (!this.ctx) {
            this.ctx = new (window.AudioContext || window.webkitAudioContext)();
            this.noiseBuffer = this.createNoiseBuffer();
            this.setupNodes();
            this.setupEngineLoop();
            this.playNextMusic();
        } else if (this.ctx.state === 'suspended') {
            this.ctx.resume();
        }
    }

    setupNodes() {
        this.nodes.master = this.ctx.createGain();
        this.nodes.master.gain.value = this.volumes.master;
        this.nodes.master.connect(this.ctx.destination);

        this.nodes.music = this.ctx.createGain();
        this.nodes.music.gain.value = this.volumes.music;
        this.nodes.music.connect(this.nodes.master);

        this.nodes.sfx = this.ctx.createGain();
        this.nodes.sfx.gain.value = this.volumes.sfx;
        this.nodes.sfx.connect(this.nodes.master);

        this.nodes.engine = this.ctx.createGain();
        this.nodes.engine.gain.value = this.volumes.engine;
        this.nodes.engine.connect(this.nodes.master);
    }

    setVolume(type, val) {
        this.volumes[type] = parseFloat(val);
        if (this.nodes[type]) this.nodes[type].gain.setTargetAtTime(this.volumes[type], this.ctx.currentTime, 0.1);
        else if (type === 'master' && this.nodes.master) this.nodes.master.gain.setTargetAtTime(this.volumes[type], this.ctx.currentTime, 0.1);
        $(`vol-disp-${type}`).innerText = Math.round(val*100) + '%';
        localStorage.setItem(`mm_vol_${type}`, val);
    }

    createNoiseBuffer() {
        if (!this.ctx) return null; 
        const bufSize = this.ctx.sampleRate * 2; 
        const buffer = this.ctx.createBuffer(1, bufSize, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufSize; i++) data[i] = Math.random() * 2 - 1;
        return buffer;
    }

    setupEngineLoop() {
        const noise = this.ctx.createBufferSource();
        noise.buffer = this.noiseBuffer; 
        noise.loop = true;
        const filter = this.ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 100;
        const gain = this.ctx.createGain();
        gain.gain.value = 0;
        noise.connect(filter);
        filter.connect(gain);
        gain.connect(this.nodes.engine); 
        noise.start();
        
        this.nodes.engineRumbleGain = gain;
        this.nodes.engineFilter = filter;

        const grindNoise = this.ctx.createBufferSource();
        grindNoise.buffer = this.noiseBuffer;
        grindNoise.loop = true;
        grindNoise.playbackRate.value = 0.5;
        
        const grindFilter = this.ctx.createBiquadFilter();
        grindFilter.type = 'bandpass';
        grindFilter.frequency.value = 150;
        grindFilter.Q.value = 1.0;

        const grindGain = this.ctx.createGain();
        grindGain.gain.value = 0;

        grindNoise.connect(grindFilter);
        grindFilter.connect(grindGain);
        grindGain.connect(this.nodes.engine);
        grindNoise.start();

        this.nodes.drillGain = grindGain;
        this.nodes.drillFilter = grindFilter;
    }

    updateEngine(speed, isDrilling) {
        if (!this.ctx || !this.nodes.engineRumbleGain || !this.nodes.engineFilter || !this.nodes.drillGain || !this.nodes.drillFilter) return;
        
        const t = this.ctx.currentTime;
        let baseVol = (speed > 0.1) ? 0.3 : 0.05;
        let baseFreq = 60 + (speed * 30);

        this.nodes.engineRumbleGain.gain.setTargetAtTime(baseVol, t, 0.2);
        this.nodes.engineFilter.frequency.setTargetAtTime(baseFreq, t, 0.2);

        if (isDrilling) {
            this.nodes.drillGain.gain.setTargetAtTime(0.5, t, 0.05);
            this.nodes.drillFilter.frequency.setTargetAtTime(150 + Math.random()*100, t, 0.1); 
        } else {
            this.nodes.drillGain.gain.setTargetAtTime(0, t, 0.1);
        }
    }

    playTone(freq, type, duration, vol = 0.1) {
        if (!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
        osc.connect(gain);
        gain.connect(this.nodes.sfx); 
        osc.start();
        osc.stop(this.ctx.currentTime + duration);
    }
    
    playMining() {
        if (!this.ctx || !this.noiseBuffer) return;
        const t = this.ctx.currentTime;
        
        const src = this.ctx.createBufferSource();
        src.buffer = this.noiseBuffer;
        src.playbackRate.value = 0.4 + Math.random() * 0.2; 
        
        const filter = this.ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 500; 

        const gain = this.ctx.createGain();
        gain.gain.setValueAtTime(0.5, t);
        gain.gain.exponentialRampToValueAtTime(0.01, t + 0.15);

        src.connect(filter);
        filter.connect(gain);
        gain.connect(this.nodes.sfx);
        src.start();
        src.stop(t + 0.15);
    }

    playChat(type) { 
        if (type==='join') { this.playTone(440, 'sine', 0.1); setTimeout(()=>this.playTone(880, 'sine', 0.2), 100); }
        else if (type==='leave') { this.playTone(440, 'sine', 0.1); setTimeout(()=>this.playTone(220, 'sine', 0.2), 100); }
        else if (type==='death') { this.playTone(100, 'sawtooth', 0.5, 0.2); }
        else this.playTone(600, 'triangle', 0.05);
    }
    playError() { this.playTone(150, 'sawtooth', 0.3, 0.1); }
    playSuccess() { this.playTone(800, 'sine', 0.1); setTimeout(()=>this.playTone(1200, 'sine', 0.2), 100); }
    playBuild() { this.playTone(300, 'square', 0.1); }
    playThud() { this.playTone(80, 'square', 0.1, 0.3); }

    playNextMusic() {
      try{
        if(this.musicSource) { this.musicSource.stop(); }
        this.currentTrack = Math.floor(Math.random() * 100) % this.playlist.length;
        const file = this.playlist[this.currentTrack];
        const audio = new Audio(file);
        const source = this.ctx.createMediaElementSource(audio);
        source.connect(this.nodes.music);
        audio.onended = () => this.playNextMusic();
        audio.onerror = () => { console.log("Music load failed, skipping"); this.playNextMusic(); };
        audio.play().catch(e=>console.log("Autoplay blocked"));
      }catch(e){
        console.error("Error playing music:", e);
      }
    }
    
    loadSettings() {
        ['master', 'music', 'sfx', 'engine'].forEach(t => {
            const v = localStorage.getItem(`mm_vol_${t}`);
            if(v !== null) {
                this.volumes[t] = parseFloat(v);
                $(`vol-${t}`).value = v;
                $(`vol-disp-${t}`).innerText = Math.round(v*100) + '%';
            }
        });
    }
}
const Sound = new SoundManager();

// --- GAME LOGIC ---

class GameEngine {
    constructor() {
        this.canvas = $('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.minimapCanvas = $('minimap');
        this.minimapCtx = this.minimapCanvas.getContext('2d');
        
        this.running = false;
        
        this.settings = {
            username: 'Miner',
            color: '#3498db',
            broker: 'wss://broker.emqx.io:8084/mqtt',
            room: 'public',
            keys: { 
                up: 'ArrowUp', left: 'ArrowLeft', right: 'ArrowRight', down: 'ArrowDown', 
                build: 'b', interact: 'e', chat: 'Enter', transfer: 'f'
            }
        };

        this.localPlayer = {
            id: uuid(),
            gridX: 100, gridY: 4,
            x: 0, y: 0,
            fuel: 100, maxFuel: 100,
            hull: 100, maxHull: 100,
            cargo: 0, maxCargo: 50,
            money: 0,
            temp: 0, maxTemp: 100,
            rotation: 0, isDrilling: false,
            drillTier: 0, heatResist: 0, xrayRange: 0,
            inventory: {}, 
            selectedBlock: TILE_TYPES.CASING,
            stats: { blocksMined: {}, totalMined: 0, startTime: now() },
            joinedAt: now()
        };

        this.map = []; 
        this.discovered = []; 
        this.remotePlayers = {}; 
        this.camera = { x: 0, y: 0 };
        this.zoom = 1.0;
        this.particles = [];
        this.isAdmin = false;
        this.bannedIds = JSON.parse(localStorage.getItem('mm_banned') || '[]');
        this.lastActionTime = 0;
        this.lastAutosave = 0;
        this.fallHeight = 0; 
        this.lastCoordsX = -1;
        this.lastCoordsY = -1;
        
        this.stationGridX = CONSTANTS.MAP_WIDTH / 2;
        this.stationGridY = 4;
        
        this.loadStoredSettings();
    }
    
    updateAdminStatus() {
        const players = Object.values(this.remotePlayers)
            .concat([this.localPlayer])
            .filter(p => p && p.joinedAt != null);

        if (players.length === 0) {
            Game.isAdmin = false;
            return;
        }

        players.sort((a, b) => a.joinedAt - b.joinedAt);
        const oldest = players[0];

        Game.isAdmin = (oldest.id === this.localPlayer.id);
    }

    loadStoredSettings() {
        if(localStorage.getItem('mm_username')) $('start-username').value = localStorage.getItem('mm_username');
        if(localStorage.getItem('mm_room_id')) $('start-room').value = localStorage.getItem('mm_room_id');
        if(localStorage.getItem('mm_veh_color')) $('start-color').value = localStorage.getItem('mm_veh_color');
        if(localStorage.getItem('mm_broker_url')) $('setting-broker').value = localStorage.getItem('mm_broker_url');
        
        const showCoords = localStorage.getItem('mm_show_coords');
        if(showCoords === 'true') { $('coords-toggle').checked = true; this.toggleCoords(true); }
        
        const binds = localStorage.getItem('mm_keybinds');
        if(binds) {
            try { this.settings.keys = {...this.settings.keys, ...JSON.parse(binds)}; } catch(e){console.error(e);}
        }
    }
    
    // Helper to get base procedural for syncing
    getProceduralTile(x, y) {
        if (y < 5) return TILE_TYPES.EMPTY;
        if (y === 5) return TILE_TYPES.GRASS;
        if (y === CONSTANTS.MAP_HEIGHT - 1) return TILE_TYPES.BEDROCK;

        let r = Game.getMapRandom(x, y);
        let type = TILE_TYPES.DIRT;
        if (y > 300) type = TILE_TYPES.DEEP_SLATE;
        else if (y > 100) type = TILE_TYPES.HARD_STONE;
        else if (y > 30) type = TILE_TYPES.STONE;

        if (r > 0.985) {
            if (y > 400) return TILE_TYPES.RUBY;
            else if (y > 250) return TILE_TYPES.EMERALD;
            else if (y > 150) return TILE_TYPES.DIAMOND;
        } else if (r > 0.96) {
            if (y > 100) return TILE_TYPES.GOLD;
        } else if (r > 0.92) {
            if (y > 50) return TILE_TYPES.IRON;
        } else if (r > 0.88) {
            return TILE_TYPES.COAL;
        }
        return type;
    }
    
    init() {
        this.settings.username = $('start-username').value || 'Miner';
        this.localPlayer.username = this.settings.username; 
        this.settings.room = $('start-room').value || 'public';
        this.settings.color = $('start-color').value;
        this.settings.broker = $('setting-broker').value;
        
        localStorage.setItem('mm_username', this.settings.username);
        localStorage.setItem('mm_room_id', this.settings.room);
        localStorage.setItem('mm_veh_color', this.settings.color);
        localStorage.setItem('mm_broker_url', this.settings.broker);
        
        $('start-screen').style.display = 'none';
        $('connection-screen').style.display = 'flex';
        this.logConnection("Initializing System...");

        this.resize();
        window.addEventListener('resize', () => this.resize());
        window.addEventListener('wheel', (e) => {
            if (e.target.id === 'gameCanvas') {
                this.zoom = clamp(this.zoom - Math.sign(e.deltaY) * 0.1, CONSTANTS.MIN_ZOOM, CONSTANTS.MAX_ZOOM);
            }
        });

        this.minimapCanvas.width = 150;
        this.minimapCanvas.height = 150;

        let seed = 0;
        for (let i = 0; i < this.settings.room.length; i++) seed += this.settings.room.charCodeAt(i);
        this.roomSeed = seed * 12345;

        this.generateMap();
        Input.init();
        Sound.loadSettings();
        
        Network.connect(); 
        UI.refreshKeybindLabels();
        UI.checkForUpdates(); 

        this.running = true;
        this.localPlayer.gridX = Math.floor(CONSTANTS.MAP_WIDTH / 2);
        this.localPlayer.gridY = 4;
        this.localPlayer.x = this.localPlayer.gridX * CONSTANTS.TILE_SIZE;
        this.localPlayer.y = this.localPlayer.gridY * CONSTANTS.TILE_SIZE;
        this.localPlayer.stats.startTime = now();

        Sound.init();
    }
    
    logConnection(msg) {
        const d = document.createElement('div');
        d.className = 'log-line';
        d.innerText = `> ${msg}`;
        $('connection-log').appendChild(d);
        $('connection-log').scrollTop = $('connection-log').scrollHeight;
    }
    
    finishConnection() {
        setTimeout(() => {
            $('connection-screen').style.display = 'none';
            this.loop();
            UI.addMessage("System", "Welcome. E for Menu/Shop. B to Build. F to Transfer.", "#FFFF00");
            Network.broadcastMove(); 
            this.updateAdminStatus();
        }, 1000);
    }

    resize() {
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
    }

    generateMap() {
        for (let y = 0; y < CONSTANTS.MAP_HEIGHT; y++) {
            this.map[y] = [];
            this.discovered[y] = new Uint8Array(CONSTANTS.MAP_WIDTH); 
            for (let x = 0; x < CONSTANTS.MAP_WIDTH; x++) {
                if (y < 5) {
                    this.map[y][x] = TILE_TYPES.EMPTY;
                    this.discovered[y][x] = 1; 
                }
                else if (y === 5) {
                     this.map[y][x] = TILE_TYPES.GRASS;
                     this.discovered[y][x] = 1; 
                }
                else if (y === CONSTANTS.MAP_HEIGHT - 1) this.map[y][x] = TILE_TYPES.BEDROCK;
                else {
                    let r = Game.getMapRandom(x, y);
                    let type = TILE_TYPES.DIRT;
                    if (y > 300) type = TILE_TYPES.DEEP_SLATE;
                    else if (y > 100) type = TILE_TYPES.HARD_STONE;
                    else if (y > 30) type = TILE_TYPES.STONE;

                    if (r > 0.985) {
                        if (y > 400) type = TILE_TYPES.RUBY;
                        else if (y > 250) type = TILE_TYPES.EMERALD;
                        else if (y > 150) type = TILE_TYPES.DIAMOND;
                    } else if (r > 0.96) {
                        if (y > 100) type = TILE_TYPES.GOLD;
                    } else if (r > 0.92) {
                        if (y > 50) type = TILE_TYPES.IRON;
                    } else if (r > 0.88) {
                        type = TILE_TYPES.COAL;
                    }
                    this.map[y][x] = type;
                }
            }
        }
    }
    
    getMapRandom(x, y) {
        const s = Math.sin(x * 12.9898 + y * 78.233 + this.roomSeed) * 43758.5453;
        return s - Math.floor(s);
    }

    toggleCoords(show) {
        $('coords-display').style.display = show ? 'block' : 'none';
        localStorage.setItem('mm_show_coords', show);
    }

    update() {
        if (!this.running) return;

        const p = this.localPlayer;
        const TS = CONSTANTS.TILE_SIZE;

        let targetX = p.gridX * TS;
        let targetY = p.gridY * TS;
        let dx = targetX - p.x;
        let dy = targetY - p.y;
        let dist = Math.sqrt(dx*dx + dy*dy);
        let speed = p.isDrilling ? CONSTANTS.SPEED_DRILL : CONSTANTS.SPEED_NORMAL;
        let isMoving = false;

        if (dist > speed) {
            let angle = Math.atan2(dy, dx);
            p.x += Math.cos(angle) * speed;
            p.y += Math.sin(angle) * speed;
            isMoving = true;
        } else {
            p.x = targetX; p.y = targetY; p.isDrilling = false;
            
            // broken -- dont use yet
            // if (this.fallHeight > 1 && !isMoving) {
            //     Sound.playThud();
            //     this.fallHeight = 0;
            // }

            let ix = 0, iy = 0;
            if (Input.keys[this.settings.keys.up]) iy = -1;
            else if (Input.keys[this.settings.keys.down]) iy = 1;
            else if (Input.keys[this.settings.keys.left]) ix = -1;
            else if (Input.keys[this.settings.keys.right]) ix = 1;

            if (Input.keys[this.settings.keys.build] && (ix || iy)) {
                if (now() - this.lastActionTime > 200) {
                    this.tryBuild(p.gridX + ix, p.gridY + iy);
                    this.lastActionTime = now();
                }
            } else if (ix || iy) {
                if (ix === 1) p.rotation = -90 * (Math.PI/180);
                if (ix === -1) p.rotation = 90 * (Math.PI/180);
                if (iy === 1) { p.rotation = 0; this.fallHeight++; }
                if (iy === -1) { p.rotation = 180 * (Math.PI/180); this.fallHeight = 0; }
                if (ix !== 0) this.fallHeight = 0;

                let nx = p.gridX + ix;
                let ny = p.gridY + iy;

                if (nx >= 0 && nx < CONSTANTS.MAP_WIDTH && ny >= 4 && ny < CONSTANTS.MAP_HEIGHT) {
                    let tile = (ny < 0) ? TILE_TYPES.EMPTY : this.map[ny][nx];
                    if (tile === TILE_TYPES.EMPTY) {
                        p.gridX = nx; p.gridY = ny;
                        if (p.gridY > 5 && p.fuel > 0) p.fuel -= CONSTANTS.FUEL_CONSUMPTION;
                        Network.broadcastMove();
                    } else if (tile !== TILE_TYPES.BEDROCK) {
                        if (now() - this.lastActionTime > 150) { 
                             if (this.tryMine(nx, ny)) {
                                 p.gridX = nx; p.gridY = ny;
                                 p.isDrilling = true;
                                 if (p.gridY > 5 && p.fuel > 0) p.fuel -= CONSTANTS.FUEL_CONSUMPTION;
                                 Network.broadcastMove();
                             }
                             this.lastActionTime = now();
                        }
                    }
                }
            }
        }
        
        Sound.updateEngine(isMoving ? speed : 0, p.isDrilling);

        Object.values(this.remotePlayers).forEach(rp => {
            if (rp.targetX !== undefined) {
                let rdx = rp.targetX - rp.x;
                let rdy = rp.targetY - rp.y;
                let rDist = Math.sqrt(rdx*rdx + rdy*rdy);
                let rSpeed = rp.isDrilling ? CONSTANTS.SPEED_DRILL : CONSTANTS.SPEED_NORMAL;
                if (rDist > rSpeed) {
                    let rAngle = Math.atan2(rdy, rdx);
                    rp.x += Math.cos(rAngle) * rSpeed;
                    rp.y += Math.sin(rAngle) * rSpeed;
                } else { rp.x = rp.targetX; rp.y = rp.targetY; }
            }
        });

        // Heat Logic
        let depth = Math.max(0, p.gridY - 5);
        let heatThreshold = 100 + (p.heatResist * 50); 
        if (depth > heatThreshold) {
            p.temp += 0.05;
            if (p.temp > 100) { 
                p.temp = 100; 
                p.hull -= 0.1; 
                $('heat-overlay').style.opacity = (Math.sin(now()/100)+1)/4 + 0.3; 
            }
        } else {
            p.temp = Math.max(0, p.temp - 0.2);
            $('heat-overlay').style.opacity = 0;
        }

        $('prompt-msg').style.display = 'none';
        if (p.gridY === this.stationGridY && Math.abs(p.gridX - this.stationGridX) < 2) {
             $('prompt-msg').style.display = 'block';
             $('prompt-msg').innerText = "PRESS E TO OPEN DASHBOARD/SHOP";
        }
        
        if (Input.keys[this.settings.keys.interact] && now() - this.lastActionTime > 500) {
            UI.toggleDashboard();
            this.lastActionTime = now();
        }

        p.fuel = clamp(p.fuel, 0, p.maxFuel);
        p.hull = clamp(p.hull, 0, p.maxHull);
        if (p.hull <= 0) this.respawn();

        this.camera.x += (p.x - this.camera.x) * 0.1;
        this.camera.y += (p.y - this.camera.y) * 0.1;

        if (SaveSystem.autosaveEnabled && now() - this.lastAutosave > 60000 && Game.isAdmin) {
            SaveSystem.saveToSlot(currentSaveId,/*, true*/); 
            this.lastAutosave = now();
            
            // dirty but it works
            if(document.getElementById('update-check-toggle').checked){
                UI.checkForUpdates();
            }
        }

        Network.update(); 
        
        // Coords Update Optimized
        if (this.lastCoordsX !== p.gridX || this.lastCoordsY !== p.gridY) {
            $('coords-display').innerText = `X: ${p.gridX} Y: ${depth}`;
            this.lastCoordsX = p.gridX;
            this.lastCoordsY = p.gridY;
        }
    }

    tryTransferFuel(targetId) {
        if (this.localPlayer.fuel > 10) {
            this.localPlayer.fuel -= 10;
            Network.sendFuel(targetId, 10);
            UI.showToast("Sent 10 Fuel!", "success");
            Sound.playSuccess();
        } else {
            UI.showToast("Not enough fuel!", "error");
            Sound.playError();
        }
    }

    tryBuild(tx, ty) {
        if (tx < 0 || tx >= CONSTANTS.MAP_WIDTH || ty < 0 || ty >= CONSTANTS.MAP_HEIGHT) return;
        if (this.map[ty][tx] === TILE_TYPES.EMPTY) {
            const type = this.localPlayer.selectedBlock;
            let count = this.localPlayer.inventory[type] || 0;
            
            if (count > 0) {
                this.localPlayer.inventory[type]--;
                this.localPlayer.cargo--; 
                this.map[ty][tx] = type;
                Network.sendTileUpdate(tx, ty, type);
                this.spawnParticle(tx * 32 + 16, ty * 32 + 16, '#95a5a6', 5);
                Sound.playBuild();
                UI.showToast("Block Placed", "success");
                UI.updateDashboard(); 
            } else {
                UI.showToast("Out of blocks!", "error");
                Sound.playError();
            }
        }
    }
    
    trashBlock(type) {
        const p = this.localPlayer;
        if(p.inventory[type] > 0) {
            p.inventory[type]--;
            p.cargo--;
            UI.showToast(`Trashed 1 ${TILE_PROPS[type].name}`, "normal");
            UI.updateDashboard();
        }
    }

    tryMine(tx, ty) {
        let tile = this.map[ty][tx];
        if (tile !== TILE_TYPES.EMPTY && tile !== TILE_TYPES.BEDROCK) {
            let props = TILE_PROPS[tile];
            if (this.localPlayer.drillTier < props.tier) { UI.showToast(`Need Tier ${props.tier} Drill`, "error"); Sound.playError(); return false; }
            if (this.localPlayer.cargo < this.localPlayer.maxCargo) {
                if (!this.localPlayer.inventory[tile]) this.localPlayer.inventory[tile] = 0;
                this.localPlayer.inventory[tile]++;
                this.localPlayer.cargo++;
                
                if (!this.localPlayer.stats.blocksMined[tile]) this.localPlayer.stats.blocksMined[tile] = 0;
                this.localPlayer.stats.blocksMined[tile]++;
                this.localPlayer.stats.totalMined++;

                this.map[ty][tx] = TILE_TYPES.EMPTY;
                this.discovered[ty][tx] = 1;
                this.spawnParticle(tx * 32 + 16, ty * 32 + 16, props.color, 8);
                Sound.playMining(); 
                Network.sendTileUpdate(tx, ty, TILE_TYPES.EMPTY);
                UI.updateDashboard(); 
                return true;
            } else { UI.showToast("Cargo Full!", "error"); Sound.playError(); return false; }
        }
        return false;
    }

    spawnParticle(x, y, color, count) {
        for(let i=0; i<count; i++) {
            this.particles.push({x, y, vx: (Math.random()-0.5)*6, vy: (Math.random()-0.5)*6, life: 1.0, color});
        }
    }

    respawn() {
        this.localPlayer.gridX = Math.floor(CONSTANTS.MAP_WIDTH / 2);
        this.localPlayer.gridY = 4;
        this.localPlayer.x = this.localPlayer.gridX * CONSTANTS.TILE_SIZE;
        this.localPlayer.y = this.localPlayer.gridY * CONSTANTS.TILE_SIZE;
        this.localPlayer.hull = this.localPlayer.maxHull;
        this.localPlayer.fuel = this.localPlayer.maxFuel;
        this.localPlayer.cargo = 0;
        this.localPlayer.inventory = {}; 
        this.localPlayer.money = Math.floor(this.localPlayer.money * 0.7);
        Network.broadcastDeath(); 
        Sound.playChat('death');
        $('heat-overlay').style.opacity = 0;
        UI.updateDashboard();
    }

    draw() {
        if (!this.running) return;
        this.ctx.resetTransform();
        this.ctx.fillStyle = '#050505';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        let cx = this.canvas.width / 2;
        let cy = this.canvas.height / 2;
        this.ctx.translate(cx, cy);
        this.ctx.scale(this.zoom, this.zoom);
        this.ctx.translate(-Math.floor(this.camera.x), -Math.floor(this.camera.y));

        const viewW = (this.canvas.width / this.zoom);
        const viewH = (this.canvas.height / this.zoom);
        const startCol = Math.floor((this.camera.x - viewW/2) / CONSTANTS.TILE_SIZE) - 1;
        const endCol = Math.floor((this.camera.x + viewW/2) / CONSTANTS.TILE_SIZE) + 1;
        const startRow = Math.floor((this.camera.y - viewH/2) / CONSTANTS.TILE_SIZE) - 1;
        const endRow = Math.floor((this.camera.y + viewH/2) / CONSTANTS.TILE_SIZE) + 1;

        const pcx = this.localPlayer.gridX;
        const pcy = this.localPlayer.gridY;
        const visionRad = 6;
        const xrayRad = 2 + this.localPlayer.xrayRange;

        /// -------------------------------
        // WORLD TIME (host-based)
        // -------------------------------
        const allPlayers = Object.values(this.remotePlayers)
            .concat([this.localPlayer])
            .filter(p => typeof p.joinedAt === "number" && !isNaN(p.joinedAt));
        if (allPlayers.length === 0) {
            // fallback: treat local player as host
            allPlayers.push({ ...this.localPlayer, joinedAt: Date.now() });
        }
        const host = allPlayers.sort((a,b)=>a.joinedAt - b.joinedAt)[0] || this.localPlayer;
        const worldTime = Date.now() - host.joinedAt;

        const dayLength = 20 * 60 * 1000;
        const t = (worldTime % dayLength) / dayLength;

        // Rotate so sunrise = 0.25, noon = 0.5, sunset = 0.75
        const sunAngle = (t * Math.PI * 2) - Math.PI / 2;

        // Smooth daylight curve (no flicker)
        const daylight = (() => {
            const x = (Math.cos(sunAngle) + 1) / 2; // 010
            return x * x * (3 - 2 * x);            // smoothstep
        })();

        // -------------------------------
        // SKY COLOR (above ground level y=5)
        // -------------------------------
        const baseSky = { r: 135, g: 206, b: 235 };
        const groundY = 5 * CONSTANTS.TILE_SIZE;

        const sunrise = Math.max(0, 1 - Math.abs(t - 0.25) * 20);
        const sunset  = Math.max(0, 1 - Math.abs(t - 0.75) * 20);
        const warm = sunrise + sunset;

        const r = Math.round(baseSky.r * (0.3 + daylight*0.7) - warm * 80);
        const g = Math.round(baseSky.g * (0.3 + daylight*0.7) - warm * 40);
        const b = Math.round(baseSky.b * (0.3 + daylight*0.7) - warm * 20);

        this.ctx.fillStyle = `rgb(${r},${g},${b})`;
        this.ctx.fillRect(
            this.camera.x - viewW,
            -2000,
            viewW * 2,
            groundY + 2000
        );

        // Sunrise/sunset gradient
        if (warm > 0) {
            const grad = this.ctx.createLinearGradient(0, -2000, 0, groundY);
            grad.addColorStop(0, `rgba(255,120,50,${warm * 0.6})`);
            grad.addColorStop(1, `rgba(255,180,120,${warm * 0.3})`);
            this.ctx.fillStyle = grad;
            this.ctx.fillRect(
                this.camera.x - viewW,
                -2000,
                viewW * 2,
                groundY + 2000
            );
        }

        // -------------------------------
        // SUN & MOON POSITIONS
        // -------------------------------
        const skyRadius = 900;
        const centerX = this.camera.x;
        const centerY = groundY - 300; // horizon

        const sunX = centerX + Math.cos(sunAngle) * skyRadius;
        const sunY = centerY + Math.sin(sunAngle) * skyRadius;

        const moonX = centerX + Math.cos(sunAngle + Math.PI) * skyRadius;
        const moonY = centerY + Math.sin(sunAngle + Math.PI) * skyRadius;

        // -------------------------------
        // SUN (always drawn)
        // -------------------------------
        {
            const sunSize = 70;
            const grd = this.ctx.createRadialGradient(sunX, sunY, 0, sunX, sunY, sunSize);
            grd.addColorStop(0, "rgba(255,255,200,1)");
            grd.addColorStop(1, "rgba(255,180,0,0.2)");

            this.ctx.fillStyle = grd;
            this.ctx.beginPath();
            this.ctx.arc(sunX, sunY, sunSize, 0, Math.PI*2);
            this.ctx.fill();
        }

        // -------------------------------
        // MOON (one draw call, 3 phases)
        // -------------------------------
        {
            const moonSize = 55;
            const moonCycle = 60 * 60 * 1000;
            const moonPhase = (worldTime % moonCycle) / moonCycle; // 0=new, 0.5=full

            this.ctx.fillStyle = "#e0e0e0";
            this.ctx.beginPath();

            // Outer circle
            this.ctx.arc(moonX, moonY, moonSize, 0, Math.PI * 2);

            // Phase curve (one quadratic curve)
            const curveOffset = (moonPhase - 0.5) * moonSize * 1.6;

            this.ctx.moveTo(moonX - moonSize, moonY);
            this.ctx.quadraticCurveTo(
                moonX + curveOffset,
                moonY,
                moonX - moonSize,
                moonY
            );

            this.ctx.fill();
        }

        // -------------------------------
        // STARS
        // -------------------------------
        if (!this.starField) {
            this.starField = [];
            for (let i = 0; i < 200; i++) {
                this.starField.push({
                    x: Math.random() * 5000 - 2500,
                    y: Math.random() * 2000 - 2000,
                    b: Math.random() * 0.8 + 0.2
                });
            }
        }

        {
            const starAlpha = (0.4 - daylight) / 0.4;
            if (starAlpha > 0) {
                this.ctx.fillStyle = "#fff";
                for (const s of this.starField) {
                    this.ctx.globalAlpha = s.b * starAlpha;
                    this.ctx.fillRect(s.x, s.y, 2, 2);
                }
                this.ctx.globalAlpha = 1;
            }
        }

        // -------------------------------
        // BLACK RECTANGLE (drawn LAST in sky section)
        // -------------------------------
        this.ctx.fillStyle = "#000";
        this.ctx.fillRect(
            this.camera.x - viewW,
            groundY,
            viewW * 2,
            5000
        );

        this.drawStation();

        for (let y = Math.max(0, startRow); y <= Math.min(CONSTANTS.MAP_HEIGHT-1, endRow); y++) {
            for (let x = Math.max(0, startCol); x <= Math.min(CONSTANTS.MAP_WIDTH-1, endCol); x++) {
                let dx = x - pcx; let dy = y - pcy;
                let dist = Math.sqrt(dx*dx + dy*dy);
                let visible = dist <= visionRad;
                let xray = dist <= xrayRad;

                if (visible) this.discovered[y][x] = 1;
                let tile = this.map[y][x];

                if (visible || xray) this.drawProceduralTile(x, y, tile, xray && !visible);
                else if (this.discovered[y][x]) {
                    this.ctx.globalAlpha = 0.3;
                    this.drawProceduralTile(x, y, tile, false);
                    this.ctx.globalAlpha = 1.0;
                }
            }
        }

        Object.values(this.remotePlayers).forEach(p => this.drawPlayer(p, false));
        this.drawPlayer(this.localPlayer, true);

        for (let i = this.particles.length - 1; i >= 0; i--) {
            let p = this.particles[i];
            p.x += p.vx; p.y += p.vy; p.life -= 0.05;
            this.ctx.globalAlpha = p.life; this.ctx.fillStyle = p.color;
            this.ctx.fillRect(p.x, p.y, 4, 4); this.ctx.globalAlpha = 1.0;
            if (p.life <= 0) this.particles.splice(i, 1);
        }

        this.drawLocalMinimap();
        this.ctx.resetTransform();
        this.drawHUD();
    }


    drawStation() {
        let ts = CONSTANTS.TILE_SIZE;
        let x = this.stationGridX * ts;
        let y = this.stationGridY * ts;
        this.ctx.fillStyle = '#7f8c8d'; this.ctx.fillRect(x - 40, y - 40, 80, 72);
        this.ctx.fillStyle = '#c0392b'; this.ctx.beginPath(); this.ctx.moveTo(x - 50, y - 40); this.ctx.lineTo(x, y - 70); this.ctx.lineTo(x + 50, y - 40); this.ctx.fill();
        this.ctx.fillStyle = '#2c3e50'; this.ctx.fillRect(x - 20, y - 10, 40, 42);
        this.ctx.fillStyle = '#f1c40f'; this.ctx.font = 'bold 12px Arial'; this.ctx.textAlign = 'center'; this.ctx.fillText("SHOP", x, y - 50);
    }

    drawProceduralTile(x, y, type, isXray) {
        let ts = CONSTANTS.TILE_SIZE;
        let px = x * ts; let py = y * ts;
        let prop = TILE_PROPS[type];
        if (isXray) { this.ctx.strokeStyle = prop.color; this.ctx.lineWidth = 2; this.ctx.strokeRect(px+4, py+4, ts-8, ts-8); return; }
        
        // Detailed Texture Patterns
        this.ctx.fillStyle = prop.color; 
        this.ctx.fillRect(px, py, ts, ts);
        const seed = Math.sin(x * 12.9898 + y * 78.233) * 43758.5453;
        const n1 = (seed % 1); 
        const n2 = ((seed * 10) % 1);
        let bevel = true;
        if (type === TILE_TYPES.EMPTY && y>=5) {
            this.ctx.fillStyle = 'rgba(50, 25, 15, 1)';
            this.ctx.fillRect(px, py, ts, ts);
            
            // Add some small pebbles/debris
            this.ctx.fillStyle = 'rgba(120, 90, 70, 0.4)';
            if(n1 > 0.7) this.ctx.fillRect(px + 8, py + 8, 3, 3);
            if(n2 > 0.6) this.ctx.fillRect(px + 20, py + 12, 2, 2);
            if(n1 < 0.3) this.ctx.fillRect(px + 15, py + 20, 4, 2);
            bevel=false;
        }
        else if (type === TILE_TYPES.EMPTY && y<5) {
            this.ctx.fillStyle = 'rgba(0, 0, 0, 0)';
            return
        }
        else if (type === TILE_TYPES.DIRT) {
             this.ctx.fillStyle = 'rgba(0,0,0,0.15)';
             if(n1 > 0.5) this.ctx.fillRect(px+4, py+4, 4, 4);
             if(n2 < 0.5) this.ctx.fillRect(px+20, py+20, 5, 5);
             if(n1 < 0.2) this.ctx.fillRect(px+12, py+10, 3, 3);
        } else if (type === TILE_TYPES.GRASS) {
             this.ctx.fillStyle = '#2ecc71'; this.ctx.fillRect(px, py, ts, 6);
             this.ctx.fillStyle = 'rgba(0,0,0,0.1)'; this.ctx.fillRect(px, py+6, ts, ts-6);
        } else if (type === TILE_TYPES.STONE || type === TILE_TYPES.HARD_STONE) {
             this.ctx.fillStyle = 'rgba(0,0,0,0.2)';
             if(n1 > 0.3) { this.ctx.fillRect(px+5, py+5, 10, 6); this.ctx.fillRect(px+18, py+18, 10, 6); }
             this.ctx.strokeStyle = 'rgba(0,0,0,0.1)';
             this.ctx.beginPath(); this.ctx.moveTo(px, py+ts); this.ctx.lineTo(px+ts, py); this.ctx.stroke();
        } else if (type === TILE_TYPES.CASING) {
            this.ctx.strokeStyle = '#555'; this.ctx.lineWidth = 4;
            this.ctx.strokeRect(px+2, py+2, ts-4, ts-4);
            this.ctx.beginPath(); this.ctx.moveTo(px, py); this.ctx.lineTo(px+ts, py+ts); this.ctx.moveTo(px+ts, py); this.ctx.lineTo(px, py+ts); this.ctx.stroke();
            return;
        } else if (type >= TILE_TYPES.COAL && type <= TILE_TYPES.RUBY) {
            this.ctx.fillStyle = 'rgba(255,255,255,0.4)';
            // Sparkle
            if (now() % 1000 < 500) {
                this.ctx.fillRect(px + 8 + (n1*16), py + 8 + (n2*16), 2, 2);
            }
        }
        
        // Bevel for all
        if(bevel){
          this.ctx.fillStyle = 'rgba(0,0,0,0.2)'; this.ctx.fillRect(px, py+ts-2, ts, 2); this.ctx.fillRect(px+ts-2, py, 2, ts); 
          this.ctx.fillStyle = 'rgba(255,255,255,0.1)'; this.ctx.fillRect(px, py, ts, 2); this.ctx.fillRect(px, py, 2, ts);
        }
    }

    drawPlayer(p, isLocal) {
        let size = CONSTANTS.TILE_SIZE;
        let cx = p.x + size/2; let cy = p.y + size/2;
        this.ctx.save(); this.ctx.translate(cx, cy); this.ctx.rotate(p.rotation || 0);
        let color = isLocal ? this.settings.color : (p.color || '#fff');
        
        this.ctx.fillStyle = color; this.ctx.fillRect(-12, -12, 24, 24);
        this.ctx.strokeStyle = '#111'; this.ctx.lineWidth = 2; this.ctx.strokeRect(-12, -12, 24, 24);
        this.ctx.fillStyle = '#bdc3c7';
        let drillOffset = (p.isDrilling && now() % 200 > 100) ? 2 : 0;
        this.ctx.beginPath(); this.ctx.moveTo(-6, 12); this.ctx.lineTo(0, 20 + drillOffset); this.ctx.lineTo(6, 12); this.ctx.fill();
        this.ctx.fillStyle = '#2c3e50'; this.ctx.fillRect(-16, -10, 4, 20); this.ctx.fillRect(12, -10, 4, 20);
        this.ctx.fillStyle = '#3498db'; this.ctx.fillRect(-6, -6, 12, 8);
        if (!isLocal) {
            this.ctx.rotate(-p.rotation); this.ctx.fillStyle = '#fff'; this.ctx.font = '10px Arial'; this.ctx.textAlign = 'center'; 
            this.ctx.shadowColor="black"; this.ctx.shadowBlur=2;
            this.ctx.fillText(p.username || "Unknown", 0, -20);
            this.ctx.shadowBlur=0;
        }
        this.ctx.restore();
    }
    
    drawLocalMinimap() {
        this.minimapCtx.fillStyle = '#000'; this.minimapCtx.fillRect(0, 0, 150, 150);
        const range = Math.floor(30 / this.zoom); 
        const center = 75; 
        const pX = this.localPlayer.gridX; const pY = this.localPlayer.gridY;
        const pixelSize = Math.max(2, 2 * this.zoom); // Better visibility

        for (let dy = -range; dy <= range; dy++) {
            for (let dx = -range; dx <= range; dx++) {
                let mx = pX + dx; let my = pY + dy;
                if (mx >= 0 && mx < CONSTANTS.MAP_WIDTH && my >= 0 && my < CONSTANTS.MAP_HEIGHT) {
                    if (this.discovered[my][mx]) {
                        let tile = this.map[my][mx];
                        this.minimapCtx.fillStyle = tile === TILE_TYPES.EMPTY ? '#111' : TILE_PROPS[tile].color;
                        this.minimapCtx.fillRect(center + dx*pixelSize, center + dy*pixelSize, pixelSize, pixelSize);
                    }
                }
            }
        }
        // Viewport Border
        this.minimapCtx.strokeStyle = "rgba(255,255,255,0.3)";
        this.minimapCtx.lineWidth = 1;
        let vw = (this.canvas.width / CONSTANTS.TILE_SIZE / this.zoom) * pixelSize;
        let vh = (this.canvas.height / CONSTANTS.TILE_SIZE / this.zoom) * pixelSize;
        this.minimapCtx.strokeRect(center - vw/2, center - vh/2, vw, vh);

        this.minimapCtx.fillStyle = '#e74c3c'; this.minimapCtx.fillRect(center-2, center-2, 5, 5); // Me
        
        // Remote Players
        Object.values(this.remotePlayers).forEach(rp => {
            let dx = rp.gridX - pX; let dy = rp.gridY - pY;
            if(Math.abs(dx) <= range && Math.abs(dy) <= range) {
                this.minimapCtx.fillStyle = '#3498db';
                this.minimapCtx.fillRect(center + dx*pixelSize -1, center + dy*pixelSize -1, 4, 4);
                // Draw ID/Name tooltip if needed, but clean dots are better for minimaps
                if(!rp.username) {
                     this.minimapCtx.fillStyle = "#fff"; this.minimapCtx.font = "8px Arial"; 
                     this.minimapCtx.fillText(rp.id.substr(0,4), center + dx*pixelSize, center + dy*pixelSize - 5);
                }
            }
        });
    }

    drawHUD() {
        const p = this.localPlayer;
        const w = this.canvas.width; const h = this.canvas.height;
        this.drawGauge(60, h - 60, 40, p.fuel, p.maxFuel, "FUEL", "#d35400");
        this.drawGauge(160, h - 60, 40, p.hull, p.maxHull, "HULL", "#c0392b");
        this.drawGauge(w - 60, h - 60, 40, p.cargo, p.maxCargo, "CARGO", "#27ae60");
        this.drawGauge(w - 160, h - 60, 40, p.temp, 100, "TEMP", "#e74c3c");
        
        this.ctx.fillStyle = "#f1c40f"; this.ctx.font = "bold 20px monospace"; this.ctx.textAlign = "center"; this.ctx.fillText("$ " + Math.floor(p.money), w/2, h - 30);
        let depth = Math.floor(Math.max(0, p.gridY - 5));
        this.ctx.fillStyle = "#aaa"; this.ctx.font = "14px monospace"; this.ctx.fillText(`Depth: ${depth}m | Drill Tier: ${p.drillTier}`, w/2, h - 55);
    }
    
    drawGauge(x, y, r, val, max, label, color) {
        const ctx = this.ctx;
        ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.fillStyle = "rgba(0,0,0,0.7)"; ctx.fill();
        ctx.lineWidth = 3; ctx.strokeStyle = "#444"; ctx.stroke();
        const start = Math.PI * 0.7; const end = Math.PI * 2.3;
        const pct = clamp(val / max, 0, 1);
        const current = start + (end - start) * pct;
        ctx.beginPath(); ctx.arc(x, y, r - 5, start, current); ctx.strokeStyle = color; ctx.lineWidth = 6; ctx.stroke();
        ctx.fillStyle = "#fff"; ctx.font = "bold 10px Arial"; ctx.textAlign = "center";
        ctx.fillText(label, x, y + 15); ctx.fillText(Math.floor(val), x, y - 5);
    }

    loop() {
        this.update();
        this.draw();
        requestAnimationFrame(() => this.loop());
    }
}

// --- HELPER FOR COLORS ---
const Qt = { lighter: (hex, factor) => hex };

// --- SHOP SYSTEM ---
class ShopSystem {
    constructor() {
        this.prices = {
            drill: [500, 2000, 10000, 50000],
            hull: 200, fuel: 200, cargo: 300, cool: 1000, xray: 2000
        };
    }
    open() { $('shop-modal').classList.add('active'); this.updateUI(); }
    close() { $('shop-modal').classList.remove('active'); }
    
    sellAll() {
        let total = 0;
        const p = Game.localPlayer;
        for (let type in p.inventory) {
            let count = p.inventory[type];
            if (count > 0 && TILE_PROPS[type].value > 0) {
                total += count * TILE_PROPS[type].value;
                p.inventory[type] = 0;
            }
        }
        if (total > 0) {
            p.money += total;
            p.cargo = 0; 
            for(let t in p.inventory) p.cargo += p.inventory[t];
            UI.showToast(`Sold all for $${total}`, "success");
            Sound.playSuccess();
        } else {
            UI.showToast("Nothing valuable to sell.", "normal");
        }
        this.updateUI();
        UI.updateDashboard(); 
    }
    
    sellItem(type, amount) {
        const p = Game.localPlayer;
        if(p.inventory[type] >= amount) {
            let val = TILE_PROPS[type].value * amount;
            p.inventory[type] -= amount;
            p.cargo -= amount;
            p.money += val;
            UI.showToast(`Sold ${amount} ${TILE_PROPS[type].name}`, "success");
            Sound.playSuccess();
            this.updateUI();
            UI.updateDashboard(); 
        }
    }
    
    refuelRepair() {
        const p = Game.localPlayer;
        if(p.money >= 10) {
            p.money -= 10;
            p.fuel = p.maxFuel;
            p.hull = p.maxHull;
            UI.showToast("Refueled & Repaired!", "success");
            Sound.playSuccess();
            this.updateUI();
        } else {
            UI.showToast("Not enough money!", "error");
            Sound.playError();
        }
    }

    updateUI() {
        const p = Game.localPlayer;
        $('shop-money').innerText = "$" + Math.floor(p.money);
        $('shop-color-picker').value = Game.settings.color;
        
        const sellContainer = $('sell-list');
        sellContainer.innerHTML = '';
        let hasItems = false;
        
        Object.keys(p.inventory).forEach(key => {
            let type = parseInt(key);
            let count = p.inventory[type];
            let val = TILE_PROPS[type].value;
            
            if (count > 0 && val > 0) {
                hasItems = true;
                let div = document.createElement('div');
                div.className = 'sell-row';
                div.innerHTML = `
                    <span style="color:${TILE_PROPS[type].color}">${TILE_PROPS[type].name} (x${count})</span>
                    <span style="color:gold">$${val}/ea</span>
                    <div class="sell-actions">
                        <button class="btn" onclick="Shop.sellItem(${type}, 1)">Sell 1</button>
                        <button class="btn" onclick="Shop.sellItem(${type}, ${count})">All</button>
                    </div>
                `;
                sellContainer.appendChild(div);
            }
        });
        
        if(!hasItems) sellContainer.innerHTML = '<div style="padding:10px; color:#555; text-align:center;">No valuable ore to sell.</div>';

        const check = (type, level) => {
            let cost = this.prices[type];
            if(Array.isArray(cost)) cost = cost[level] || 999999;
            else cost = Math.floor(cost * (1 + level));
            $(`cost-${type}`).innerText = "$" + cost;
            $(`btn-${type}`).disabled = p.money < cost;
            if(Array.isArray(this.prices[type]) && !this.prices[type][level]) {
                 $(`cost-${type}`).innerText = "MAX";
                 $(`btn-${type}`).disabled = true;
            }
        };
        check('drill', p.drillTier);
        check('hull', (p.maxHull-100)/20);
        check('fuel', (p.maxFuel-100)/20);
        check('cargo', (p.maxCargo-50)/10);
        check('cool', p.heatResist);
        check('xray', p.xrayRange);
    }
    
    buy(item) {
        const p = Game.localPlayer;
        let cost = 0;
        if (item === 'paint') { if (p.money >= 100) { p.money -= 100; Game.settings.color = $('shop-color-picker').value; UI.showToast("Repainted!", "success"); } }
        else if (item === 'drill') { cost = this.prices.drill[p.drillTier]; if (p.money >= cost) { p.money -= cost; p.drillTier++; UI.showToast("Drill Upgraded!", "success"); Sound.playSuccess(); } }
        else {
            let level = 0;
            if (item === 'hull') level = (p.maxHull-100)/20;
            if (item === 'fuel') level = (p.maxFuel-100)/20;
            if (item === 'cargo') level = (p.maxCargo-50)/10;
            if (item === 'cool') level = p.heatResist;
            if (item === 'xray') level = p.xrayRange;
            cost = Math.floor(this.prices[item] * (1 + level));
            if (p.money >= cost) {
                p.money -= cost;
                if (item === 'hull') { p.maxHull += 20; p.hull = p.maxHull; }
                if (item === 'fuel') { p.maxFuel += 20; p.fuel = p.maxFuel; }
                if (item === 'cargo') p.maxCargo += 10;
                if (item === 'cool') p.heatResist++;
                if (item === 'xray') p.xrayRange++;
                UI.showToast("Upgraded!", "success");
                Sound.playSuccess();
            }
        }
        this.updateUI();
    }
}

// --- NETWORK (MQTT) ---
class NetworkManager {
    constructor() {
        this.client = null;
        this.baseTopic = 'mm_online/';
        this.lastHeartbeat = 0;
    }

    connect() {
        Game.logConnection(`Connecting to broker ${Game.settings.broker}...`);
        
        const broker = Game.settings.broker;
        const options = { clientId: 'mm_' + Game.localPlayer.id, keepalive: 60, clean: true, reconnectPeriod: 1000 };
        try { this.client = mqtt.connect(broker, options); } catch (e) { Game.logConnection("Error creating client: " + e); }

        this.client.on('connect', () => {
            Game.logConnection("Connected. Subscribing...");
            this.client.subscribe(`${this.baseTopic}${Game.settings.room}/#`, (err) => {
                if(!err) {
                    Game.logConnection("Subscribed. Joining room...");
                    this.publish('ctrl', { type: 'join', id: Game.localPlayer.id, username: Game.settings.username, color: Game.settings.color, joinedAt: Game.localPlayer.joinedAt, /*ver: BUILD_TIMESTAMP*/ });
                    Game.finishConnection();
                    Sound.playSuccess();
                    // BROADCAST MOVE immediately so everyone sees new player
                    this.broadcastMove();
                } else {
                    Game.logConnection("Sub Error: " + err);
                }
            });
        });
        
        this.client.on('offline', () => { $('disconnect-msg').style.display = 'block'; });
        this.client.on('reconnect', () => { $('disconnect-msg').style.display = 'none'; });
        this.client.on('message', (topic, message) => this.handleMessage(topic, message));
    }

    update() {
        let n = now();
        Object.keys(Game.remotePlayers).forEach(id => {
            if (n - Game.remotePlayers[id].lastSeen > 10000) {
                const msg = `${Game.remotePlayers[id].username} ${UI.rndMsg('leave')}`;
                UI.addMessage("System", msg, "#888");
                Sound.playChat('leave');
                delete Game.remotePlayers[id];
                UI.updatePlayerList();
                this.updateAdminStatus();
            }
        });
        if (n - this.lastHeartbeat > 2000) {
            this.publish('pos', { type: 'heartbeat', id: Game.localPlayer.id, username: Game.settings.username });
            this.lastHeartbeat = n;
        }
    }

    broadcastMove() {
        const p = Game.localPlayer;
        this.publish('pos', { 
            type: 'move', id: p.id, 
            sx: p.x, sy: p.y, tx: p.gridX * CONSTANTS.TILE_SIZE, ty: p.gridY * CONSTANTS.TILE_SIZE, 
            gx: p.gridX, gy: p.gridY, r: p.rotation, col: Game.settings.color, drill: p.isDrilling,
            username: Game.settings.username
        });
        this.lastHeartbeat = now();
    }

    broadcastDeath() { this.publish('chat', { type: 'death', id: Game.localPlayer.id, name: Game.settings.username }); }
    sendFuel(targetId, amount) { this.publish('ctrl', { type: 'fuel', to: targetId, from: Game.settings.username, amt: amount }); }
    sendTileUpdate(x, y, type) { this.publish('map', { type: 'tile', x, y, val: type, id: Game.localPlayer.id }); }
    sendChat(msg) { this.publish('chat', { type: 'chat', id: Game.localPlayer.id, name: Game.settings.username, msg }); }
    kickUser(id) { this.publish('ctrl', { type: 'kick', target: id }); }
    
    // Add missing Map Request logic
    requestMap(fromId) {
        this.publish('ctrl', { type: 'map_req', from: Game.localPlayer.id, to: fromId });
    }
    
    sendMapDiff(toId) {
        let diffs = [];
        for (let y = 0; y < CONSTANTS.MAP_HEIGHT; y++) {
            for (let x = 0; x < CONSTANTS.MAP_WIDTH; x++) {
                let base = Game.getProceduralTile(x, y);
                // Note: Game.map is the truth. If it differs from procedural base, send it.
                if (Game.map[y][x] !== base) {
                    diffs.push({x, y, v: Game.map[y][x]});
                }
            }
        }
        // Send ALL diffs (simple version)
        if(diffs.length > 0) {
            // chunking
             const CHUNK_SIZE = 100;
             for (let i=0; i<diffs.length; i+=CHUNK_SIZE) {
                 this.publish('map', { type: 'sync', data: diffs.slice(i, i+CHUNK_SIZE), to: toId });
             }
        }
    }
    
    publish(sub, payload) { if (this.client && this.client.connected) this.client.publish(`${this.baseTopic}${Game.settings.room}/${sub}`, JSON.stringify(payload)); }

    handleMessage(topic, message) {
        let msg;
        try { msg = JSON.parse(message.toString()); } catch(e) { return; }
        if (msg.id === Game.localPlayer.id && msg.type !== 'kick') return;

        if (msg.type === 'move' || msg.type === 'heartbeat') {
            if (!Game.remotePlayers[msg.id]) {
                Game.remotePlayers[msg.id] = { 
                    id: msg.id, x: msg.sx || 0, y: msg.sy || 0, targetX: msg.tx, targetY: msg.ty,
                    username: msg.username || "Unknown", color: msg.col || '#fff', lastSeen: now() 
                };
            }
            let rp = Game.remotePlayers[msg.id];
            rp.lastSeen = now();
            if(msg.username && rp.username === "Unknown") rp.username = msg.username;
            
            if (msg.type === 'move') {
                rp.color = msg.col; rp.rotation = msg.r; rp.isDrilling = msg.drill; rp.gridX = msg.gx; rp.gridY = msg.gy;
                rp.targetX = msg.tx; rp.targetY = msg.ty;
                if (Math.abs(rp.x - rp.targetX) > 100 || Math.abs(rp.y - rp.targetY) > 100) { rp.x = rp.targetX; rp.y = rp.targetY; }
            }
        }
        else if (msg.type === 'join') {
            if (Game.bannedIds.includes(msg.id) && Game.isAdmin) this.kickUser(msg.id);
            else {
                // Only show message if we didn't know them before
                if(!Game.remotePlayers[msg.id]) { 
                    UI.addMessage("System", `${msg.username} ${UI.rndMsg('join')}`, "#aaa"); 
                    Sound.playChat('join'); 
                }
                Game.remotePlayers[msg.id] = { 
                    id: msg.id, username: msg.username, color: msg.color, x: 0, y: 0, targetX: 0, targetY: 0, joinedAt: msg.joinedAt, lastSeen: now() 
                };
                UI.updatePlayerList();
                this.updateAdminStatus();
                this.checkAdmin();
                
                // If I am admin, SEND MAP
                if(Game.isAdmin) {
                    this.sendMapDiff(msg.id);
                }
                
                // Reply with MY position so they see me immediately
                this.broadcastMove();
                
            }
        }
        else if (msg.type === 'tile') {
             if (Game.map[msg.y]) { Game.map[msg.y][msg.x] = msg.val; Game.discovered[msg.y][msg.x] = 1; }
        }
        else if (msg.type === 'sync' && msg.to === Game.localPlayer.id) {
            // Apply Map Sync
            msg.data.forEach(d => {
                if (Game.map[d.y]) {
                     Game.map[d.y][d.x] = d.v;
                     // Auto discover synced changes so we can see them on minimap
                     Game.discovered[d.y][d.x] = 1;
                }
            });
            UI.showToast("Map Synced with Host", "success");
        }
        else if (msg.type === 'map_req' && Game.isAdmin) {
            this.sendMapDiff(msg.from);
        }
        else if (msg.type === 'chat') { UI.addMessage(msg.name, msg.msg); Sound.playChat('msg'); }
        else if (msg.type === 'death') { UI.addMessage("System", `${msg.name} ${UI.rndMsg('death')}`, "#f55"); Sound.playChat('death'); }
        else if (msg.type === 'kick') {
            if (msg.target === Game.localPlayer.id) { alert(UI.rndMsg('kick')); location.reload(); }
            else { 
                if(Game.remotePlayers[msg.target]) UI.addMessage("System", `${Game.remotePlayers[msg.target].username} ${UI.rndMsg('kick')}`, "red"); 
                delete Game.remotePlayers[msg.target];
            }
        }
        else if (msg.type === 'fuel' && msg.to === Game.localPlayer.id) {
            Game.localPlayer.fuel = Math.min(Game.localPlayer.maxFuel, Game.localPlayer.fuel + msg.amt);
            UI.showToast(`Received ${msg.amt} Fuel from ${msg.from}`, "success");
            Sound.playSuccess();
            if (Game.localPlayer.fuel < 20) UI.addMessage("System", `${Game.settings.username} ${UI.rndMsg('rescue')}`, "orange");
        }
    }

    checkAdmin() {
        let all = Object.values(Game.remotePlayers).concat([Game.localPlayer]);
        all.sort((a,b) => a.joinedAt - b.joinedAt);
        if (all[0].id === Game.localPlayer.id && !Game.isAdmin) {
            Game.isAdmin = true;
            UI.updateAdminPanel();
        }
    }
}

// --- INPUT ---

class InputManager {
    constructor() { this.keys = {}; this.bindMode = null; }
    init() {
        window.addEventListener('keydown', e => {
            Sound.init(); 
            if (this.bindMode) {
                Game.settings.keys[this.bindMode] = e.key;
                localStorage.setItem('mm_keybinds', JSON.stringify(Game.settings.keys));
                UI.showToast(`Bound ${this.bindMode.toUpperCase()} to ${e.key}`, "success");
                this.bindMode = null;
                UI.refreshKeybindLabels();
                return;
            }
            this.keys[e.key] = true;
            if (e.key === Game.settings.keys.chat && document.activeElement !== $('chat-input')) {
                e.preventDefault();
                $('chat-input').focus();
            }
            if (Object.values(Game.settings.keys).includes(e.key) && e.key !== Game.settings.keys.chat) e.preventDefault();
        });
        window.addEventListener('keyup', e => this.keys[e.key] = false);
        $('chat-input').addEventListener('keydown', e => {
            if (e.key === 'Enter') {
                let val = e.target.value.trim();
                if (val) { 
                    if(val.startsWith('/')) { this.handleCommand(val); }
                    else {
                        // Display own message immediately
                        UI.addMessage(Game.settings.username, val);
                        Network.sendChat(val);
                    }
                    e.target.value = ""; 
                }
                e.target.blur();
                $('gameCanvas').focus();
            }
            e.stopPropagation();
        });
    }
    
    handleCommand(cmd) {
        let parts = cmd.split(' ');
        if (parts[0] === '/tp' && Game.isAdmin) {
            if (parts.length === 3) {
                let x = parseInt(parts[1]); let y = parseInt(parts[2]);
                if (!isNaN(x) && !isNaN(y)) {
                    Game.localPlayer.gridX = x; Game.localPlayer.gridY = y;
                    Game.localPlayer.x = x * CONSTANTS.TILE_SIZE; Game.localPlayer.y = y * CONSTANTS.TILE_SIZE;
                    UI.showToast(`Teleported to ${x}, ${y}`, "success");
                    Network.broadcastMove();
                }
            } else if (parts.length === 2) {
                let target = Object.values(Game.remotePlayers).find(p => p.username === parts[1]);
                if (target) {
                    Game.localPlayer.gridX = target.gridX; Game.localPlayer.gridY = target.gridY;
                    Game.localPlayer.x = target.x; Game.localPlayer.y = target.y;
                    UI.showToast(`Teleported to ${target.username}`, "success");
                    Network.broadcastMove();
                } else UI.showToast("Player not found", "error");
            }
        } else {
            UI.showToast("Unknown command or not admin", "error");
        }
    }

    startBind(action) { this.bindMode = action; UI.refreshKeybindLabels(); }
}

// --- UI & SAVES ---

class UIManager {
    rndMsg(type) { const arr = MSGS[type]; return arr[Math.floor(Math.random() * arr.length)]; }
    addMessage(name, text, color='#fff') {
        const div = document.createElement('div');
        div.innerHTML = `<span style="color:${color}; font-weight:bold;">${name}:</span> ${text}`;
        $('chat-messages').appendChild(div);
        $('chat-messages').scrollTop = $('chat-messages').scrollHeight;
    }
    showToast(msg, type='normal',timeout=4000) {
        const area = $('notification-area');
        const el = document.createElement('div');
        el.className = `toast ${type}`;
        el.innerText = msg;
        area.appendChild(el);
        setTimeout(() => el.remove(), timeout);
    }
    openSettings() { 
        $('settings-modal').classList.add('active'); 
        this.refreshKeybindLabels(); 
        this.renderSaveSlots();
    }
    closeSettings() { $('settings-modal').classList.remove('active'); }
    refreshKeybindLabels() {
        const keys = Game.settings.keys;
        const map = { up: 'btn-bind-up', down: 'btn-bind-down', left: 'btn-bind-left', right: 'btn-bind-right', build: 'btn-bind-build', interact: 'btn-bind-interact', transfer: 'btn-bind-transfer', chat: 'btn-bind-chat' };
        for (let action in map) {
            let btn = $(map[action]);
            if (Input.bindMode === action) { btn.classList.add('binding'); btn.innerText = `PRESS KEY...`; } 
            else { btn.classList.remove('binding'); btn.innerText = `${action.toUpperCase()}: ${keys[action]}`; }
        }
    }
    
    checkServers() {
        const list = $('server-list');
        const display = $('server-status-display');
        display.style.display = 'block';
        display.innerHTML = 'Checking servers...';
        
        let promises = [];
        Array.from(list.options).forEach(opt => {
            const url = opt.value;
            const p = new Promise(resolve => {
                try {
                    const client = mqtt.connect(url, { connectTimeout: 2000, reconnectPeriod: 0 });
                    client.on('connect', () => { client.end(); resolve({url, status: true}); });
                    client.on('error', () => { client.end(); resolve({url, status: false}); });
                    setTimeout(() => { if(!client.connected){ client.end(); resolve({url, status: false}); } }, 2500);
                } catch(e) { resolve({url, status: false}); }
            });
            promises.push(p);
        });
        
        Promise.all(promises).then(results => {
            display.innerHTML = '';
            results.forEach(res => {
                const div = document.createElement('div');
                div.className = 'server-option';
                div.innerHTML = `<span class="status-dot ${res.status ? 'green':'red'}"></span> ${res.url}`;
                display.appendChild(div);
            });
        });
    }
    async checkForUpdates() {
        try {
            if (!initialTimestamp) {
                const url = new URL(window.location.href);
                url.searchParams.set('_t', Date.now());
                const headRes = await fetch(url.toString(), { method: 'HEAD' });
                initialTimestamp = headRes.headers.get('last-modified');
                console.log("current version is :", initialTimestamp);
            }else{
                const url = new URL(window.location.href);
                url.searchParams.set('_t', Date.now());
                const headRes = await fetch(url.toString(), { method: 'HEAD' });
                const currentTimestamp = headRes.headers.get('last-modified');
                
                if (currentTimestamp && currentTimestamp !== initialTimestamp) {
                    UI.showToast("New Version Available!", "normal");
                    UI.addMessage("System", `Update detected! (${currentTimestamp}) Please save and refresh.`, "#0f0", 9999999);
                }
            }
        } catch (e) { console.error('Update check error:', e); }
    }

    toggleDashboard() {
        const dash = $('dashboard-modal');
        if (dash.classList.contains('active')) {
            dash.classList.remove('active');
        } else {
            dash.classList.add('active');
            this.updateDashboard();
        }
    }

    updateDashboard() {
        const p = Game.localPlayer;
        // Inventory
        const grid = $('inv-grid');
        grid.innerHTML = '';
        
        let types = Object.keys(p.inventory).map(Number).sort((a,b) => a-b);
        if(p.inventory[TILE_TYPES.CASING] === undefined) p.inventory[TILE_TYPES.CASING] = 0;
        if(!types.includes(TILE_TYPES.CASING)) types.push(TILE_TYPES.CASING);

        types.forEach(type => {
            let count = p.inventory[type] || 0;
            if (count > 0 || type === TILE_TYPES.CASING) {
                let div = document.createElement('div');
                div.className = `inv-item ${p.selectedBlock == type ? 'active' : ''}`;
                div.style.color = TILE_PROPS[type].color || '#fff';
                div.innerHTML = `
                    ${TILE_PROPS[type].name}<span class="inv-count">${count}</span>
                    <div class="inv-trash" onclick="event.stopPropagation(); Game.trashBlock(${type})">x</div>
                `;
                if(p.selectedBlock == type) {
                    div.innerHTML += '<div style="font-size:8px; color:#2ecc71;">[EQUIPPED]</div>';
                }
                div.onclick = () => { p.selectedBlock = parseInt(type); UI.updateDashboard(); Sound.playTone(400, 'sine', 0.05); };
                grid.appendChild(div);
            }
        });

        // Stats
        let elapsed = Math.floor((now() - p.stats.startTime) / 1000);
        let mins = Math.floor(elapsed / 60);
        let secs = elapsed % 60;
        let html = `
            <div class="stat-row"><span>Time Played:</span><span>${mins}m ${secs}s</span></div>
            <div class="stat-row"><span>Total Blocks Mined:</span><span>${p.stats.totalMined}</span></div>
            <div class="stat-row"><span>Max Depth Reached:</span><span>${Math.floor(Math.max(0, p.gridY-5))}m</span></div>
        `;
        let sorted = Object.keys(p.stats.blocksMined).sort((a,b) => p.stats.blocksMined[b] - p.stats.blocksMined[a]).slice(0,3);
        sorted.forEach(t => {
            html += `<div class="stat-row"><span>${TILE_PROPS[t].name}:</span><span>${p.stats.blocksMined[t]}</span></div>`;
        });
        $('stats-container').innerHTML = html;

        // Leaderboard
        let players = Object.values(Game.remotePlayers).concat(p);
        players.forEach(pl => pl.score = Math.floor((pl.gridY || 0) + (pl.money||0)/10)); 
        players.sort((a,b) => b.score - a.score);
        
        let lbHtml = "";
        players.forEach((pl, i) => {
            // Show ID if username missing
            const name = pl.username || `ID: ${pl.id.substr(0,5)}`;
            lbHtml += `<div class="stat-row"><span>${i+1}. ${name}</span><span>${pl.score} pts</span></div>`;
        });
        $('leaderboard-container').innerHTML = lbHtml;

        $('station-btn-container').style.display = (p.gridY === Game.stationGridY && Math.abs(p.gridX - Game.stationGridX) < 2) ? 'block' : 'none';
    }

    updatePlayerList() {
        if (!Game.isAdmin) return;
        $('admin-panel').style.display = 'block';
        const list = $('player-list');
        list.innerHTML = '';
        Object.values(Game.remotePlayers).forEach(p => {
            const row = document.createElement('div');
            row.className = 'player-row';
            row.innerHTML = `<span>${p.username}</span><div><button class="btn btn-small btn-danger" onclick="Admin.kick('${p.id}')">K</button></div>`;
            list.appendChild(row);
        });
    }
    updateAdminPanel() { this.updatePlayerList(); }
    
    renderSaveSlots() {
        const container = $('save-slots-container');
        container.innerHTML = '';
        const isHost = Game.isAdmin;
        SaveSystem.slots.forEach((slot, i) => {
            const div = document.createElement('div');
            div.className = 'save-slot';
            const dateStr = slot ? new Date(slot.timestamp).toLocaleString() : 'Empty';
            const nameStr = slot ? slot.name : `Slot ${i+1}`;
            const disabled = !isHost ? 'disabled' : '';
            const disabledText = !isHost ? ' (Host Only)' : '';
            div.innerHTML = `
                <div class="save-slot-info">
                    <strong>${nameStr}${disabledText}</strong><br>
                    <span style="font-size:10px; color:#999">${dateStr}</span>
                </div>
                <div class="save-slot-actions">
                    <button class="btn btn-small" ${disabled} onclick="SaveSystem.saveToSlot(${i})">Save</button>
                    <button class="btn btn-small" ${!slot || disabled ? 'disabled' : ''} onclick="SaveSystem.loadFromSlot(${i})">Load</button>
                    <button class="btn btn-small btn-danger" ${!slot || disabled ? 'disabled' : ''} onclick="SaveSystem.deleteSlot(${i})">Del</button>
                    <button class="btn btn-small" style="background:#444;" ${!slot || disabled ? 'disabled' : ''} onclick="SaveSystem.exportSlot(${i})">Export</button>
                </div>
            `;
            container.appendChild(div);
        });
        $('autosave-toggle').checked = SaveSystem.autosaveEnabled;
        $('autosave-toggle').disabled = !isHost;
    }
}

class AdminSystem { kick(id) { Network.kickUser(id); delete Game.remotePlayers[id]; UI.updatePlayerList(); } }

class SaveSystem {
    static autosaveEnabled = true;
    static slots = [null, null, null]; 
    static db = null;
    static dbPromise = null;

    static async initDB() {
        if (!this.dbPromise) {
            this.dbPromise = new Promise((resolve, reject) => {
                const request = indexedDB.open("MegaMinerDB", 1);
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains("saves")) {
                        db.createObjectStore("saves", { keyPath: "id" });
                    }
                };
                request.onsuccess = (event) => {
                    resolve(event.target.result);
                };
                request.onerror = (event) => {
                    console.error("IndexedDB initialization failed", event);
                    reject(event);
                };
            });
        }
        this.db = await this.dbPromise;
    }

    static init() {
        for(let i=0; i<3; i++) {
            const meta = localStorage.getItem(`mm_save_meta_${i+1}`);
            if(meta) this.slots[i] = JSON.parse(meta);
        }
        const as = localStorage.getItem('mm_autosave_setting');
        if(as !== null) this.autosaveEnabled = (as === 'true');
    }

    static toggleAutosave(val) {
        this.autosaveEnabled = val;
        localStorage.setItem('mm_autosave_setting', val);
    }
    
    static saveAndReload() {
        this.saveToSlot(currentSaveId/*, true*/);
        location.reload();
    }

    static async saveToSlot(i, isAuto = false) {
        try {
            await this.initDB();

            const cleanPlayer = JSON.parse(JSON.stringify(Game.localPlayer));
            const cleanMap = JSON.parse(JSON.stringify(Game.map));
            const cleanDiscovered = Game.discovered.map(r => Array.from(r));

            const data = {
                id: i + 1,
                player: cleanPlayer,
                map: cleanMap,
                discovered: cleanDiscovered,
                banned: Game.bannedIds,
                timestamp: Date.now()
            };

            const meta = {
                timestamp: Date.now(),
                name: isAuto ? `Autosave (Slot ${i + 1})` : `Save ${i + 1}`
            };

            await new Promise((resolve, reject) => {
                const tx = this.db.transaction(["saves"], "readwrite");
                const store = tx.objectStore("saves");

                const req = store.put(data);

                req.onsuccess = () => resolve();
                req.onerror = (e) => reject(e);
            });

            // Save metadata (small, safe)
            this.slots[i] = meta;
            localStorage.setItem(`mm_save_meta_${i+1}`, JSON.stringify(meta));

            if (!isAuto) {
                UI.renderSaveSlots();
                UI.showToast(`Saved to Slot ${i + 1}`, "success");
            }

        } catch (e) {
            console.error("Error during saveToSlot", e);
            if (!isAuto) UI.showToast("Save Failed", "error");
        }
    }

    static async loadFromSlot(i) {
        await this.initDB();
        const id = i + 1;

        try {
            const data = await new Promise((resolve, reject) => {
                const tx = this.db.transaction(["saves"], "readonly");
                const store = tx.objectStore("saves");
                const req = store.get(id);

                req.onsuccess = () => resolve(req.result);
                req.onerror = (e) => reject(e);
            });

            if (!data) {
                UI.showToast("No save data in this slot", "error");
                return;
            }

            this.restoreData(data);
            UI.closeSettings();

        } catch (e) {
            UI.showToast("Failed to load save", "error");
            console.error(e);
        }
    }


    static async deleteSlot(i) {
        await this.initDB();
        const id = i + 1;
        try {
            const transaction = this.db.transaction(["saves"], "readwrite");
            const store = transaction.objectStore("saves");
            store.delete(id);
            this.slots[i] = null;
            UI.renderSaveSlots();
        } catch (e) {
            UI.showToast("Failed to delete save", "error");
            console.error(e);
        }
    }

    static async exportSlot(i) {
        await this.initDB();
        const id = i + 1;
        try {
            const transaction = this.db.transaction(["saves"], "readonly");
            const store = transaction.objectStore("saves");
            const request = store.get(id);
            request.onsuccess = (event) => {
                const data = event.target.result;
                if (data) {
                    const blob = new Blob([JSON.stringify(data)], { type: "application/json" });
                    const a = document.createElement("a");
                    a.href = URL.createObjectURL(blob);
                    a.download = `mm_save_slot_${id}.json`;
                    a.click();
                    UI.showToast(`Exported Slot ${id}`, "success");
                } else {
                    UI.showToast("No save data in this slot", "error");
                }
            };
            request.onerror = () => {
                UI.showToast("Export Failed", "error");
            };
        } catch (e) {
            UI.showToast("Export Failed", "error");
            console.error(e);
        }
    }

    static exportSave() {
        const data = { player: Game.localPlayer, map: Game.map, discovered: Array.from(Game.discovered).map(r => Array.from(r)), banned: Game.bannedIds };
        const blob = new Blob([JSON.stringify(data)], {type: 'application/json'});
        const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = `mm_save.json`; a.click();
    }

    static importSave(input) {
        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const data = JSON.parse(e.target.result);
                this.restoreData(data);
            } catch(e) { UI.showToast("Invalid File", "error"); }
        };
        if(input.files[0]) reader.readAsText(input.files[0]);
    }

    static restoreData(data) {
        if(data.player) Game.localPlayer = {...Game.localPlayer, ...data.player};
        if(data.map) Game.map = data.map;
        if(data.discovered) Game.discovered = data.discovered.map(r => new Uint8Array(r));
        if(data.banned) Game.bannedIds = data.banned;
        UI.showToast("Game Loaded!", "success");
    }
}

function generateCreditsHTML(data) {
    let html = "";

    for (const category in data) {
        html += `<div class="credits-section">`;
        html += `<h3>${category.replace(/([A-Z])/g, " $1").toUpperCase()}</h3>`;

        const section = data[category];

        // Simple string list (e.g., specialThanks)
        if (Array.isArray(section) && typeof section[0] === "string") {
            html += `<div class="credit-entry">`;
            html += `<ul class="simple-list">`;
            section.forEach(item => html += `<li>${item}</li>`);
            html += `</ul>`;
            html += `</div>`;
            continue;
        }

        // Object list (music, sfx, pictures, etc.)
        section.forEach(entry => {
            const key = Object.keys(entry)[0];
            const name = entry[key];
            const items = entry.items || entry.songs || [];

            html += `<div class="credit-entry">`;
            html += `<strong>${name}</strong>`;
            if (items.length > 0) {
                html += `<ul>`;
                items.forEach(i => html += `<li>${i}</li>`);
                html += `</ul>`;
            }
            html += `</div>`;
        });

        html += `</div>`;
    }

    return html;
}

// --- INSTANTIATION ---
const Game = new GameEngine();
const Input = new InputManager();
const Network = new NetworkManager();
const UI = new UIManager();
const Admin = new AdminSystem();
const Shop = new ShopSystem();

// Init Save System
SaveSystem.init();

// Expose
window.Game = Game;
window.UI = UI;
window.SaveSystem = SaveSystem;
window.Admin = Admin;
window.Shop = Shop;
window.Input = Input;
window.Sound = Sound;
//patrickdearteaga.com, 
const creditsData = {
    music: [
        {
            artist: "Patrick de Arteaga",
            songs: ["Chiptronical","Great Little Challenge", "Solve The Puzzle"]
        },
        {
            artist: "Kevin Macleod",
            songs: ["Sneaky Snitch"]
        },
        {
            artist: "VibeHorn (Pixabay)",
            songs: ["Cozy Lofi Relax"]
        },
        {
            artist: "DELOSound (Pixabay)",
            songs: ["LoFi Background Music 3"]
        },
        {
            artist: "CFL_TurningPages (Pixabay)",
            songs: ["Field Duel lofi"]
        }
    ],

    // pictures: [
    //     // { author: "Jane Doe", items: ["Sky texture", "Moon texture"] },
    // ],

    // sfx: [
    //     // { source: "Jane Doe", items: ["Footsteps", "Door creak"] },
    // ],

    specialThanks: [
        "My friends",
        "Playtesters",
        "Contributors",
        "The laptops that were sacrificed in the making of this game"
    ]
};
//J ANK AUDIO FIX
Sound.loadSettings()
// bruh
document.getElementById('credits').innerHTML = generateCreditsHTML(creditsData);
</script>
</body>
</html>
<!-- If the original devs of megaminer are reading this, I would love to hear your feedback! -->
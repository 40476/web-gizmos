<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>microViz</title>
    <style>
        :root { --bg: #1a1a1a; --accent: #00ff9d; }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: var(--bg); color: white; font-family: monospace; }
        .container { max-width: 800px; margin: 0 auto; padding: 1rem; }
        
        #visualizer-container { 
            height: 70vh; 
            border: 2px solid var(--accent);
            margin: 1rem 0;
            background: #000;
        }
        
        .controls { 
            display: grid; 
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 1rem;
            padding: 1rem 0;
        }
        
        input[type="range"], input[type="color"] { width: 100%; }
        button, input[type="file"] { padding: 0.5rem; background: #333; color: white; border: 1px solid #555; }
    </style>
</head>
<body onclick="var interacted=true">
    <div class="container">
        <input type="file" id="audio-upload" accept="audio/*">
        <button id="play-toggle">▶ Play</button>
        <select id="visualizer-select">
            <option value="bars">Frequency Bars</option>
            <option value="waveform">Waveform</option>
            <option value="circular">Circular Spectrum</option>
            <option value="particles">Audio Particles</option>
        </select>
        
        <canvas id="visualizer-container"></canvas>
        
        <div class="controls" id="controls-container"></div>
    </div>

    <script>
        // Configuration (auto-saved to localStorage)
        const CONFIG = JSON.parse(localStorage.getItem('audioVisConfig')) || {
            visualizer: 'bars',
            barCount: 128,
            fftSize: 2048,
            color: '#00ff9d',
            sensitivity: 1,
            particleCount: 100,
            lineWidth: 2
        };

        // Core elements
        const canvas = document.getElementById('visualizer-container');
        const ctx = canvas.getContext('2d');
        const audioUpload = document.getElementById('audio-upload');
        const playToggle = document.getElementById('play-toggle');
        const visualizerSelect = document.getElementById('visualizer-select');
        const controlsContainer = document.getElementById('controls-container');
        let audioContextInitialized = false;
        let audioElement = null;
        let audioContext, analyser, source, isPlaying = false;
        let audioData = new Uint8Array();

        // Init Web Audio
        async function initAudio() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                if (audioContext.state === 'suspended') {
                    await audioContext.resume();
                }
                
                analyser = audioContext.createAnalyser();
                analyser.fftSize = CONFIG.fftSize;
                audioData = new Uint8Array(analyser.frequencyBinCount);
            }
        }

        // Visualizers
        const visualizers = {
            bars: {
                settings: [
                    { id: 'barCount', type: 'range', label: 'Bar Count', min: 16, max: 256, step: 1 },
                    { id: 'color', type: 'color', label: 'Color' }
                ],
                draw: () => {
                    const barWidth = canvas.width / CONFIG.barCount;
                    ctx.fillStyle = CONFIG.color;
                    
                    for (let i = 0; i < CONFIG.barCount; i++) {
                        const value = audioData[i];
                        const barHeight = (value / 255) * canvas.height * CONFIG.sensitivity;
                        const x = i * barWidth;
                        const y = canvas.height - barHeight;
                        
                        ctx.fillRect(x, y, barWidth - 2, barHeight);
                    }
                }
            },

            waveform: {
                settings: [
                    { id: 'lineWidth', type: 'range', label: 'Line Width', min: 1, max: 10 },
                    { id: 'color', type: 'color', label: 'Color' }
                ],
                draw: () => {
                    ctx.lineWidth = CONFIG.lineWidth;
                    ctx.strokeStyle = CONFIG.color;
                    ctx.beginPath();
                    
                    const sliceWidth = canvas.width / audioData.length;
                    let x = 0;
                    
                    for (let i = 0; i < audioData.length; i++) {
                        const v = audioData[i] / 128.0;
                        const y = v * canvas.height / 2;
                        
                        if (i === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                        
                        x += sliceWidth;
                    }
                    
                    ctx.lineTo(canvas.width, canvas.height / 2);
                    ctx.stroke();
                }
            },

            circular: {
                settings: [
                    { id: 'barCount', type: 'range', label: 'Bar Count', min: 16, max: 256, step: 1 },
                    { id: 'color', type: 'color', label: 'Color' }
                ],
                draw: () => {
                    const centerX = canvas.width / 2;
                    const centerY = canvas.height / 2;
                    const radius = Math.min(canvas.width, canvas.height) * 0.25;
                    
                    ctx.strokeStyle = CONFIG.color;
                    ctx.lineWidth = 3;
                    
                    for (let i = 0; i < CONFIG.barCount; i++) {
                        const value = audioData[i];
                        const length = (value / 255) * radius * CONFIG.sensitivity;
                        const angle = (i * 2 * Math.PI) / CONFIG.barCount;
                        
                        const x1 = centerX + Math.cos(angle) * radius;
                        const y1 = centerY + Math.sin(angle) * radius;
                        const x2 = centerX + Math.cos(angle) * (radius + length);
                        const y2 = centerY + Math.sin(angle) * (radius + length);
                        
                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x2, y2);
                        ctx.stroke();
                    }
                }
            },

            particles: {
                settings: [
                    { id: 'particleCount', type: 'range', label: 'Particles', min: 10, max: 500, step: 1 },
                    { id: 'color', type: 'color', label: 'Color' }
                ],
                draw: () => {
                    const particles = Array(CONFIG.particleCount).fill().map((_, i) => ({
                        x: Math.random() * canvas.width,
                        y: Math.random() * canvas.height,
                        speed: 0.5 + Math.random() * 2,
                        angle: Math.random() * Math.PI * 2
                    }));
                    
                    ctx.fillStyle = CONFIG.color;
                    
                    analyser.getByteTimeDomainData(audioData);
                    const average = audioData.reduce((a, b) => a + b, 0) / audioData.length;
                    const intensity = (average - 128) / 128 * CONFIG.sensitivity;
                    
                    particles.forEach(p => {
                        p.x += Math.cos(p.angle) * p.speed * (intensity + 1);
                        p.y += Math.sin(p.angle) * p.speed * (intensity + 1);
                        
                        if (p.x < 0 || p.x > canvas.width) p.angle = Math.PI - p.angle;
                        if (p.y < 0 || p.y > canvas.height) p.angle = -p.angle;
                        
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, 2 * (intensity + 1), 0, Math.PI * 2);
                        ctx.fill();
                    });
                }
            }
        };

        // UI & Control Handling
        function renderControls() {
            controlsContainer.innerHTML = '';
            const currentVis = visualizers[CONFIG.visualizer];
            
            currentVis.settings.forEach(setting => {
                const wrapper = document.createElement('div');
                wrapper.innerHTML = `
                    <label>${setting.label}</label>
                    <input type="${setting.type}" id="${setting.id}" 
                           ${setting.min ? `min="${setting.min}"` : ''}
                           ${setting.max ? `max="${setting.max}"` : ''}
                           ${setting.step ? `step="${setting.step}"` : ''}>
                `;
                const input = wrapper.querySelector('input');
                
                if (setting.type === 'color') {
                    input.value = CONFIG[setting.id];
                } else {
                    input.value = CONFIG[setting.id];
                }
                
                input.addEventListener('input', e => {
                    CONFIG[setting.id] = setting.type === 'range' ? 
                        parseFloat(e.target.value) : e.target.value;
                    saveConfig();
                });
                
                controlsContainer.appendChild(wrapper);
            });
        }

        function saveConfig() {
            localStorage.setItem('audioVisConfig', JSON.stringify(CONFIG));
        }

        // Audio Processing Loop
        function draw() {
            if (!isPlaying) return;
            
            analyser.getByteFrequencyData(audioData);
            
            ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            visualizers[CONFIG.visualizer].draw();
            
            requestAnimationFrame(draw);
        }

        // Event Handlers
        audioUpload.addEventListener('change', async (e) => {
            
              const file = e.target.files[0];
              if (!file) return;
              
              await initAudio();
              
              if (source) source.disconnect();
              
              const url = URL.createObjectURL(file);
              audioElement = new Audio(url);
              source = audioContext.createMediaElementSource(audioElement);
              
              source.connect(analyser);
              analyser.connect(audioContext.destination);
              
              try {
                  await audioElement.play();
                  isPlaying = true;
                  playToggle.textContent = '⏸ Pause';
                  draw();
              } catch (err) {
                  console.error('Playback failed:', err);
              }
            
        });

        playToggle.addEventListener('click', async () => {
            if (!audioElement) return;
            
            if (audioContext.state !== 'running') {
                await audioContext.resume();
            }
            
            if (isPlaying) {
                audioElement.pause();
            } else {
                await audioElement.play();
            }
            
            isPlaying = !isPlaying;
            playToggle.textContent = isPlaying ? '⏸ Pause' : '▶ Play';
            
            if (isPlaying) draw();
        });

        visualizerSelect.addEventListener('change', e => {
            CONFIG.visualizer = e.target.value;
            saveConfig();
            renderControls();
        });

        // Resize Handling
        window.addEventListener('resize', () => {
            canvas.width = canvas.clientWidth;
            canvas.height = canvas.clientHeight;
        });

        // Init
        function init() {
            visualizerSelect.value = CONFIG.visualizer;
            canvas.width = canvas.clientWidth;
            canvas.height = canvas.clientHeight;
            
            renderControls();
        }

        init();
    </script>
</body>
</html>
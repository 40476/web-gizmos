<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>DRiFT.js</title>
    <!-- MQTT Library -->
    <script src="https://unpkg.com/mqtt/dist/mqtt.min.js"></script>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Roboto:wght@300;400;700&display=swap');

        :root {
            --neon-blue: #00f3ff;
            --neon-pink: #ff00ff;
            --bg-dark: #0a0a0f;
            --panel-bg: rgba(16, 20, 30, 0.95);
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--bg-dark);
            font-family: 'Roboto', sans-serif;
            color: white;
            user-select: none;
            touch-action: none;
        }

        canvas {
            display: block;
            image-rendering: pixelated; 
        }

        .scanlines {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(to bottom, rgba(255,255,255,0), rgba(255,255,255,0) 50%, rgba(0,0,0,0.1) 50%, rgba(0,0,0,0.1));
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 100;
        }

        #ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .interactive {
            pointer-events: auto;
        }

        /* Update Notification */
        #update-notification {
            display: none;
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 255, 0, 0.2);
            border: 1px solid #0f0;
            color: #0f0;
            padding: 10px 20px;
            font-family: 'Orbitron', sans-serif;
            cursor: pointer;
            z-index: 100;
            text-shadow: 0 0 5px #0f0;
            animation: pulse-green 2s infinite;
        }
        #update-notification:hover { background: rgba(0, 255, 0, 0.4); }
        @keyframes pulse-green { 0% { box-shadow: 0 0 5px #0f0; } 50% { box-shadow: 0 0 20px #0f0; } 100% { box-shadow: 0 0 5px #0f0; } }

        /* Mobile Controls */
        #mobile-controls {
            display: none;
            position: absolute;
            bottom: 20px;
            width: 100%;
            height: 150px;
            pointer-events: none;
            z-index: 200;
            padding: 0 20px;
            justify-content: space-between;
        }
        
        @media (hover: none) and (pointer: coarse) {
            #mobile-controls { display: flex; }
            #chat-container { bottom: 180px; width: 200px; height: 150px; }
        }

        .touch-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            width: 70px;
            height: 70px;
            pointer-events: auto;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            user-select: none;
            backdrop-filter: blur(2px);
        }
        .touch-btn:active { background: rgba(0, 243, 255, 0.3); border-color: var(--neon-blue); }
        .touch-group { display: flex; gap: 15px; align-items: flex-end; }
        .touch-rect { width: 60px; height: 90px; border-radius: 10px; }

        /* Main Menu */
        #main-menu {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 50;
            backdrop-filter: blur(5px);
        }

        .panel {
            background: var(--panel-bg);
            border: 1px solid var(--neon-blue);
            box-shadow: 0 0 20px rgba(0, 243, 255, 0.2);
            padding: 2rem;
            border-radius: 8px;
            width: 400px;
            max-width: 90%;
            text-align: center;
            max-height: 90vh;
            overflow-y: auto;
        }

        h1 {
            font-family: 'Orbitron', sans-serif;
            color: var(--neon-blue);
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 1.5rem;
            text-shadow: 0 0 10px var(--neon-blue);
        }

        input[type="text"], input[type="number"], input[type="color"], select {
            background: #1a1a24;
            border: 1px solid #333;
            color: white;
            padding: 10px;
            width: 100%;
            margin-bottom: 1rem;
            font-family: 'Orbitron', sans-serif;
            border-radius: 4px;
        }
        
        input[type="range"] {
            width: 100%;
            margin: 10px 0;
            background: #333;
            height: 6px;
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: var(--neon-blue);
            border-radius: 50%;
            cursor: pointer;
        }

        input[type="color"] { height: 50px; cursor: pointer; }

        button {
            background: linear-gradient(45deg, var(--neon-blue), #00aaff);
            border: none;
            color: black;
            padding: 12px 24px;
            font-weight: bold;
            font-family: 'Orbitron', sans-serif;
            cursor: pointer;
            width: 100%;
            transition: transform 0.1s, box-shadow 0.1s;
            border-radius: 4px;
            text-transform: uppercase;
        }
        button:hover { transform: translateY(-2px); box-shadow: 0 0 15px var(--neon-blue); }
        button.secondary { background: transparent; border: 1px solid var(--neon-pink); color: var(--neon-pink); margin-top: 10px; }
        button.secondary:hover { box-shadow: 0 0 15px var(--neon-pink); background: rgba(255, 0, 255, 0.1); }

        /* Keybind Grid */
        .keybind-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 15px;
            text-align: left;
        }
        .keybind-btn {
            background: #222;
            border: 1px solid #444;
            color: var(--neon-blue);
            padding: 5px;
            font-size: 0.8rem;
            text-align: center;
            cursor: pointer;
        }
        .keybind-btn:hover { background: #333; border-color: var(--neon-blue); }
        .keybind-btn.recording { background: var(--neon-pink); color: black; border-color: white; animation: pulse 0.5s infinite alternate; }
        @keyframes pulse { from { opacity: 1; } to { opacity: 0.7; } }

        #hud {
            padding: 20px;
            display: flex;
            justify-content: space-between;
            font-family: 'Orbitron', sans-serif;
            text-shadow: 1px 1px 0 #000;
        }
        
        #editor-ui {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--panel-bg);
            padding: 10px;
            border: 1px solid var(--neon-pink);
            display: none;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            border-radius: 8px;
            max-width: 90%;
            z-index: 60;
        }

        .tool-btn {
            width: 40px; height: 40px;
            border: 1px solid #555; background: #222; color: white;
            cursor: pointer; display: flex; align-items: center; justify-content: center;
            font-size: 1.2rem; transition: all 0.2s;
        }
        .tool-btn:hover { background: #333; }
        .tool-btn.active { border-color: var(--neon-blue); background: rgba(0, 243, 255, 0.2); transform: scale(1.1); }

        .editor-input-group { display: flex; align-items: center; gap: 5px; }
        .editor-input-group input { width: 60px; margin: 0; padding: 5px; font-size: 12px; text-align: center; }

        #chat-container {
            position: absolute; bottom: 20px; left: 20px; width: 300px; height: 250px;
            background: rgba(0, 0, 0, 0.6); border: 1px solid #333;
            display: flex; flex-direction: column; pointer-events: auto; border-radius: 4px;
            z-index: 40;
        }
        #chat-messages { flex: 1; overflow-y: auto; padding: 10px; font-size: 0.85rem; color: #ddd; }
        .chat-msg { margin-bottom: 4px; word-wrap: break-word; }
        .sys-msg { color: var(--neon-blue); font-style: italic; }
        .err-msg { color: var(--neon-pink); }
        #chat-input { background: rgba(0,0,0,0.8); border: none; border-top: 1px solid #333; color: white; padding: 8px; outline: none; }

        #right-panel {
            position: absolute; bottom: 20px; right: 20px;
            display: flex; flex-direction: column; gap: 10px; align-items: flex-end;
            z-index: 40;
        }
        #leaderboard {
            background: rgba(0,0,0,0.7); border: 1px solid var(--neon-blue); padding: 10px;
            width: 200px; font-size: 12px; color: white; font-family: 'Orbitron', sans-serif;
        }
        .lb-row { display: flex; justify-content: space-between; margin-bottom: 4px; }
        .lb-name { color: #ddd; }
        .lb-laps { color: var(--neon-blue); font-weight: bold; }
        .lb-admin { color: gold; margin-left: 4px; }
        #minimap-container { border: 2px solid var(--neon-blue); background: rgba(0,0,0,0.8); width: 200px; height: 200px; }
        #minimap-canvas { width: 100%; height: 100%; display: block; }

        #maps-modal, #settings-modal { display: none; }
        
        #quit-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(255, 0, 0, 0.3); pointer-events: none; display: none;
            align-items: center; justify-content: center; z-index: 200;
            font-family: 'Orbitron', sans-serif; font-size: 2rem; color: white; text-shadow: 0 0 10px red;
        }

        /* Tabs */
        .tabs { display: flex; border-bottom: 1px solid #444; margin-bottom: 10px; }
        .tab { flex: 1; padding: 10px; cursor: pointer; text-align: center; font-size: 0.8rem; background: #222; color: #888; }
        .tab.active { background: #333; color: var(--neon-blue); border-bottom: 2px solid var(--neon-blue); }
        .tab-content { display: none; }
        .tab-content.active { display: block; }
    </style>
</head>
<body>

    <div class="scanlines"></div>
    <div id="quit-overlay">DISCONNECTING...</div>

    <div id="ui-layer">
        <!-- Main Menu -->
        <div id="main-menu" class="interactive">
            <div class="panel">
                <h1>DRiFT.js</h1>
                <input type="text" id="username" placeholder="Racer Name" maxlength="12">
                <input type="text" id="room-name" placeholder="Room Name (e.g. cat)" value="lobby">
                <div class="text-left text-sm text-gray-400 mb-2">Car Color</div>
                <input type="color" id="car-color" value="#00f3ff">
                <button onclick="startGame()">Connect & Race</button>
                <button class="secondary text-xs" onclick="openSettings()">Settings & Network</button>
                <div id="connection-status" class="mt-2 text-xs text-gray-500">Public MQTT (HiveMQ Default)</div>
            </div>
        </div>

        <div id="update-notification" class="interactive" onclick="location.reload()">
            New Update Available! Click to Reload.
        </div>

        <!-- HUD -->
        <div id="hud">
            <div>
                <div class="text-xl" style="color: var(--neon-blue)">SPEED: <span id="speed-display">0</span> KM/H</div>
                <div class="text-sm text-gray-400">POS: <span id="pos-display">0,0</span></div>
            </div>
            <div class="text-right">
                <div class="text-xl" style="color: var(--neon-pink)">ROOM: <span id="room-display">--</span></div>
                <div id="role-display" class="text-xs text-gray-400 font-mono mb-1">MQTT</div>
                <button class="interactive text-xs bg-gray-800 border border-gray-600 px-2 py-1 mt-1" onclick="toggleEditor()">Map Editor</button>
                <button class="interactive text-xs bg-gray-800 border border-gray-600 px-2 py-1 mt-1" onclick="openSaveMenu()">Maps</button>
                <button class="interactive text-xs bg-gray-800 border border-gray-600 px-2 py-1 mt-1" onclick="openSettings()">‚öôÔ∏è</button>
            </div>
        </div>

        <!-- Editor UI -->
        <div id="editor-ui" class="interactive">
            <div class="tool-btn active" onclick="setTool(1)" title="Wall (1)">üß±</div>
            <div class="tool-btn" onclick="setTool(0)" title="Pavement (2)">üõ£Ô∏è</div>
            <div class="tool-btn" onclick="setTool(2)" title="Start/Finish (3)">üèÅ</div>
            <div class="tool-btn" onclick="setTool(3)" title="Grass (4)" style="color:#4f4">üå±</div>
            <div class="tool-btn" onclick="setTool(4)" title="Dirt (5)" style="color:#d84">üí©</div>
            <div class="tool-btn" onclick="setTool(5)" title="Sand (6)" style="color:#fd4">üèñÔ∏è</div>
            <div class="tool-btn" onclick="setTool(6)" title="Rumble (7)" style="color:#f44">üíà</div>
            
            <div class="border-l border-gray-600 mx-1"></div>
            
            <div class="editor-input-group">
                <label>W:</label>
                <input type="number" id="map-w" value="100" min="20" max="300">
            </div>
            <div class="editor-input-group">
                <label>H:</label>
                <input type="number" id="map-h" value="100" min="20" max="300">
            </div>
            
            <button class="text-xs px-3 py-1 bg-gray-700" onclick="applyMapSize()">Resize</button>
            <button class="text-xs px-3 py-1 bg-purple-700" onclick="generateTerrain()">Gen Terrain</button>
            
            <div class="border-l border-gray-600 mx-1"></div>
            <div class="tool-btn" onclick="shareMap()" title="Share Map" style="border-color: var(--neon-blue)">üì°</div>
            <div class="tool-btn" onclick="clearMap()" title="Clear All" style="border-color: var(--neon-pink)">üóëÔ∏è</div>
        </div>

        <!-- Chat -->
        <div id="chat-container" class="interactive">
            <div id="chat-messages"></div>
            <input type="text" id="chat-input" placeholder="Chat... (/ban name, /mute name)">
        </div>
        
        <!-- Right Panel -->
        <div id="right-panel">
            <div id="leaderboard">
                <div class="border-b border-gray-600 mb-2 pb-1 text-center">LEADERBOARD</div>
                <div id="lb-content"></div>
            </div>
            <div id="minimap-container">
                <canvas id="minimap-canvas" width="200" height="200"></canvas>
            </div>
        </div>

        <!-- Mobile Controls -->
        <div id="mobile-controls">
            <div class="touch-group">
                <div class="touch-btn" ontouchstart="inputs.left=true" ontouchend="inputs.left=false">‚óÑ</div>
                <div class="touch-btn" ontouchstart="inputs.right=true" ontouchend="inputs.right=false">‚ñ∫</div>
            </div>
            <div class="touch-group">
                <div class="touch-btn" style="border-color:var(--neon-blue)" ontouchstart="inputs.drift=true" ontouchend="inputs.drift=false">üí®</div>
                <div class="touch-btn touch-rect" style="border-color:#f44" ontouchstart="inputs.down=true" ontouchend="inputs.down=false">B</div>
                <div class="touch-btn touch-rect" style="border-color:#4f4" ontouchstart="inputs.up=true" ontouchend="inputs.up=false">G</div>
            </div>
        </div>
    </div>

    <!-- Map Save/Load Modal -->
    <div id="maps-modal" class="interactive fixed inset-0 bg-black bg-opacity-90 z-50 flex items-center justify-center hidden">
        <div class="panel w-96">
            <h2 class="text-xl mb-4 text-white font-bold">Saved Maps</h2>
            <div id="maps-list" class="max-h-60 overflow-y-auto mb-4 text-left space-y-2"></div>
            <div class="flex gap-2">
                <input type="text" id="map-save-name" placeholder="Map Name" class="flex-1">
                <button onclick="saveCurrentMap()" class="w-auto px-4">Save</button>
            </div>
            <button onclick="closeSaveMenu()" class="secondary mt-4">Close (Esc)</button>
        </div>
    </div>

    <!-- Settings Modal -->
    <div id="settings-modal" class="interactive fixed inset-0 bg-black bg-opacity-90 z-50 flex items-center justify-center hidden">
        <div class="panel w-96 text-left" style="max-height: 95vh; overflow-y: auto;">
            <h2 class="text-xl mb-4 text-white font-bold text-center">Settings</h2>
            
            <div class="tabs">
                <div class="tab active" onclick="switchTab('general')">General</div>
                <div class="tab" onclick="switchTab('controls')">Controls</div>
                <div class="tab" onclick="switchTab('host')">Host/Map</div>
            </div>

            <!-- General Tab -->
            <div id="tab-general" class="tab-content active">
                <div class="mb-4">
                    <h3 class="text-sm font-bold text-gray-400 mb-2">Audio</h3>
                    <label class="text-xs text-gray-400">Master Volume (<span id="vol-master-val">100</span>%)</label>
                    <input type="range" id="vol-master" min="0" max="200" value="100" oninput="updateVolumes()">
                    <label class="text-xs text-gray-400">Engine Volume (<span id="vol-engine-val">100</span>%)</label>
                    <input type="range" id="vol-engine" min="0" max="200" value="100" oninput="updateVolumes()">
                    <label class="text-xs text-gray-400">Tire Volume (<span id="vol-tires-val">100</span>%)</label>
                    <input type="range" id="vol-tires" min="0" max="200" value="100" oninput="updateVolumes()">
                    <label class="text-xs text-gray-400">SFX Volume (<span id="vol-sfx-val">100</span>%)</label>
                    <input type="range" id="vol-sfx" min="0" max="200" value="100" oninput="updateVolumes()">
                </div>
                <div class="mb-4 border-t border-gray-700 pt-4">
                    <h3 class="text-sm font-bold text-gray-400 mb-2">Graphics</h3>
                    <label class="text-xs text-gray-400">Paint Detail (<span id="paint-dist-val">10</span>px)</label>
                    <input type="range" id="paint-dist" min="5" max="50" value="10" oninput="updateGraphics()">
                </div>
                <div class="mb-4 border-t border-gray-700 pt-4">
                    <h3 class="text-sm font-bold text-gray-400 mb-2">Network</h3>
                    <label class="block text-left text-sm mb-1">MQTT Broker</label>
                    <select id="broker-select" class="text-xs mb-4">
                        <option value="wss://broker.hivemq.com:8884/mqtt">HiveMQ Public</option>
                        <option value="wss://broker.emqx.io:8084/mqtt">EMQX Public</option>
                        <option value="wss://test.mosquitto.org:8081">Mosquitto Public</option>
                    </select>
                </div>
            </div>

            <!-- Controls Tab -->
            <div id="tab-controls" class="tab-content">
                <h3 class="text-sm font-bold text-gray-400 mb-2">Keybinds (Click to bind)</h3>
                <div class="keybind-grid" id="keybind-list"></div>
                <button class="secondary text-xs mt-2" onclick="resetKeybinds()">Reset to Default</button>
            </div>

            <!-- Host/Map Tab -->
            <div id="tab-host" class="tab-content">
                <div id="host-controls-overlay" class="text-center text-gray-500 py-4 hidden">
                    Only the Host (Oldest Player) can edit physics.
                </div>
                <div id="host-controls-area">
                    <h3 class="text-sm font-bold text-neon-blue mb-2">Physics Tuner (Syncs to Room)</h3>
                    <label class="text-xs text-gray-400">Engine Power (<span id="phy-engine-val">0.5</span>)</label>
                    <input type="range" id="phy-engine" min="0.1" max="2.0" step="0.1" value="0.5" onchange="updateHostPhysics()">
                    
                    <label class="text-xs text-gray-400">Turn Speed (<span id="phy-turn-val">0.08</span>)</label>
                    <input type="range" id="phy-turn" min="0.01" max="0.3" step="0.01" value="0.08" onchange="updateHostPhysics()">
                    
                    <label class="text-xs text-gray-400">Drift Grip (<span id="phy-grip-val">0.05</span>)</label>
                    <input type="range" id="phy-grip" min="0.01" max="0.5" step="0.01" value="0.05" onchange="updateHostPhysics()">
                    
                    <label class="text-xs text-gray-400">Air Drag (<span id="phy-drag-val">0.98</span>)</label>
                    <input type="range" id="phy-drag" min="0.90" max="0.999" step="0.001" value="0.98" onchange="updateHostPhysics()">

                    <div class="mt-4 pt-2 border-t border-gray-700">
                        <label class="flex items-center gap-2 text-xs">
                            <input type="checkbox" id="host-allow-paint" checked onchange="updateHostSettings()"> Allow Client Painting
                        </label>
                    </div>
                </div>
            </div>
            
            <div class="flex gap-2 mt-4 pt-4 border-t border-gray-700">
                <button onclick="saveSettings()">Save & Close</button>
                <button onclick="closeSettings()" class="secondary">Cancel</button>
            </div>
        </div>
    </div>

    <canvas id="game-canvas"></canvas>

<script>
/**
 * CONFIG & GLOBALS
 */
// Persistent User ID for Ban System
const CLIENT_ID = localStorage.getItem('drift_pid') || crypto.randomUUID();
if(!localStorage.getItem('drift_pid')) localStorage.setItem('drift_pid', CLIENT_ID);

// Game State
let canvas, ctx, miniCanvas, miniCtx;
let isConnected = false;
let isEditorOpen = false;
let particles = []; 
let quitTimer = null;
let drawings = []; 
let bannedIds = JSON.parse(localStorage.getItem('drift_banned_ids') || '[]');

// Default Configs
const DEFAULT_BINDINGS = {
    up: 'w', down: 's', left: 'a', right: 'd', drift: ' ',
    paint: 't', editor: 'm', save: 'l', quit: 'q'
};
let bindings = { ...DEFAULT_BINDINGS };
let inputs = { up: false, down: false, left: false, right: false, drift: false, paint: false };
let remappingAction = null;

// Physics Defaults
const DEFAULT_PHYSICS = { engine: 0.5, turn: 0.08, grip: 0.05, drag: 0.98 };
let currentPhysics = { ...DEFAULT_PHYSICS };
let hostSettings = { allowPaint: true };

// Graphics
let paintDistThreshold = 10;

let myCar = {
    x: 0, y: 0, 
    vx: 0, vy: 0, 
    angle: 0, speed: 0, color: '#00f3ff', 
    name: 'Player', id: CLIENT_ID, joinedAt: 0,
    accel: 0, steer: 0, drifting: false, laps: 0, onFinishLine: false
};
let players = {}; 
let chatMuted = []; 
let mapData = []; 
const TILE_SIZE = 40;
let mapWidth = 100;
let mapHeight = 100;

const TILES = { PAVEMENT: 0, WALL: 1, SPAWN: 2, GRASS: 3, DIRT: 4, SAND: 5, RUMBLE: 6 };
const REVERSE_POWER = 0.2; // Fixed reverse for simplicity

let camera = { x: 0, y: 0, zoom: 1 };
let mqttClient;
let roomTopicBase = "";
let currentBroker = "wss://broker.hivemq.com:8884/mqtt"; 
let currentTool = 1;
let mouse = { x: 0, y: 0, leftDown: false, rightDown: false };
let lastPaintX = 0; let lastPaintY = 0;

/**
 * AUDIO SYSTEM
 */
class SoundManager {
    constructor() {
        this.ctx = null;
        this.engineOsc = null; this.engineGain = null;
        this.noiseNode = null; this.noiseGain = null;
        this.vols = { master: 1, engine: 1, tires: 1, sfx: 1 };
    }
    init() {
        if (this.ctx) return;
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        this.ctx = new AudioContext();
        this.engineOsc = this.ctx.createOscillator(); this.engineOsc.type = 'square';
        this.engineGain = this.ctx.createGain(); this.engineGain.gain.value = 0;
        this.engineOsc.connect(this.engineGain); this.engineGain.connect(this.ctx.destination);
        this.engineOsc.start();
        const bufferSize = this.ctx.sampleRate * 2;
        const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
        this.noiseNode = this.ctx.createBufferSource(); this.noiseNode.buffer = buffer; this.noiseNode.loop = true;
        this.noiseGain = this.ctx.createGain(); this.noiseGain.gain.value = 0;
        const filter = this.ctx.createBiquadFilter(); filter.type = 'lowpass'; filter.frequency.value = 800;
        this.noiseNode.connect(filter); filter.connect(this.noiseGain); this.noiseGain.connect(this.ctx.destination);
        this.noiseNode.start();
    }
    update(speed, isDrifting, isSlipSurface) {
        if (!this.ctx) return;
        const baseFreq = 80;
        this.engineOsc.frequency.setTargetAtTime(baseFreq + (Math.abs(speed) * 20), this.ctx.currentTime, 0.1);
        let engVol = 0.1 * this.vols.master * this.vols.engine;
        this.engineGain.gain.setTargetAtTime(engVol, this.ctx.currentTime, 0.1);
        let skidVol = 0;
        if (Math.abs(speed) > 2) {
            if (isDrifting) skidVol = 0.3;
            else if (isSlipSurface && Math.abs(speed) > 5) skidVol = 0.2;
        }
        skidVol = skidVol * this.vols.master * this.vols.tires;
        this.noiseGain.gain.setTargetAtTime(skidVol, this.ctx.currentTime, 0.1);
    }
    playTone(freq, type, duration, volMod = 1) {
        if (!this.ctx) return;
        const osc = this.ctx.createOscillator(); osc.type = type; osc.frequency.value = freq;
        const gain = this.ctx.createGain(); gain.gain.value = 0.3 * this.vols.master * this.vols.sfx * volMod;
        osc.connect(gain); gain.connect(this.ctx.destination);
        osc.start();
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
        osc.stop(this.ctx.currentTime + duration);
    }
    playCrash() { this.playTone(100, 'sawtooth', 0.3); }
    playChat() { this.playTone(800, 'sine', 0.1); }
    playJoin() { this.playTone(400, 'triangle', 0.1, 0.5); setTimeout(() => this.playTone(600, 'triangle', 0.2, 0.5), 100); }
    playLeave() { this.playTone(600, 'triangle', 0.1, 0.5); setTimeout(() => this.playTone(400, 'triangle', 0.2, 0.5), 100); }
    playLap() { this.playTone(880, 'square', 0.1, 0.7); setTimeout(() => this.playTone(1100, 'square', 0.3, 0.7), 100); }
}
const audio = new SoundManager();

/**
 * INITIALIZATION
 */
window.onload = () => {
    loadLocalSettings();
    canvas = document.getElementById('game-canvas');
    ctx = canvas.getContext('2d');
    miniCanvas = document.getElementById('minimap-canvas');
    miniCtx = miniCanvas.getContext('2d');
    resize();
    window.addEventListener('resize', resize);
    initMap(100, 100);
    loadSavedMapsList();
    checkMobile(); 
    checkForUpdates();
    setInterval(checkForUpdates, 60000);
    setInterval(updateLeaderboard, 500);
    setTimeout(resize, 100);

    // Key Listeners
    window.addEventListener('keydown', e => {
        if(remappingAction) { 
            e.preventDefault();
            bindings[remappingAction] = e.key.toLowerCase();
            remappingAction = null;
            saveLocalInputs();
            renderKeybinds();
            return;
        }
        if(document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'SELECT') return;
        const k = e.key.toLowerCase();
        for (let action in bindings) {
            if (bindings[action] === k) {
                if (action === 'editor') toggleEditor();
                else if (action === 'save') openSaveMenu();
                else if (action === 'quit') {
                    if(!quitTimer) {
                        document.getElementById('quit-overlay').style.display = 'flex';
                        quitTimer = setTimeout(() => { location.reload(); }, 1000);
                    }
                }
                else if (inputs.hasOwnProperty(action)) inputs[action] = true;
            }
        }
        if(k === 'escape') { closeSaveMenu(); closeSettings(); }
        if(parseInt(k) >= 1 && parseInt(k) <= 7) setTool([null, 1, 0, 2, 3, 4, 5, 6][parseInt(k)]);
    });
    
    window.addEventListener('keyup', e => {
        const k = e.key.toLowerCase();
        for (let action in bindings) {
            if (bindings[action] === k && inputs.hasOwnProperty(action)) inputs[action] = false;
        }
        if (bindings['quit'] === k) {
            clearTimeout(quitTimer); quitTimer = null;
            document.getElementById('quit-overlay').style.display = 'none';
        }
    });

    document.getElementById('chat-input').addEventListener('keydown', e => { if (e.key === 'Enter') sendChatFunc(); });

    canvas.addEventListener('mousedown', e => {
        if(e.button === 0) mouse.leftDown = true;
        if(e.button === 2) mouse.rightDown = true;
        handleEditorInput(e);
    });
    window.addEventListener('mouseup', () => { mouse.leftDown = false; mouse.rightDown = false; });
    canvas.addEventListener('mousemove', e => {
        const rect = canvas.getBoundingClientRect();
        mouse.x = e.clientX - rect.left; mouse.y = e.clientY - rect.top;
        handleEditorInput(e);
    });
    canvas.addEventListener('contextmenu', e => e.preventDefault());

    requestAnimationFrame(gameLoop);
};

// Update Checker
let initialCommitHash = null;
async function checkForUpdates() {
    try {
        const res = await fetch('https://api.github.com/repos/40476/web-gizmos/commits?path=racing/index.html&per_page=1');
        if (!res.ok) return;
        const data = await res.json();
        const latestHash = data[0]?.sha;
        if (!initialCommitHash) { initialCommitHash = latestHash; } 
        else if (initialCommitHash !== latestHash) { document.getElementById('update-notification').style.display = 'block'; }
    } catch (e) {}
}

function checkMobile() {
    var isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(new URLSearchParams(window.location.search).get('ua') || navigator.userAgent);
    if (isMobile) {
        document.getElementById('mobile-controls').style.display = 'flex';
        const chat = document.getElementById('chat-container');
        chat.style.bottom = '180px'; chat.style.width = '200px'; chat.style.height = '150px';
    }
}

function loadLocalSettings() {
    if(localStorage.getItem('drift_username')) document.getElementById('username').value = localStorage.getItem('drift_username');
    if(localStorage.getItem('drift_room')) document.getElementById('room-name').value = localStorage.getItem('drift_room');
    if(localStorage.getItem('drift_color')) document.getElementById('car-color').value = localStorage.getItem('drift_color');
    if(localStorage.getItem('drift_broker')) {
        currentBroker = localStorage.getItem('drift_broker');
        document.getElementById('broker-select').value = currentBroker;
    }
    // Safe Keybind Loading (Merge with defaults to fix missing keys)
    const storedBindings = localStorage.getItem('drift_bindings');
    if(storedBindings) {
        const parsed = JSON.parse(storedBindings);
        bindings = { ...DEFAULT_BINDINGS, ...parsed };
    }

    ['master', 'engine', 'tires', 'sfx'].forEach(v => {
        const val = localStorage.getItem('drift_vol_'+v);
        if(val) {
            document.getElementById('vol-'+v).value = val;
            audio.vols[v] = parseInt(val) / 100;
            document.getElementById(`vol-${v}-val`).innerText = val;
        }
    });
}

function saveLocalInputs() {
    localStorage.setItem('drift_username', document.getElementById('username').value);
    localStorage.setItem('drift_room', document.getElementById('room-name').value);
    localStorage.setItem('drift_color', document.getElementById('car-color').value);
    localStorage.setItem('drift_bindings', JSON.stringify(bindings));
}

function startRemap(action) { remappingAction = action; renderKeybinds(); }
function renderKeybinds() {
    const list = document.getElementById('keybind-list'); list.innerHTML = '';
    const labels = { up: "Throttle", down: "Brake", left: "Left", right: "Right", drift: "Handbrake", paint: "Paint Line", editor: "Toggle Editor", save: "Maps Menu", quit: "Hold to Quit" };
    for (let action in bindings) {
        const row = document.createElement('div');
        row.innerHTML = `<span class="text-xs text-gray-400 self-center">${labels[action] || action}</span>`;
        const btn = document.createElement('button');
        btn.className = `keybind-btn ${remappingAction === action ? 'recording' : ''}`;
        btn.innerText = remappingAction === action ? 'Press Key...' : bindings[action].toUpperCase();
        if(bindings[action] === ' ') btn.innerText = 'SPACE';
        btn.onclick = () => startRemap(action);
        row.appendChild(btn); list.appendChild(row);
    }
}

function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; if(ctx) ctx.imageSmoothingEnabled = false; }

function initMap(w, h) {
    mapWidth = w; mapHeight = h;
    mapData = new Array(mapWidth * mapHeight).fill(0);
    for(let x=0; x<mapWidth; x++) { setTile(x, 0, TILES.WALL, false); setTile(x, mapHeight-1, TILES.WALL, false); }
    for(let y=0; y<mapHeight; y++) { setTile(0, y, TILES.WALL, false); setTile(mapWidth-1, y, TILES.WALL, false); }
    setTile(10, 10, TILES.SPAWN, false);
    respawn();
    document.getElementById('map-w').value = mapWidth;
    document.getElementById('map-h').value = mapHeight;
}

/**
 * NETWORKING (MQTT)
 */
async function startGame() {
    audio.init();
    saveLocalInputs();

    const nameInput = document.getElementById('username').value.trim() || "Racer";
    const roomInput = document.getElementById('room-name').value.trim().toLowerCase() || "lobby";
    myCar.name = nameInput;
    myCar.color = document.getElementById('car-color').value;
    myCar.joinedAt = Date.now(); 

    document.getElementById('connection-status').innerText = "Hashing Room...";
    const hashBuffer = await crypto.subtle.digest('SHA-256', new TextEncoder().encode(roomInput));
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('').substr(0, 16);
    roomTopicBase = `drift_v8/${hashHex}`;
    
    document.getElementById('room-display').innerText = roomInput;
    document.getElementById('connection-status').innerText = `Connecting...`;

    if (mqttClient) mqttClient.end();

    try {
        mqttClient = mqtt.connect(currentBroker, { clientId: CLIENT_ID, clean: true, connectTimeout: 5000 });
        mqttClient.on('connect', () => {
            isConnected = true;
            document.getElementById('main-menu').style.display = 'none';
            addSystemMessage("Connected.");
            mqttClient.subscribe(`${roomTopicBase}/#`);
            publish('join', { name: myCar.name, color: myCar.color, id: myCar.id, joinedAt: myCar.joinedAt });
            setInterval(sendUpdate, 50); // 20Hz
        });
        mqttClient.on('error', (err) => document.getElementById('connection-status').innerText = "Conn Error.");
        mqttClient.on('message', (topic, message) => {
            const payload = JSON.parse(message.toString());
            const subTopic = topic.replace(roomTopicBase + '/', '');
            handleNetworkMessage(subTopic, payload);
        });
    } catch (e) { alert("Connection Error: " + e.message); }
}

function publish(subTopic, data) {
    if (!isConnected || !mqttClient) return;
    mqttClient.publish(`${roomTopicBase}/${subTopic}`, JSON.stringify(data));
}

function sendUpdate() {
    publish('pos', {
        id: myCar.id, name: myCar.name, color: myCar.color,
        x: Math.round(myCar.x), y: Math.round(myCar.y),
        angle: parseFloat(myCar.angle.toFixed(2)), speed: Math.round(myCar.speed), laps: myCar.laps,
        joinedAt: myCar.joinedAt
    });
}

function getAdminId() {
    let all = Object.values(players).concat(myCar);
    all.sort((a,b) => a.joinedAt - b.joinedAt);
    return all[0] ? all[0].id : myCar.id;
}

function handleNetworkMessage(subTopic, data) {
    if (data.id === myCar.id) return;

    if (subTopic === 'pos') {
        if (!players[data.id]) {
            if(bannedIds.includes(data.id) && getAdminId() === myCar.id) { publish('kick', { targetId: data.id }); }
            players[data.id] = { ...data, lastSeen: Date.now() };
            addSystemMessage(`${data.name} joined.`);
            audio.playJoin();
            // Host sends state to NEW player
            if (getAdminId() === myCar.id) {
                publish('map_sync', { 
                    data: mapData, w: mapWidth, h: mapHeight, targetId: data.id,
                    spawnX: myCar.x, spawnY: myCar.y,
                    drawings: drawings,
                    physics: currentPhysics,
                    hostSettings: hostSettings
                });
            }
        } else {
            const p = players[data.id];
            p.x = data.x; p.y = data.y; p.angle = data.angle; p.speed = data.speed;
            p.color = data.color; p.name = data.name; p.laps = data.laps || 0;
            p.joinedAt = data.joinedAt || Date.now();
            p.lastSeen = Date.now();
        }
    } else if (subTopic === 'join') {
        if(bannedIds.includes(data.id) && getAdminId() === myCar.id) { publish('kick', { targetId: data.id }); return; }
        players[data.id] = { ...data, x:0, y:0, angle:0, laps:0, lastSeen: Date.now() };
        addSystemMessage(`${data.name} joined.`);
        audio.playJoin();
        // Host Syncs state to NEW player
        if (getAdminId() === myCar.id) {
            publish('map_sync', { 
                data: mapData, w: mapWidth, h: mapHeight, targetId: data.id,
                spawnX: myCar.x, spawnY: myCar.y,
                drawings: drawings,
                physics: currentPhysics,
                hostSettings: hostSettings
            });
        }
    } else if (subTopic === 'kick') {
        if(data.targetId === myCar.id) { alert("You have been banned from this room."); location.reload(); }
    } else if (subTopic === 'chat') {
        if (!chatMuted.includes(data.name)) { addChatMessage(data.name, data.text, data.color); audio.playChat(); }
    } else if (subTopic === 'paint') {
        if(data.x1 && data.y1 && data.x2 && data.y2) drawings.push(data);
    } else if (subTopic === 'map') {
        addSystemMessage(`${data.sender} shared a map.`);
        if(data.data && data.data.length === data.w * data.h) {
            loadMapData(data.data); mapWidth = data.w; mapHeight = data.h; drawings = data.drawings || [];
            if(data.physics) currentPhysics = data.physics;
            if(data.spawnX && data.spawnY) { myCar.x = data.spawnX; myCar.y = data.spawnY; myCar.vx = 0; myCar.vy = 0; }
        }
    } else if (subTopic === 'map_sync') {
        // Sync Logic: If targeted to me OR broadcast (no ID)
        if (!data.targetId || data.targetId === myCar.id) {
            if(data.physics) currentPhysics = data.physics;
            if(data.hostSettings) hostSettings = data.hostSettings;
            if(data.drawings) drawings = data.drawings; // Sync drawings
            
            // Only overwrite map if local is default/empty OR if it's targeted sync (join)
            if (mapData.every(t => t === 0 || t === 1) || data.targetId === myCar.id) {
                if(data.data && data.data.length === data.w * data.h) {
                    loadMapData(data.data);
                    mapWidth = data.w; mapHeight = data.h;
                    // Force Respawn on Join Sync
                    respawn(); 
                }
            }
        }
    } else if (subTopic === 'physics_sync') {
        if(data.physics) currentPhysics = data.physics;
        if(data.hostSettings) hostSettings = data.hostSettings;
    }
}

/**
 * GAME LOGIC
 */
let lastFrameTime = 0;
const TARGET_FPS = 60;
const FRAME_INTERVAL = 1000 / TARGET_FPS;

function gameLoop(timestamp) {
    requestAnimationFrame(gameLoop);
    if (!lastFrameTime) { lastFrameTime = timestamp; return; }
    const elapsed = timestamp - lastFrameTime;
    
    if (elapsed > FRAME_INTERVAL) {
        lastFrameTime = timestamp - (elapsed % FRAME_INTERVAL);
        
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.imageSmoothingEnabled = false;
        
        updatePhysics();

        camera.x = myCar.x - canvas.width / 2;
        camera.y = myCar.y - canvas.height / 2;

        ctx.save();
        ctx.translate(-camera.x, -camera.y);

        drawMap();
        drawPaintings();

        particles.forEach((p, i) => {
            p.update(); p.draw(ctx);
            if(p.life <= 0) particles.splice(i, 1);
        });

        for (let id in players) {
            const p = players[id];
            drawCar(p);
            if (Date.now() - p.lastSeen > 5000) {
                audio.playLeave();
                addSystemMessage(`${players[id].name} rage quit.`);
                delete players[id];
            }
        }

        drawCar(myCar);
        if(isEditorOpen) drawEditorCursor();

        ctx.restore();
        drawMinimap();
    }
}

function updatePhysics() {
    const centerTile = getTile(Math.floor(myCar.x / TILE_SIZE), Math.floor(myCar.y / TILE_SIZE));
    if (centerTile === TILES.SPAWN) {
        if (!myCar.onFinishLine) {
            myCar.laps++; myCar.onFinishLine = true; audio.playLap(); addSystemMessage(`Lap ${myCar.laps}!`);
        }
    } else { myCar.onFinishLine = false; }

    let grip = 0.96; let drag = 0.98; let surfaceType = 'pavement';
    switch(centerTile) {
        case TILES.GRASS: grip = 0.85; drag = 0.92; surfaceType='grass'; break;
        case TILES.DIRT: grip = 0.60; drag = 0.94; surfaceType='dirt'; break;
        case TILES.SAND: grip = 0.90; drag = 0.80; surfaceType='dirt'; break;
        case TILES.RUMBLE: grip = 0.98; drag = 0.97; break;
    }

    if (inputs.drift) { grip = parseFloat(currentPhysics.grip); myCar.drifting = true; } else { myCar.drifting = false; }

    const effectiveTurnSpeed = myCar.drifting ? parseFloat(currentPhysics.turn) * 1.3 : parseFloat(currentPhysics.turn);
    if (inputs.left) myCar.angle -= effectiveTurnSpeed;
    if (inputs.right) myCar.angle += effectiveTurnSpeed;

    let accel = 0;
    if (inputs.up) accel = parseFloat(currentPhysics.engine);
    if (inputs.down) accel = -REVERSE_POWER;

    myCar.vx += Math.cos(myCar.angle) * accel;
    myCar.vy += Math.sin(myCar.angle) * accel;

    const rightAngle = myCar.angle + Math.PI/2;
    const lateralVelocity = myCar.vx * Math.cos(rightAngle) + myCar.vy * Math.sin(rightAngle);
    
    myCar.vx -= Math.cos(rightAngle) * lateralVelocity * grip;
    myCar.vy -= Math.sin(rightAngle) * lateralVelocity * grip;

    myCar.vx *= drag * parseFloat(currentPhysics.drag); myCar.vy *= drag * parseFloat(currentPhysics.drag);

    let nextX = myCar.x + myCar.vx; let nextY = myCar.y + myCar.vy;
    if (checkCollision(nextX, nextY)) {
        myCar.vx *= -0.5; myCar.vy *= -0.5; nextX = myCar.x + myCar.vx; nextY = myCar.y + myCar.vy; audio.playCrash();
    } else { myCar.x = nextX; myCar.y = nextY; }

    myCar.speed = Math.sqrt(myCar.vx*myCar.vx + myCar.vy*myCar.vy);
    document.getElementById('speed-display').innerText = Math.floor(myCar.speed * 10);
    document.getElementById('pos-display').innerText = `${Math.floor(myCar.x)},${Math.floor(myCar.y)}`;

    const isSliding = Math.abs(lateralVelocity) > 2.0;
    audio.update(myCar.speed, myCar.drifting || isSliding, surfaceType !== 'pavement');

    if ((myCar.drifting || isSliding) && (Date.now() % 3 === 0)) emitParticles(myCar.x, myCar.y, surfaceType === 'pavement' ? 'smoke' : surfaceType);
    else if (myCar.speed > 2 && surfaceType !== 'pavement' && (Date.now() % 5 === 0)) emitParticles(myCar.x, myCar.y, surfaceType);

    // Painting Logic
    if (inputs.paint && (hostSettings.allowPaint || getAdminId() === myCar.id)) {
        if (!lastPaintX) { lastPaintX = myCar.x; lastPaintY = myCar.y; }
        const dist = Math.hypot(myCar.x - lastPaintX, myCar.y - lastPaintY);
        if (dist > paintDistThreshold) { 
            const line = { x1: lastPaintX, y1: lastPaintY, x2: myCar.x, y2: myCar.y, color: myCar.color };
            drawings.push(line);
            publish('paint', line);
            lastPaintX = myCar.x; lastPaintY = myCar.y;
        }
    } else {
        lastPaintX = 0; lastPaintY = 0;
    }
}

function checkCollision(x, y) {
    const r = 12; 
    const checks = [ {x: x-r, y: y-r}, {x: x+r, y: y-r}, {x: x-r, y: y+r}, {x: x+r, y: y+r} ];
    for (let p of checks) {
        const tx = Math.floor(p.x / TILE_SIZE); const ty = Math.floor(p.y / TILE_SIZE);
        if (getTile(tx, ty) === TILES.WALL) return true;
    }
    return false;
}

function drawCar(c) {
    ctx.save(); ctx.translate(c.x, c.y); ctx.rotate(c.angle);
    ctx.fillStyle = c.color; ctx.shadowBlur = 10; ctx.shadowColor = c.color; ctx.fillRect(-15, -10, 30, 20);
    ctx.fillStyle = "#222"; ctx.fillRect(-18, -11, 5, 22);
    ctx.fillStyle = "#000"; ctx.fillRect(-2, -8, 8, 16);
    ctx.fillStyle = "#fff"; ctx.shadowColor = "#fff"; ctx.fillRect(14, -8, 2, 4); ctx.fillRect(14, 4, 2, 4);
    ctx.restore();
    ctx.fillStyle = "white"; ctx.font = "10px Orbitron"; ctx.textAlign = "center"; ctx.shadowBlur = 0;
    ctx.fillText(c.name, c.x, c.y - 25);
}

function drawPaintings() {
    ctx.lineWidth = 2;
    for(let l of drawings) {
        ctx.strokeStyle = l.color; ctx.beginPath(); ctx.moveTo(l.x1, l.y1); ctx.lineTo(l.x2, l.y2); ctx.stroke();
    }
}

function updateLeaderboard() {
    const adminId = getAdminId();
    const all = [{id: myCar.id, name: myCar.name, laps: myCar.laps, color: myCar.color}, ...Object.values(players)];
    all.sort((a,b) => (b.laps || 0) - (a.laps || 0));
    document.getElementById('lb-content').innerHTML = all.map(p => 
        `<div class="lb-row"><span class="lb-name" style="color:${p.color}">${p.name} ${p.id === adminId ? '<span class="lb-admin">‚òÖ</span>' : ''}</span><span class="lb-laps">${p.laps||0}</span></div>`
    ).join('');
}

/**
 * MAP & EDITOR
 */
function getTile(x, y) {
    if (x < 0 || x >= mapWidth || y < 0 || y >= mapHeight) return TILES.WALL;
    return mapData[y * mapWidth + x];
}
function setTile(x, y, val) {
    if (x < 0 || x >= mapWidth || y < 0 || y >= mapHeight) return;
    mapData[y * mapWidth + x] = val;
}
function drawMap() {
    const startX = Math.floor(camera.x / TILE_SIZE); const startY = Math.floor(camera.y / TILE_SIZE);
    const endX = startX + Math.ceil(canvas.width / TILE_SIZE) + 1; const endY = startY + Math.ceil(canvas.height / TILE_SIZE) + 1;
    for (let y = startY; y < endY; y++) {
        for (let x = startX; x < endX; x++) {
            const t = getTile(x, y); const px = x * TILE_SIZE; const py = y * TILE_SIZE;
            if (t === TILES.PAVEMENT) { ctx.fillStyle = "#222"; ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE); ctx.strokeStyle = "#333"; ctx.strokeRect(px, py, TILE_SIZE, TILE_SIZE); }
            else if (t === TILES.WALL) { ctx.fillStyle = "#445"; ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE); ctx.fillStyle = "#000"; ctx.fillRect(px + 4, py + 4, TILE_SIZE - 8, TILE_SIZE - 8); ctx.strokeStyle = "var(--neon-blue)"; ctx.lineWidth = 1; ctx.strokeRect(px, py, TILE_SIZE, TILE_SIZE); }
            else if (t === TILES.GRASS) { ctx.fillStyle = "#262"; ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE); ctx.fillStyle = "#383"; ctx.fillRect(px+5, py+5, 5, 5); ctx.fillRect(px+20, py+25, 5, 5); }
            else if (t === TILES.DIRT) { ctx.fillStyle = "#642"; ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE); }
            else if (t === TILES.SAND) { ctx.fillStyle = "#da8"; ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE); }
            else if (t === TILES.RUMBLE) { ctx.fillStyle = (x + y) % 2 === 0 ? "#e22" : "#eee"; ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE); }
            else if (t === TILES.SPAWN) { ctx.fillStyle = ((x + y) % 2 === 0) ? "#fff" : "#000"; ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE); ctx.strokeStyle = "white"; ctx.strokeRect(px, py, TILE_SIZE, TILE_SIZE); }
        }
    }
}
function drawMinimap() {
    miniCtx.fillStyle = '#000'; miniCtx.fillRect(0, 0, 200, 200);
    const scaleX = 200 / mapWidth; const scaleY = 200 / mapHeight;
    miniCtx.fillStyle = '#666';
    for(let i=0; i<mapData.length; i++) { if(mapData[i] === TILES.WALL) { const x = i % mapWidth; const y = Math.floor(i / mapWidth); miniCtx.fillRect(x * scaleX, y * scaleY, scaleX, scaleY); } }
    miniCtx.fillStyle = '#00f3ff'; miniCtx.beginPath(); miniCtx.arc((myCar.x/TILE_SIZE)*scaleX, (myCar.y/TILE_SIZE)*scaleY, 3, 0, Math.PI*2); miniCtx.fill();
    miniCtx.fillStyle = '#ff0055';
    for(let id in players) { const p = players[id]; miniCtx.beginPath(); miniCtx.arc((p.x/TILE_SIZE)*scaleX, (p.y/TILE_SIZE)*scaleY, 2, 0, Math.PI*2); miniCtx.fill(); }
}

/**
 * UI & UTILS
 */
function toggleEditor() { isEditorOpen = !isEditorOpen; document.getElementById('editor-ui').style.display = isEditorOpen ? 'flex' : 'none'; }
function setTool(t) { currentTool = t; document.querySelectorAll('.tool-btn').forEach((b, i) => b.classList.toggle('active', i === t || (t===0 && i===1))); }
function handleEditorInput(e) {
    if(!isEditorOpen) return; 
    const worldX = mouse.x + camera.x; const worldY = mouse.y + camera.y;
    const tx = Math.floor(worldX / TILE_SIZE); const ty = Math.floor(worldY / TILE_SIZE);
    if (mouse.leftDown) setTile(tx, ty, currentTool); if (mouse.rightDown) setTile(tx, ty, TILES.PAVEMENT);
}
function drawEditorCursor() {
    const worldX = mouse.x + camera.x; const worldY = mouse.y + camera.y;
    const tx = Math.floor(worldX / TILE_SIZE); const ty = Math.floor(worldY / TILE_SIZE);
    ctx.strokeStyle = "yellow"; ctx.lineWidth = 2; ctx.strokeRect(tx * TILE_SIZE, ty * TILE_SIZE, TILE_SIZE, TILE_SIZE);
}
function clearMap() { if(confirm("Clear map?")) { mapData.fill(0); drawings = []; shareMap(); } }
function applyMapSize() {
    const w = parseInt(document.getElementById('map-w').value); const h = parseInt(document.getElementById('map-h').value);
    if (w < 20 || h < 20 || w > 300 || h > 300) { alert("Size limit"); return; }
    if(confirm("Resize? Clears data.")) initMap(w, h);
}
function generateTerrain() {
    if(!confirm("Generate?")) return;
    for(let i=0; i<mapData.length; i++) {
        let x = i % mapWidth; let y = Math.floor(i / mapWidth);
        if (x===0 || y===0 || x===mapWidth-1 || y===mapHeight-1) mapData[i] = TILES.WALL; else mapData[i] = Math.random() < 0.45 ? TILES.WALL : TILES.PAVEMENT;
    }
    for(let k=0; k<5; k++) {
        let newData = [...mapData];
        for(let y=1; y<mapHeight-1; y++) {
            for(let x=1; x<mapWidth-1; x++) {
                let n = 0; for(let dy=-1; dy<=1; dy++) for(let dx=-1; dx<=1; dx++) if(getTile(x+dx, y+dy) === TILES.WALL) n++;
                if (n > 4) newData[y*mapWidth+x] = TILES.WALL; else if (n < 4) newData[y*mapWidth+x] = TILES.PAVEMENT;
            }
        }
        mapData = newData;
    }
    setTile(10, 10, TILES.SPAWN); respawn();
}
function respawn() {
    let spawnFound = false; myCar.vx = 0; myCar.vy = 0; myCar.speed = 0;
    for(let y=0; y<mapHeight; y++) { for(let x=0; x<mapWidth; x++) { if(getTile(x, y) === TILES.SPAWN) { myCar.x = x * TILE_SIZE + TILE_SIZE/2; myCar.y = y * TILE_SIZE + TILE_SIZE/2; spawnFound = true; break; } } if(spawnFound) break; }
    if(!spawnFound) { myCar.x = 200; myCar.y = 200; }
}
function openSaveMenu() { document.getElementById('maps-modal').style.display = 'flex'; loadSavedMapsList(); }
function closeSaveMenu() { document.getElementById('maps-modal').style.display = 'none'; }
function saveCurrentMap() {
    const name = document.getElementById('map-save-name').value || "Untitled";
    const saveObj = { name: name, date: new Date().toLocaleDateString(), data: mapData, w: mapWidth, h: mapHeight, physics: currentPhysics, drawings: drawings };
    localStorage.setItem('drift_map_' + name, JSON.stringify(saveObj)); loadSavedMapsList();
}
function loadSavedMapsList() {
    const list = document.getElementById('maps-list'); list.innerHTML = "";
    for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key.startsWith('drift_map_')) {
            const val = JSON.parse(localStorage.getItem(key));
            const div = document.createElement('div'); div.className = "flex justify-between items-center bg-gray-800 p-2 rounded";
            div.innerHTML = `<span>${val.name}</span>`;
            const btnLoad = document.createElement('button'); btnLoad.innerText = "Load"; btnLoad.className = "text-xs px-2 py-1 w-auto ml-2";
            btnLoad.onclick = () => { 
                if (val.w) { mapWidth = val.w; mapHeight = val.h; } 
                loadMapData(val.data);
                if(val.physics) currentPhysics = val.physics;
                if(val.drawings) drawings = val.drawings;
                shareMap(); closeSaveMenu(); 
            };
            div.appendChild(btnLoad); list.appendChild(div);
        }
    }
}
function loadMapData(newData) { if(newData && newData.length === mapWidth * mapHeight) { mapData = newData; respawn(); } else { console.warn("Invalid map data loaded"); } }
function shareMap() { if(!isConnected) { alert("Connect first!"); return; } publish('map', { sender: myCar.name, data: mapData, w: mapWidth, h: mapHeight, spawnX: myCar.x, spawnY: myCar.y, drawings: drawings, physics: currentPhysics }); }
function sendChatFunc() {
    const input = document.getElementById('chat-input'); const text = input.value.trim();
    if (!text) return;
    if (text.startsWith('/')) { handleCommand(text); } else { publish('chat', { name: myCar.name, text: text, color: myCar.color }); }
    input.value = "";
}
function handleCommand(cmd) {
    const parts = cmd.split(' ');
    if (parts[0] === '/kick') addSystemMessage("Kick requires admin (Disabled in Public Mode)");
    else if (parts[0] === '/ban') {
        if(getAdminId() === myCar.id) {
            const targetName = parts[1]; let targetId = null;
            for(let id in players) { if(players[id].name === targetName) targetId = id; }
            if(targetId) {
                bannedIds.push(targetId); localStorage.setItem('drift_banned_ids', JSON.stringify(bannedIds));
                publish('kick', { targetId: targetId }); addSystemMessage(`Banning ${targetName}...`);
            } else { addSystemMessage("User not found."); }
        } else { addSystemMessage("Only Admin (Oldest player) can ban."); }
    }
    else if (parts[0] === '/mute') { chatMuted.push(parts[1]); addSystemMessage(`Muted ${parts[1]}.`); }
}
function addChatMessage(name, text, color) {
    const div = document.createElement('div'); div.className = 'chat-msg';
    div.innerHTML = `<span style="color:${color}; font-weight:bold">${name}:</span> ${text}`;
    const container = document.getElementById('chat-messages'); container.appendChild(div); container.scrollTop = container.scrollHeight;
}
function addSystemMessage(text) {
    const div = document.createElement('div'); div.className = 'chat-msg sys-msg'; div.innerText = `[SYS] ${text}`;
    const container = document.getElementById('chat-messages'); container.appendChild(div); container.scrollTop = container.scrollHeight;
}

// SETTINGS UI
function openSettings() { 
    document.getElementById('settings-modal').style.display = 'flex'; 
    renderKeybinds(); 
    switchTab('general');
    
    // Admin check for Host Tab
    const isAdmin = getAdminId() === myCar.id;
    document.getElementById('host-controls-area').style.display = isAdmin ? 'block' : 'none';
    document.getElementById('host-controls-overlay').style.display = isAdmin ? 'none' : 'block';
    
    // Sync Inputs
    document.getElementById('phy-engine').value = currentPhysics.engine || 0.5;
    document.getElementById('phy-turn').value = currentPhysics.turn || 0.08;
    document.getElementById('phy-grip').value = currentPhysics.grip || 0.05;
    document.getElementById('phy-drag').value = currentPhysics.drag || 0.98;
    document.getElementById('host-allow-paint').checked = hostSettings.allowPaint;
}
function closeSettings() { document.getElementById('settings-modal').style.display = 'none'; remappingAction = null; }
function saveSettings() { currentBroker = document.getElementById('broker-select').value; localStorage.setItem('drift_broker', currentBroker); closeSettings(); if (isConnected) { alert("Broker changed. Please reconnect."); location.reload(); } }
function updateVolumes() {
    ['master', 'engine', 'tires', 'sfx'].forEach(v => {
        const val = document.getElementById('vol-'+v).value; audio.vols[v] = parseInt(val) / 100; document.getElementById(`vol-${v}-val`).innerText = val; localStorage.setItem('drift_vol_'+v, val);
    });
}
function updateGraphics() {
    paintDistThreshold = parseInt(document.getElementById('paint-dist').value);
    document.getElementById('paint-dist-val').innerText = paintDistThreshold;
}
function updateHostPhysics() {
    if(getAdminId() !== myCar.id) return;
    currentPhysics.engine = document.getElementById('phy-engine').value;
    document.getElementById('phy-engine-val').innerText = currentPhysics.engine;
    currentPhysics.turn = document.getElementById('phy-turn').value;
    document.getElementById('phy-turn-val').innerText = currentPhysics.turn;
    currentPhysics.grip = document.getElementById('phy-grip').value;
    document.getElementById('phy-grip-val').innerText = currentPhysics.grip;
    currentPhysics.drag = document.getElementById('phy-drag').value;
    document.getElementById('phy-drag-val').innerText = currentPhysics.drag;
    publish('physics_sync', { physics: currentPhysics, hostSettings: hostSettings });
}
function updateHostSettings() {
    if(getAdminId() !== myCar.id) return;
    hostSettings.allowPaint = document.getElementById('host-allow-paint').checked;
    publish('physics_sync', { physics: currentPhysics, hostSettings: hostSettings });
}
function resetKeybinds() {
    bindings = { ...DEFAULT_BINDINGS };
    saveLocalInputs();
    renderKeybinds();
}
function switchTab(tabId) {
    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
    document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
    document.querySelector(`.tab[onclick="switchTab('${tabId}')"]`).classList.add('active');
    document.getElementById(`tab-${tabId}`).classList.add('active');
}

class Particle {
    constructor(x, y, color, life, speed) { this.x = x; this.y = y; this.color = color; this.life = life; this.maxLife = life; const angle = Math.random() * Math.PI * 2; this.vx = Math.cos(angle) * speed; this.vy = Math.sin(angle) * speed; }
    update() { this.x += this.vx; this.y += this.vy; this.life--; }
    draw(ctx) { ctx.globalAlpha = this.life / this.maxLife; ctx.fillStyle = this.color; ctx.fillRect(this.x, this.y, 3, 3); ctx.globalAlpha = 1.0; }
}
function emitParticles(x, y, type) {
    let color = '#fff'; let count = 1; if (type === 'smoke') { color = '#ddd'; count = 2; } if (type === 'dirt') { color = '#864'; count = 2; } if (type === 'grass') { color = '#484'; count = 2; }
    for(let i=0; i<count; i++) particles.push(new Particle(x + (Math.random()*10-5), y + (Math.random()*10-5), color, 20 + Math.random()*20, 0.5));
}
</script>
</body>
</html>

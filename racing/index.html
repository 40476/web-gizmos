<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Drift.js Multiplayer (Torrent P2P)</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Roboto:wght@300;400;700&display=swap');

        :root {
            --neon-blue: #00f3ff;
            --neon-pink: #ff00ff;
            --bg-dark: #0a0a0f;
            --panel-bg: rgba(16, 20, 30, 0.95);
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--bg-dark);
            font-family: 'Roboto', sans-serif;
            color: white;
            user-select: none;
        }

        canvas {
            display: block;
            image-rendering: pixelated;
        }

        /* CRT Effect Overlay */
        .scanlines {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(to bottom, rgba(255,255,255,0), rgba(255,255,255,0) 50%, rgba(0,0,0,0.1) 50%, rgba(0,0,0,0.1));
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 100;
        }

        /* UI Containers */
        #ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .interactive {
            pointer-events: auto;
        }

        /* Main Menu */
        #main-menu {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 50;
            backdrop-filter: blur(5px);
        }

        .panel {
            background: var(--panel-bg);
            border: 1px solid var(--neon-blue);
            box-shadow: 0 0 20px rgba(0, 243, 255, 0.2);
            padding: 2rem;
            border-radius: 8px;
            width: 400px;
            max-width: 90%;
            text-align: center;
        }

        h1 {
            font-family: 'Orbitron', sans-serif;
            color: var(--neon-blue);
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 1.5rem;
            text-shadow: 0 0 10px var(--neon-blue);
        }

        input[type="text"], input[type="number"], input[type="color"] {
            background: #1a1a24;
            border: 1px solid #333;
            color: white;
            padding: 10px;
            width: 100%;
            margin-bottom: 1rem;
            font-family: 'Orbitron', sans-serif;
            border-radius: 4px;
        }

        input[type="color"] {
            height: 50px;
            cursor: pointer;
        }

        button {
            background: linear-gradient(45deg, var(--neon-blue), #00aaff);
            border: none;
            color: black;
            padding: 12px 24px;
            font-weight: bold;
            font-family: 'Orbitron', sans-serif;
            cursor: pointer;
            width: 100%;
            transition: transform 0.1s, box-shadow 0.1s;
            border-radius: 4px;
            text-transform: uppercase;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 0 15px var(--neon-blue);
        }

        button.secondary {
            background: transparent;
            border: 1px solid var(--neon-pink);
            color: var(--neon-pink);
            margin-top: 10px;
        }

        button.secondary:hover {
            box-shadow: 0 0 15px var(--neon-pink);
            background: rgba(255, 0, 255, 0.1);
        }

        /* HUD */
        #hud {
            padding: 20px;
            display: flex;
            justify-content: space-between;
            font-family: 'Orbitron', sans-serif;
            text-shadow: 1px 1px 0 #000;
        }

        #editor-ui {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--panel-bg);
            padding: 10px;
            border: 1px solid var(--neon-pink);
            display: none; /* Hidden by default */
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            border-radius: 8px;
            max-width: 90%;
        }

        .tool-btn {
            width: 40px;
            height: 40px;
            border: 1px solid #555;
            background: #222;
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            transition: all 0.2s;
        }

        .tool-btn:hover { background: #333; }

        .tool-btn.active {
            border-color: var(--neon-blue);
            background: rgba(0, 243, 255, 0.2);
            transform: scale(1.1);
        }

        .editor-input-group {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .editor-input-group input {
            width: 60px;
            margin: 0;
            padding: 5px;
            font-size: 12px;
            text-align: center;
        }

        /* Chat */
        #chat-container {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 300px;
            height: 250px;
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid #333;
            display: flex;
            flex-direction: column;
            pointer-events: auto;
            border-radius: 4px;
        }

        #chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
            font-size: 0.85rem;
            color: #ddd;
        }

        .chat-msg { margin-bottom: 4px; word-wrap: break-word; }
        .sys-msg { color: var(--neon-blue); font-style: italic; }
        .err-msg { color: var(--neon-pink); }

        #chat-input {
            background: rgba(0,0,0,0.8);
            border: none;
            border-top: 1px solid #333;
            color: white;
            padding: 8px;
            outline: none;
        }

        /* Minimap */
        #minimap-container {
            position: absolute;
            bottom: 20px;
            right: 20px;
            border: 2px solid var(--neon-blue);
            background: rgba(0,0,0,0.8);
            width: 200px;
            height: 200px;
        }
        #minimap-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        /* Saved Maps Modal */
        #maps-modal {
            display: none;
        }
    </style>
</head>
<body>

    <div class="scanlines"></div>

    <div id="ui-layer">
        <!-- Main Menu -->
        <div id="main-menu" class="interactive">
            <div class="panel">
                <h1>Cyber Drift P2P</h1>
                <input type="text" id="username" placeholder="Racer Name" maxlength="12">
                <input type="text" id="room-name" placeholder="Room Name (e.g. cat)" value="lobby">
                <div class="text-left text-sm text-gray-400 mb-2">Car Color</div>
                <input type="color" id="car-color" value="#00f3ff">
                <button onclick="startGame()">Connect & Race</button>
                <div id="connection-status" class="mt-2 text-xs text-gray-500">Uses Trystero (Torrent) - May take 5-10s</div>
            </div>
        </div>

        <!-- HUD -->
        <div id="hud">
            <div>
                <div class="text-xl" style="color: var(--neon-blue)">SPEED: <span id="speed-display">0</span> KM/H</div>
                <div class="text-sm text-gray-400">POS: <span id="pos-display">0,0</span></div>
            </div>
            <div class="text-right">
                <div class="text-xl" style="color: var(--neon-pink)">ROOM: <span id="room-display">--</span></div>
                <div id="role-display" class="text-xs text-gray-400 font-mono mb-1">MESH MODE</div>
                <button class="interactive text-xs bg-gray-800 border border-gray-600 px-2 py-1 mt-1" onclick="toggleEditor()">Map Editor</button>
                <button class="interactive text-xs bg-gray-800 border border-gray-600 px-2 py-1 mt-1" onclick="openSaveMenu()">Load/Save Maps</button>
            </div>
        </div>

        <!-- Editor UI -->
        <div id="editor-ui" class="interactive">
            <div class="tool-btn active" onclick="setTool(1)" title="Wall">üß±</div>
            <div class="tool-btn" onclick="setTool(0)" title="Pavement (Eraser)">üõ£Ô∏è</div>
            <div class="tool-btn" onclick="setTool(2)" title="Spawn Point">üèÅ</div>
            <div class="tool-btn" onclick="setTool(3)" title="Grass" style="color:#4f4">üå±</div>
            <div class="tool-btn" onclick="setTool(4)" title="Dirt" style="color:#d84">üí©</div>
            <div class="tool-btn" onclick="setTool(5)" title="Sand" style="color:#fd4">üèñÔ∏è</div>
            <div class="tool-btn" onclick="setTool(6)" title="Rumble Strip" style="color:#f44">üíà</div>

            <div class="border-l border-gray-600 mx-1"></div>

            <div class="editor-input-group">
                <label>W:</label>
                <input type="number" id="map-w" value="100" min="20" max="300">
            </div>
            <div class="editor-input-group">
                <label>H:</label>
                <input type="number" id="map-h" value="100" min="20" max="300">
            </div>

            <button class="text-xs px-3 py-1 bg-gray-700" onclick="applyMapSize()">Resize</button>
            <button class="text-xs px-3 py-1 bg-purple-700" onclick="generateTerrain()">Gen Terrain</button>

            <div class="border-l border-gray-600 mx-1"></div>
            <div class="tool-btn" onclick="shareMap()" title="Share Map to Room" style="border-color: var(--neon-blue)">üì°</div>
            <div class="tool-btn" onclick="clearMap()" title="Clear All" style="border-color: var(--neon-pink)">üóëÔ∏è</div>
        </div>

        <!-- Chat -->
        <div id="chat-container" class="interactive">
            <div id="chat-messages"></div>
            <input type="text" id="chat-input" placeholder="Chat... (/kick name, /mute name)">
        </div>

        <!-- Minimap -->
        <div id="minimap-container">
            <canvas id="minimap-canvas" width="200" height="200"></canvas>
        </div>
    </div>

    <!-- Map Save/Load Modal -->
    <div id="maps-modal" class="interactive fixed inset-0 bg-black bg-opacity-90 z-50 flex items-center justify-center hidden">
        <div class="panel w-96">
            <h2 class="text-xl mb-4 text-white font-bold">Saved Maps</h2>
            <div id="maps-list" class="max-h-60 overflow-y-auto mb-4 text-left space-y-2">
                <!-- Map items injected here -->
            </div>
            <div class="flex gap-2">
                <input type="text" id="map-save-name" placeholder="Map Name" class="flex-1">
                <button onclick="saveCurrentMap()" class="w-auto px-4">Save</button>
            </div>
            <button onclick="closeSaveMenu()" class="secondary mt-4">Close</button>
        </div>
    </div>

    <canvas id="game-canvas"></canvas>

<script type="module">
// FIX 1: Explicitly import Torrent strategy to avoid Nostr relay errors
import { joinRoom } from 'https://esm.sh/trystero/torrent';

/**
 * CONFIG & GLOBALS
 */
const CLIENT_ID = "racer_" + Math.random().toString(16).substr(2, 8);

// Game State
let canvas, ctx, miniCanvas, miniCtx;
let isConnected = false;
let isEditorOpen = false;
let particles = []; // Particle system

let myCar = {
    x: 0, y: 0,
    vx: 0, vy: 0, // Velocity Vector
    angle: 0,
    speed: 0, // Scalar speed for display/pitch
    color: '#00f3ff',
    name: 'Player',
    id: CLIENT_ID,
    accel: 0,
    steer: 0,
    drifting: false
};
let players = {}; // Remote players
let chatMuted = [];
let mapData = [];
const TILE_SIZE = 40;
let mapWidth = 100;
let mapHeight = 100;

// Tile Definitions
const TILES = {
    PAVEMENT: 0,
    WALL: 1,
    SPAWN: 2,
    GRASS: 3,
    DIRT: 4,
    SAND: 5,
    RUMBLE: 6
};

// Physics Constants
const ENGINE_POWER = 0.5; // Slightly increased
const REVERSE_POWER = 0.2;
const TURN_SPEED = 0.08;
const DRAG_AIR = 0.98; // Less air resistance for better coasting

// Camera
let camera = { x: 0, y: 0, zoom: 1 };

// Trystero State
let room;
let roomHash = "";
let sendUpdate, sendMap, sendChat, sendKick, sendTile;

// Inputs
const keys = { w: false, a: false, s: false, d: false, Shift: false, " ": false };

// Editor
let currentTool = 1;
let mouse = { x: 0, y: 0, leftDown: false, rightDown: false };

/**
 * AUDIO SYSTEM (8-bit style)
 */
class SoundManager {
    constructor() {
        this.ctx = null;
        this.engineOsc = null;
        this.engineGain = null;
        this.noiseNode = null;
        this.noiseGain = null;
    }

    init() {
        if (this.ctx) return;
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        this.ctx = new AudioContext();

        // Engine Sound (Square wave for 8-bit feel)
        this.engineOsc = this.ctx.createOscillator();
        this.engineOsc.type = 'square';
        this.engineGain = this.ctx.createGain();
        this.engineGain.gain.value = 0.1;
        this.engineOsc.connect(this.engineGain);
        this.engineGain.connect(this.ctx.destination);
        this.engineOsc.start();

        // Drift/Skid Noise (White Noise Buffer)
        const bufferSize = this.ctx.sampleRate * 2; // 2 seconds buffer
        const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) {
            data[i] = Math.random() * 2 - 1;
        }

        this.noiseNode = this.ctx.createBufferSource();
        this.noiseNode.buffer = buffer;
        this.noiseNode.loop = true;
        this.noiseGain = this.ctx.createGain();
        this.noiseGain.gain.value = 0;

        // Lowpass filter for skid sound
        const filter = this.ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 800;

        this.noiseNode.connect(filter);
        filter.connect(this.noiseGain);
        this.noiseGain.connect(this.ctx.destination);
        this.noiseNode.start();
    }

    update(speed, isDrifting, isSlipSurface) {
        if (!this.ctx) return;

        // Engine Pitch
        const baseFreq = 80;
        this.engineOsc.frequency.setTargetAtTime(baseFreq + (Math.abs(speed) * 20), this.ctx.currentTime, 0.1);

        // Tire Noise Volume
        let skidVol = 0;
        if (Math.abs(speed) > 2) {
            if (isDrifting) skidVol = 0.3; // Louder drift
            else if (isSlipSurface && Math.abs(speed) > 5) skidVol = 0.2;
        }
        this.noiseGain.gain.setTargetAtTime(skidVol, this.ctx.currentTime, 0.1);
    }

    playCrash() {
        if (!this.ctx) return;
        const osc = this.ctx.createOscillator();
        osc.type = 'sawtooth';
        osc.frequency.value = 100;
        const gain = this.ctx.createGain();
        gain.gain.value = 0.3;

        osc.connect(gain);
        gain.connect(this.ctx.destination);

        osc.start();
        osc.frequency.exponentialRampToValueAtTime(10, this.ctx.currentTime + 0.3);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.3);
        osc.stop(this.ctx.currentTime + 0.3);
    }
}

const audio = new SoundManager();

/**
 * INITIALIZATION
 */
window.onload = () => {
    canvas = document.getElementById('game-canvas');
    ctx = canvas.getContext('2d');

    miniCanvas = document.getElementById('minimap-canvas');
    miniCtx = miniCanvas.getContext('2d');

    resize();
    window.addEventListener('resize', resize);

    initMap(100, 100);

    // Inputs
    window.addEventListener('keydown', e => {
        if(document.activeElement.tagName === 'INPUT') return;
        const k = e.key.toLowerCase();
        if(keys.hasOwnProperty(k)) keys[k] = true;
        if(e.key === 'Shift') keys.Shift = true;
        if(e.key === ' ') keys[" "] = true;
    });

    window.addEventListener('keyup', e => {
        const k = e.key.toLowerCase();
        if(keys.hasOwnProperty(k)) keys[k] = false;
        if(e.key === 'Shift') keys.Shift = false;
        if(e.key === ' ') keys[" "] = false;
    });

    document.getElementById('chat-input').addEventListener('keydown', e => {
        if (e.key === 'Enter') sendChatFunc();
    });

    // Editor Mouse Interaction
    canvas.addEventListener('mousedown', e => {
        if(!isEditorOpen) return;
        if(e.button === 0) mouse.leftDown = true;
        if(e.button === 2) mouse.rightDown = true;
        handleEditorInput(e);
    });
    window.addEventListener('mouseup', () => { mouse.leftDown = false; mouse.rightDown = false; });
    canvas.addEventListener('mousemove', e => {
        const rect = canvas.getBoundingClientRect();
        mouse.x = e.clientX - rect.left;
        mouse.y = e.clientY - rect.top;
        if(isEditorOpen && (mouse.leftDown || mouse.rightDown)) handleEditorInput(e);
    });
    canvas.addEventListener('contextmenu', e => e.preventDefault());

    loadSavedMapsList();
    requestAnimationFrame(gameLoop);
};

// Global exports
window.startGame = startGame;
window.toggleEditor = toggleEditor;
window.setTool = setTool;
window.shareMap = shareMap;
window.clearMap = clearMap;
window.applyMapSize = applyMapSize;
window.generateTerrain = generateTerrain;
window.openSaveMenu = openSaveMenu;
window.closeSaveMenu = closeSaveMenu;
window.saveCurrentMap = saveCurrentMap;

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}

function initMap(w, h) {
    mapWidth = w;
    mapHeight = h;
    mapData = new Array(mapWidth * mapHeight).fill(0);

    // Borders
    for(let x=0; x<mapWidth; x++) {
        setTile(x, 0, TILES.WALL, false);
        setTile(x, mapHeight-1, TILES.WALL, false);
    }
    for(let y=0; y<mapHeight; y++) {
        setTile(0, y, TILES.WALL, false);
        setTile(mapWidth-1, y, TILES.WALL, false);
    }
    setTile(10, 10, TILES.SPAWN, false);
    respawn();
    document.getElementById('map-w').value = mapWidth;
    document.getElementById('map-h').value = mapHeight;
}

/**
 * NETWORKING (Trystero)
 */
async function startGame() {
    audio.init(); // Start Audio Context on user gesture

    const nameInput = document.getElementById('username').value.trim() || "Racer";
    const roomInput = document.getElementById('room-name').value.trim().toLowerCase() || "lobby";
    const colorInput = document.getElementById('car-color').value;

    myCar.name = nameInput;
    myCar.color = colorInput;

    document.getElementById('connection-status').innerText = "Hashing Room...";

    const hashBuffer = await crypto.subtle.digest('SHA-256', new TextEncoder().encode(roomInput));
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    roomHash = "drift_v5_" + hashArray.map(b => b.toString(16).padStart(2, '0')).join('').substr(0, 16);

    document.getElementById('room-display').innerText = roomInput;
    document.getElementById('connection-status').innerText = "Joining Mesh...";

    initTrystero(roomHash);
}

function initTrystero(roomId) {
    const config = { appId: 'drift_racer_p2p_v5' };
    room = joinRoom(config, roomId);

    const [sndUp, getUp] = room.makeAction('pos');
    const [sndMap, getMap] = room.makeAction('map');
    const [sndChat, getChat] = room.makeAction('chat');
    const [sndKick, getKick] = room.makeAction('kick');
    const [sndTile, getTile] = room.makeAction('tile');

    sendUpdate = sndUp;
    sendMap = sndMap;
    sendChat = sndChat;
    sendKick = sndKick;
    sendTile = sndTile;

    getUp((data, peerId) => {
        if (!players[peerId]) {
            players[peerId] = { ...data, id: peerId, lastSeen: Date.now() };
            addSystemMessage(`${data.name} detected.`);
        } else {
            const p = players[peerId];
            p.x = data.x; // Direct sync for simplicity, could lerp
            p.y = data.y;
            p.angle = data.angle;
            p.speed = data.speed; // Visual only
            p.lastSeen = Date.now();
            if (p.color !== data.color) p.color = data.color;
            if (p.name !== data.name) p.name = data.name;
        }
    });

    getMap((data, peerId) => {
        addSystemMessage("Received map data.");
        if(data.w && data.h) {
            mapWidth = data.w;
            mapHeight = data.h;
        }
        loadMapData(data.data);
    });

    getChat((data, peerId) => {
        if (chatMuted.includes(data.name)) return;
        addChatMessage(data.name, data.text, data.color);
    });

    getKick((data, peerId) => {
        if (data.targetName === myCar.name) {
            alert("You have been kicked by the room.");
            room.leave();
            location.reload();
        }
    });

    getTile((data, peerId) => {
        setTile(data.x, data.y, data.val, false);
    });

    room.onPeerJoin(peerId => {
        addSystemMessage("Peer joined.");
        sendMap({ data: mapData, w: mapWidth, h: mapHeight }, peerId);
    });

    room.onPeerLeave(peerId => {
        if(players[peerId]) {
            addSystemMessage(`${players[peerId].name} left.`);
            delete players[peerId];
        }
    });

    isConnected = true;
    document.getElementById('main-menu').style.display = 'none';
    addSystemMessage(`Joined room! Welcome, ${myCar.name}.`);

    setInterval(broadcastUpdate, 50); // 20Hz update
}

function broadcastUpdate() {
    if (!isConnected || !sendUpdate) return;
    sendUpdate({
        name: myCar.name,
        color: myCar.color,
        x: Math.round(myCar.x),
        y: Math.round(myCar.y),
        angle: parseFloat(myCar.angle.toFixed(2)),
        speed: Math.round(myCar.speed)
    });
}

/**
 * PARTICLE SYSTEM
 */
class Particle {
    constructor(x, y, color, life, speed) {
        this.x = x;
        this.y = y;
        this.color = color;
        this.life = life;
        this.maxLife = life;
        const angle = Math.random() * Math.PI * 2;
        this.vx = Math.cos(angle) * speed;
        this.vy = Math.sin(angle) * speed;
    }
    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.life--;
    }
    draw(ctx) {
        ctx.globalAlpha = this.life / this.maxLife;
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x, this.y, 3, 3);
        ctx.globalAlpha = 1.0;
    }
}

function emitParticles(x, y, type) {
    let color = '#fff';
    let count = 1;
    if (type === 'smoke') { color = '#ddd'; count = 2; }
    if (type === 'dirt') { color = '#864'; count = 2; }
    if (type === 'grass') { color = '#484'; count = 2; }

    for(let i=0; i<count; i++) {
        particles.push(new Particle(x + (Math.random()*10-5), y + (Math.random()*10-5), color, 20 + Math.random()*20, 0.5));
    }
}

/**
 * GAME LOGIC & PHYSICS REWRITE
 */
function gameLoop() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Always update physics to allow moving while editing
    updatePhysics();

    // Camera follow
    camera.x = myCar.x - canvas.width / 2;
    camera.y = myCar.y - canvas.height / 2;

    ctx.save();
    ctx.translate(-camera.x, -camera.y);

    drawMap();

    // Draw Particles (behind cars)
    particles.forEach((p, i) => {
        p.update();
        p.draw(ctx);
        if(p.life <= 0) particles.splice(i, 1);
    });

    // Draw Players
    for (let id in players) {
        const p = players[id];
        // Simple interpolation
        drawCar(p);
        if (Date.now() - p.lastSeen > 15000) delete players[id];
    }

    drawCar(myCar);

    if(isEditorOpen) drawEditorCursor();

    ctx.restore();
    drawMinimap();

    requestAnimationFrame(gameLoop);
}

function updatePhysics() {
    // 1. Determine Surface
    const centerTile = getTile(Math.floor(myCar.x / TILE_SIZE), Math.floor(myCar.y / TILE_SIZE));
    let grip = 0.96; // Normal Grip (High)
    let drag = 0.98; // Rolling Resistance
    let surfaceType = 'pavement';

    switch(centerTile) {
        case TILES.GRASS: grip = 0.85; drag = 0.92; surfaceType='grass'; break;
        case TILES.DIRT: grip = 0.60; drag = 0.94; surfaceType='dirt'; break;
        case TILES.SAND: grip = 0.90; drag = 0.80; surfaceType='dirt'; break;
        case TILES.RUMBLE: grip = 0.98; drag = 0.97; break;
        default: break;
    }

    // FIX 2: Better Drift Logic
    if (keys[" "]) {
        grip = 0.15; // DRASTICALLY reduce grip for drift
        myCar.drifting = true;
    } else {
        myCar.drifting = false;
    }

    // 2. Input Forces
    if (keys.a) myCar.angle -= TURN_SPEED;
    if (keys.d) myCar.angle += TURN_SPEED;

    let accel = 0;
    if (keys.w) accel = ENGINE_POWER;
    if (keys.s) accel = -REVERSE_POWER;

    // Apply Acceleration Vector
    myCar.vx += Math.cos(myCar.angle) * accel;
    myCar.vy += Math.sin(myCar.angle) * accel;

    // 3. Apply Physics (Newtonian)
    const rightAngle = myCar.angle + Math.PI/2;
    // Velocity magnitude in the "right" direction (slipping)
    const lateralVelocity = myCar.vx * Math.cos(rightAngle) + myCar.vy * Math.sin(rightAngle);

    // If drifting, we kill LESS lateral velocity (allowing slide)
    // If not drifting, we kill MOST lateral velocity (grip)
    const lateralDamping = grip;

    // Apply friction to slide
    myCar.vx -= Math.cos(rightAngle) * lateralVelocity * lateralDamping;
    myCar.vy -= Math.sin(rightAngle) * lateralVelocity * lateralDamping;

    // Apply Drag (Forward Resistance)
    myCar.vx *= drag * DRAG_AIR;
    myCar.vy *= drag * DRAG_AIR;

    // 4. Update Position & Collision
    let nextX = myCar.x + myCar.vx;
    let nextY = myCar.y + myCar.vy;

    if (checkCollision(nextX, nextY)) {
        // Simple bounce
        myCar.vx *= -0.5;
        myCar.vy *= -0.5;
        nextX = myCar.x + myCar.vx;
        nextY = myCar.y + myCar.vy;
        audio.playCrash();
    } else {
        myCar.x = nextX;
        myCar.y = nextY;
    }

    // 5. Update State for Network/Audio/HUD
    myCar.speed = Math.sqrt(myCar.vx*myCar.vx + myCar.vy*myCar.vy);

    // FIX 3: Update HUD explicitly
    document.getElementById('speed-display').innerText = Math.floor(myCar.speed * 10);
    document.getElementById('pos-display').innerText = `${Math.floor(myCar.x)},${Math.floor(myCar.y)}`;

    // Audio Update
    const isSliding = Math.abs(lateralVelocity) > 2.0;
    audio.update(myCar.speed, myCar.drifting || isSliding, surfaceType !== 'pavement');

    // Particles
    if ((myCar.drifting || isSliding) && (Date.now() % 3 === 0)) {
        emitParticles(myCar.x, myCar.y, surfaceType === 'pavement' ? 'smoke' : surfaceType);
    } else if (myCar.speed > 2 && surfaceType !== 'pavement' && (Date.now() % 5 === 0)) {
        emitParticles(myCar.x, myCar.y, surfaceType);
    }
}

function checkCollision(x, y) {
    const r = 12; // Car radius
    const checks = [
        {x: x - r, y: y - r}, {x: x + r, y: y - r},
        {x: x - r, y: y + r}, {x: x + r, y: y + r}
    ];

    for (let p of checks) {
        const tx = Math.floor(p.x / TILE_SIZE);
        const ty = Math.floor(p.y / TILE_SIZE);
        if (getTile(tx, ty) === TILES.WALL) return true;
    }
    return false;
}

function drawCar(c) {
    ctx.save();
    ctx.translate(c.x, c.y);
    ctx.rotate(c.angle);

    ctx.fillStyle = c.color;
    ctx.shadowBlur = 10;
    ctx.shadowColor = c.color;
    ctx.fillRect(-15, -10, 30, 20); // Smaller body

    // Spoiler
    ctx.fillStyle = "#222";
    ctx.fillRect(-18, -11, 5, 22);

    // Windshield
    ctx.fillStyle = "#000";
    ctx.fillRect(-2, -8, 8, 16);

    // Headlights
    ctx.fillStyle = "#fff";
    ctx.shadowColor = "#fff";
    ctx.fillRect(14, -8, 2, 4);
    ctx.fillRect(14, 4, 2, 4);

    ctx.restore();

    ctx.fillStyle = "white";
    ctx.font = "10px Orbitron";
    ctx.textAlign = "center";
    ctx.shadowBlur = 0;
    ctx.fillText(c.name, c.x, c.y - 25);
}

/**
 * MAP SYSTEM
 */
function getTile(x, y) {
    if (x < 0 || x >= mapWidth || y < 0 || y >= mapHeight) return TILES.WALL;
    return mapData[y * mapWidth + x];
}

function setTile(x, y, val, emit = true) {
    if (x < 0 || x >= mapWidth || y < 0 || y >= mapHeight) return;
    const idx = y * mapWidth + x;
    mapData[idx] = val;
    if (emit && isConnected && sendTile) {
        sendTile({ x: x, y: y, val: val });
    }
}

function drawMap() {
    const startX = Math.floor(camera.x / TILE_SIZE);
    const startY = Math.floor(camera.y / TILE_SIZE);
    const endX = startX + Math.ceil(canvas.width / TILE_SIZE) + 1;
    const endY = startY + Math.ceil(canvas.height / TILE_SIZE) + 1;

    for (let y = startY; y < endY; y++) {
        for (let x = startX; x < endX; x++) {
            const t = getTile(x, y);
            const px = x * TILE_SIZE;
            const py = y * TILE_SIZE;

            // Draw Ground/Base
            if (t === TILES.PAVEMENT) {
                ctx.fillStyle = "#222"; // Asphalt
                ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
                ctx.strokeStyle = "#333";
                ctx.strokeRect(px, py, TILE_SIZE, TILE_SIZE);
            } else if (t === TILES.WALL) {
                ctx.fillStyle = "#445";
                ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
                ctx.fillStyle = "#000"; // Fake 3D top
                ctx.fillRect(px + 4, py + 4, TILE_SIZE - 8, TILE_SIZE - 8);
                ctx.strokeStyle = "var(--neon-blue)";
                ctx.lineWidth = 1;
                ctx.strokeRect(px, py, TILE_SIZE, TILE_SIZE);
            } else if (t === TILES.GRASS) {
                ctx.fillStyle = "#262";
                ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
                // Detail
                ctx.fillStyle = "#383";
                ctx.fillRect(px+5, py+5, 5, 5);
                ctx.fillRect(px+20, py+25, 5, 5);
            } else if (t === TILES.DIRT) {
                ctx.fillStyle = "#642";
                ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
            } else if (t === TILES.SAND) {
                ctx.fillStyle = "#da8";
                ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
            } else if (t === TILES.RUMBLE) {
                ctx.fillStyle = (x + y) % 2 === 0 ? "#e22" : "#eee"; // Red/White
                ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
            } else if (t === TILES.SPAWN) {
                ctx.fillStyle = ((x + y) % 2 === 0) ? "#fff" : "#000";
                ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
            }
        }
    }
}

function drawMinimap() {
    miniCtx.fillStyle = '#000';
    miniCtx.fillRect(0, 0, 200, 200);
    const scaleX = 200 / mapWidth;
    const scaleY = 200 / mapHeight;

    miniCtx.fillStyle = '#666';
    for(let i=0; i<mapData.length; i++) {
        if(mapData[i] === TILES.WALL) {
            const x = i % mapWidth;
            const y = Math.floor(i / mapWidth);
            miniCtx.fillRect(x * scaleX, y * scaleY, scaleX, scaleY);
        }
    }

    miniCtx.fillStyle = '#00f3ff';
    miniCtx.beginPath();
    miniCtx.arc((myCar.x/TILE_SIZE)*scaleX, (myCar.y/TILE_SIZE)*scaleY, 3, 0, Math.PI*2);
    miniCtx.fill();

    miniCtx.fillStyle = '#ff0055';
    for(let id in players) {
        const p = players[id];
        miniCtx.beginPath();
        miniCtx.arc((p.x/TILE_SIZE)*scaleX, (p.y/TILE_SIZE)*scaleY, 2, 0, Math.PI*2);
        miniCtx.fill();
    }
}

/**
 * EDITOR TOOLS
 */
function toggleEditor() {
    isEditorOpen = !isEditorOpen;
    document.getElementById('editor-ui').style.display = isEditorOpen ? 'flex' : 'none';
}

function setTool(t) {
    currentTool = t;
    document.querySelectorAll('.tool-btn').forEach((b, i) => {
        b.classList.toggle('active', i === t || (t===0 && i===1)); // Correct index map
    });
}

function handleEditorInput(e) {
    const worldX = mouse.x + camera.x;
    const worldY = mouse.y + camera.y;
    const tx = Math.floor(worldX / TILE_SIZE);
    const ty = Math.floor(worldY / TILE_SIZE);
    if (mouse.leftDown) setTile(tx, ty, currentTool);
    if (mouse.rightDown) setTile(tx, ty, TILES.PAVEMENT);
}

function drawEditorCursor() {
    const worldX = mouse.x + camera.x;
    const worldY = mouse.y + camera.y;
    const tx = Math.floor(worldX / TILE_SIZE);
    const ty = Math.floor(worldY / TILE_SIZE);
    ctx.strokeStyle = "yellow";
    ctx.lineWidth = 2;
    ctx.strokeRect(tx * TILE_SIZE, ty * TILE_SIZE, TILE_SIZE, TILE_SIZE);
}

function clearMap() {
    if(confirm("Clear map?")) {
        mapData.fill(0);
        shareMap();
    }
}

function applyMapSize() {
    const w = parseInt(document.getElementById('map-w').value);
    const h = parseInt(document.getElementById('map-h').value);
    if (w < 20 || h < 20 || w > 300 || h > 300) {
        alert("Size must be between 20 and 300"); return;
    }
    if(confirm("Resize? Clears data.")) {
        initMap(w, h);
        shareMap();
    }
}

function generateTerrain() {
    if(!confirm("Generate? Overwrites map.")) return;
    for(let i=0; i<mapData.length; i++) {
        let x = i % mapWidth;
        let y = Math.floor(i / mapWidth);
        if (x===0 || y===0 || x===mapWidth-1 || y===mapHeight-1) mapData[i] = TILES.WALL;
        else mapData[i] = Math.random() < 0.45 ? TILES.WALL : TILES.PAVEMENT;
    }
    for(let k=0; k<5; k++) {
        let newData = [...mapData];
        for(let y=1; y<mapHeight-1; y++) {
            for(let x=1; x<mapWidth-1; x++) {
                let neighbors = 0;
                for(let dy=-1; dy<=1; dy++) {
                    for(let dx=-1; dx<=1; dx++) {
                        if(dx===0 && dy===0) continue;
                        if(getTile(x+dx, y+dy) === TILES.WALL) neighbors++;
                    }
                }
                if (neighbors > 4) newData[y*mapWidth+x] = TILES.WALL;
                else if (neighbors < 4) newData[y*mapWidth+x] = TILES.PAVEMENT;
            }
        }
        mapData = newData;
    }
    // Grass patches
    for(let i=0; i<mapData.length; i++) {
        if(mapData[i] === TILES.PAVEMENT && Math.random() < 0.1) mapData[i] = TILES.GRASS;
    }
    setTile(10, 10, TILES.SPAWN, false);
    respawn();
    shareMap();
}

function respawn() {
    let spawnFound = false;
    myCar.vx = 0; myCar.vy = 0; myCar.speed = 0;
    for(let y=0; y<mapHeight; y++) {
        for(let x=0; x<mapWidth; x++) {
            if(getTile(x, y) === TILES.SPAWN) {
                myCar.x = x * TILE_SIZE + TILE_SIZE/2;
                myCar.y = y * TILE_SIZE + TILE_SIZE/2;
                spawnFound = true; break;
            }
        }
        if(spawnFound) break;
    }
    if(!spawnFound) { myCar.x = 200; myCar.y = 200; }
}

/**
 * SAVE/LOAD/SHARE/CHAT
 */
function openSaveMenu() {
    document.getElementById('maps-modal').style.display = 'flex';
    loadSavedMapsList();
}
function closeSaveMenu() { document.getElementById('maps-modal').style.display = 'none'; }

function saveCurrentMap() {
    const name = document.getElementById('map-save-name').value || "Untitled";
    const saveObj = {
        name: name,
        date: new Date().toLocaleDateString(),
        data: mapData, w: mapWidth, h: mapHeight
    };
    localStorage.setItem('drift_map_' + name, JSON.stringify(saveObj));
    loadSavedMapsList();
}

function loadSavedMapsList() {
    const list = document.getElementById('maps-list');
    list.innerHTML = "";
    for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key.startsWith('drift_map_')) {
            const val = JSON.parse(localStorage.getItem(key));
            const div = document.createElement('div');
            div.className = "flex justify-between items-center bg-gray-800 p-2 rounded";
            div.innerHTML = `<span>${val.name}</span>`;
            const btnLoad = document.createElement('button');
            btnLoad.innerText = "Load";
            btnLoad.className = "text-xs px-2 py-1 w-auto ml-2";
            btnLoad.onclick = () => {
                if (val.w) { mapWidth = val.w; mapHeight = val.h; }
                loadMapData(val.data); shareMap(); closeSaveMenu();
            };
            div.appendChild(btnLoad);
            list.appendChild(div);
        }
    }
}

function loadMapData(newData) {
    if(newData) { mapData = newData; respawn(); }
}
function shareMap() {
    if(!isConnected) { alert("Connect first!"); return; }
    if(sendMap) sendMap({ data: mapData, w: mapWidth, h: mapHeight });
}

function sendChatFunc() {
    const input = document.getElementById('chat-input');
    const text = input.value.trim();
    if (!text) return;
    if (text.startsWith('/')) { handleCommand(text); }
    else {
        if(sendChat) sendChat({ name: myCar.name, text: text, color: myCar.color });
        // Local Echo
        addChatMessage(myCar.name, text, myCar.color);
    }
    input.value = "";
}

function handleCommand(cmd) {
    const parts = cmd.split(' ');
    const action = parts[0];
    const target = parts[1];
    if (action === '/kick') {
        if(sendKick) { sendKick({ targetName: target }); addSystemMessage(`Kick vote: ${target}`); }
    } else if (action === '/mute') {
        chatMuted.push(target); addSystemMessage(`Muted ${target}.`);
    }
}

function addChatMessage(name, text, color) {
    const div = document.createElement('div');
    div.className = 'chat-msg';
    div.innerHTML = `<span style="color:${color}; font-weight:bold">${name}:</span> ${text}`;
    const container = document.getElementById('chat-messages');
    container.appendChild(div);
    container.scrollTop = container.scrollHeight;
}
function addSystemMessage(text) {
    const div = document.createElement('div');
    div.className = 'chat-msg sys-msg';
    div.innerText = `[SYS] ${text}`;
    const container = document.getElementById('chat-messages');
    container.appendChild(div);
    container.scrollTop = container.scrollHeight;
}
</script>
</body>
</html>

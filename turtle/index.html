<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Floating Turtles â€” grid obstacles</title>
  <style>
     html{
        user-select: none;
        -moz-user-select: none;
        -khtml-user-select: none;
        -webkit-user-select: none;
        -o-user-select: none;
     }
    .turtle {
      width: 500px;
      height: 500px;
      position: absolute;
      transform: scale(0.2);
      transform-origin: center center;
      z-index: 10;
    }
    .turtle__head {
      width: 75px; height: 85px; border-radius: 50%;
      background-color: #82C49F; position: relative;
      top: 22%; left: 50%; transform: translate(-50%, -50%);
      cursor: pointer; transition: top 0.3s ease-in-out; z-index: 4;
    }
    .turtle__head::before, .turtle__head::after {
      top: 20px; width: 8px; height: 8px; border-radius: 50%;
      background-color: #6A757A; content: ""; position: absolute;
    }
    .turtle__head::before { left: 13px; }
    .turtle__head::after  { right: 13px; }

    .turtle__shell {
      --shell-base: #6A757A; --shell-inner: #5D666B; --shell-plate: #636E72;
      width: 220px; height: 250px; background-color: var(--shell-base);
      border-radius: 50%; overflow: hidden; position: absolute;
      top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 5; cursor: grab;
    }
    .turtle__shell::before, .turtle__shell::after {
      content: ""; position: absolute; top: 50%; left: 50%;
    }
    .turtle__shell::before {
      width: 200px; height: 235px; background-color: var(--shell-inner);
      transform: translate(-50%, -50%); border-radius: 50%;
    }
    .turtle__shell::after {
      width: 50%; height: 100%; background-color: white; opacity: 0.1; top: 0;
    }
    .turtle__shell div {
      width: 120px; height: 80px; background: var(--shell-plate);
      position: relative; top: 50%; left: 50%; transform: translate(-50%, -50%);
    }
    .turtle__shell div::before, .turtle__shell div::after {
      content: ""; position: absolute; left: 0;
    }
    .turtle__shell div::before {
      top: -30px; border-left: 60px solid transparent; border-right: 60px solid transparent;
      border-bottom: 30px solid var(--shell-plate);
    }
    .turtle__shell div::after {
      bottom: -30px; border-left: 60px solid transparent; border-right: 60px solid transparent;
      border-top: 30px solid var(--shell-plate);
    }

    @keyframes rainbowCycle {
      0% { filter: hue-rotate(0deg) saturate(2) contrast(1.5); }
      100% { filter: hue-rotate(360deg) saturate(2) contrast(1.5); }
    }
    .rainbow { animation: rainbowCycle 8s linear infinite; }

    .turtle__tail {
      width: 0; height: 0; border-left: 8px solid transparent; border-right: 8px solid transparent;
      border-top: 35px solid #84C3A0; position: absolute; bottom: 18%; left: 50%;
      transform: translate(-50%, -50%); z-index: 3;
    }
    .turtle__legs {
      width: 30px; height: 300px; border-radius: 20%; background-color: #82C49F;
      position: absolute; top: 50%; left: 50%; z-index: 3;
    }
    .turtle__legs.-left  { transform: translate(-50%, -50%) rotate(-45deg); }
    .turtle__legs.-right { transform: translate(-50%, -50%) rotate(45deg); }
    .turtle.is-moving .turtle__legs.-left  { animation: walking-turtle-01 1.5s ease-in-out infinite alternate; }
    .turtle.is-moving .turtle__legs.-right { animation: walking-turtle-02 1.5s ease-in-out infinite alternate; }
    .turtle.is-retracted .turtle__head { top: 28%; }
    .turtle.neck-extend .turtle__head { top: 18%; }
    .turtle.is-dragging { z-index: 100; }
    .turtle.is-dragging .turtle__shell { cursor: grabbing; }

    .turtle-name {
      position: absolute; font-size: 14px; font-family: Arial, sans-serif; color: #333;
      background: rgba(255,255,255,0.7); padding: 2px 6px; border-radius: 6px;
      transform: translate(-50%, -100%); pointer-events: none; white-space: nowrap;
    }

    body {
      width: 100vw; height: 100vh; background-color: #ADD8E6; overflow: hidden;
      margin: 0; padding: 0; cursor: crosshair; font-family: 'Inter', sans-serif;
    }

    .food-pellet {
      position: absolute; width: 10px; height: 10px; background-color: #c27a3a;
      border: 2px solid #8f592a; border-radius: 50%; z-index: 1;
      transform: translate(-50%, -50%); pointer-events: none;
    }

    @keyframes walking-turtle-01 {
      0%   { transform: translate(-50%, -50%) rotate(-40deg); }
      25%  { transform: translate(-50%, -50%) rotate(-45deg); }
      50%  { transform: translate(-50%, -50%) rotate(-30deg); }
      75%  { transform: translate(-50%, -50%) rotate(-45deg); }
      100% { transform: translate(-50%, -50%) rotate(-40deg); }
    }
    @keyframes walking-turtle-02 {
      0%   { transform: translate(-50%, -50%) rotate(40deg); }
      25%  { transform: translate(-50%, -50%) rotate(45deg); }
      50%  { transform: translate(-50%, -50%) rotate(35deg); }
      75%  { transform: translate(-50%, -50%) rotate(45deg); }
      100% { transform: translate(-50%, -50%) rotate(30deg); }
    }

    /* Grid overlay */
    #grid {
      position: absolute;
      inset: 0;
      pointer-events: none; /* toggled to allow painting only with Shift */
      z-index: 2;
    }
    .grid-cell {
      position: absolute;
      box-sizing: border-box;
      border: 1px solid rgba(0,0,0,0.08);
      background: rgba(0,0,0,0.0);
    }
    .grid-cell.is-blocked {
      background: rgba(220, 60, 60, 0.25);
    }
  </style>
</head>
<body>

<script>
  // --- Global Setup ---
  let foodItems = [];
  let turtles = [];
  const margin = 25;

  // Grid settings (canvas-based)
  const GRID_SIZE = 40;
  const BLOCK_MARGIN = 80; // pixels
  const TURTLE_BODY_RADIUS = 30;
  let numGridX = 0, numGridY = 0;
  let gridBlocked = []; // boolean array
  let showLines = false;
  let gridCanvas, gridCtx;
  let painting = false;
  let paintToValue = null; // true/false based on first toggled cell

  // Keep your getSettings/personality code
  function getSettings() {
    const params = new URLSearchParams(window.location.search);
    return {
      rainbowChance: parseFloat(params.get('rainbowChance')) || 0,
      numTurtles: parseInt(params.get('count') || 5),
      sizeVariation: parseFloat(params.get('sizeVariation')) || 0.3,
      namesEnabled: params.get('namesEnabled') === 'true',
      turtleColors: (params.get('colors') || 'green,brown').split(',')
    };
  }
  const settings = getSettings();

  const PERSONALITIES = {
    default:   { idleChance: 0.0002, idleDuration: 300, minSpeed: 0.2, maxSpeed: 1.0, maxSeekSpeed: 3.0, visionDistance: 300, whiskerLength: 40 },
    shy:       { idleChance: 0.0005, idleDuration: 600, minSpeed: 0.1, maxSpeed: 0.8, maxSeekSpeed: 2.0, visionDistance: 200, whiskerLength: 50 },
    aggressive:{ idleChance: 0.0001, idleDuration: 100, minSpeed: 0.3, maxSpeed: 1.5, maxSeekSpeed: 4.0, visionDistance: 400, whiskerLength: 30 },
    lazy:      { idleChance: 0.001,  idleDuration: 1000,minSpeed: 0.1, maxSpeed: 0.5, maxSeekSpeed: 1.0, visionDistance: 150, whiskerLength: 40 }
  };

  function loadNames() { return JSON.parse(localStorage.getItem('turtleNames') || '[]'); }
  function saveNames(names) { localStorage.setItem('turtleNames', JSON.stringify(names)); }
  function loadPersonalities() { return JSON.parse(localStorage.getItem('turtlePersonalities') || '{}'); }
  function savePersonalities(p) { localStorage.setItem('turtlePersonalities', JSON.stringify(p)); }
  function clamp(num, min, max) { return Math.min(Math.max(num, min), max); }

  // --- Grid canvas initialization ---
  function initGridCanvas() {
    numGridX = Math.ceil(window.innerWidth / GRID_SIZE);
    numGridY = Math.ceil(window.innerHeight / GRID_SIZE);

    if (!gridCanvas) {
      gridCanvas = document.createElement('canvas');
      gridCanvas.id = 'grid-canvas';
      gridCanvas.style.position = 'absolute';
      gridCanvas.style.left = '0';
      gridCanvas.style.top = '0';
      gridCanvas.style.zIndex = '2';
      gridCanvas.style.display = 'block'; // hidden by default
      document.body.appendChild(gridCanvas);
      gridCtx = gridCanvas.getContext('2d');

      // Painting
      gridCanvas.addEventListener('mousedown', (e) => {
        if (!showLines) return;
        const { gx, gy } = screenToGrid(e.clientX, e.clientY);
        if (gx === null) return;
        painting = true;
        const current = gridBlocked[idx(gx, gy)];
        paintToValue = !current;
        gridBlocked[idx(gx, gy)] = paintToValue;
        drawGrid();
      });
      document.addEventListener('mousemove', (e) => {
        if (!painting || !showLines) return;
        const { gx, gy } = screenToGrid(e.clientX, e.clientY);
        if (gx === null) return;
        gridBlocked[idx(gx, gy)] = paintToValue;
        drawGrid();
      });
      document.addEventListener('mouseup', () => { painting = false; });
    }

    gridCanvas.width = window.innerWidth;
    gridCanvas.height = window.innerHeight;
    gridBlocked = new Array(numGridX * numGridY).fill(false);
  }
  function idx(gx, gy) { return gy * numGridX + gx; }

  function screenToGrid(sx, sy) {
    const gx = Math.floor(sx / GRID_SIZE);
    const gy = Math.floor(sy / GRID_SIZE);
    if (gx < 0 || gy < 0 || gx >= numGridX || gy >= numGridY) return { gx: null, gy: null };
    return { gx, gy };
  }

  function isBlockedWorld(wx, wy) {
    const gx = Math.floor(wx / GRID_SIZE);
    const gy = Math.floor(wy / GRID_SIZE);
    if (gx < 0 || gy < 0 || gx >= numGridX || gy >= numGridY) return true;
    if (!gridBlocked[idx(gx, gy)]) return false;

    // margin: treat near edges as blocked too
    const cx = gx * GRID_SIZE + GRID_SIZE/2;
    const cy = gy * GRID_SIZE + GRID_SIZE/2;
    const dist = Math.hypot(wx - cx, wy - cy);
    return dist < GRID_SIZE/2 + BLOCK_MARGIN;
  }

  function drawGrid() {
    gridCtx.clearRect(0, 0, gridCanvas.width, gridCanvas.height);

    // blocked cells always visible
    gridCtx.fillStyle = 'rgba(220,60,60,0.35)';
    for (let gx = 0; gx < numGridX; gx++) {
      for (let gy = 0; gy < numGridY; gy++) {
        if (gridBlocked[idx(gx, gy)]) {
          const cx = gx * GRID_SIZE + GRID_SIZE/2;
          const cy = gy * GRID_SIZE + GRID_SIZE/2;
          gridCtx.beginPath();
          gridCtx.arc(cx, cy, GRID_SIZE/1.2, 0, Math.PI*2);
          gridCtx.fill();
        }
      }
    }

    // grid lines only when editing
    if (showLines) {
      gridCtx.strokeStyle = 'rgba(0,0,0,0.08)';
      gridCtx.beginPath();
      for (let gx = 0; gx <= numGridX; gx++) {
        const x = gx * GRID_SIZE;
        gridCtx.moveTo(x, 0);
        gridCtx.lineTo(x, gridCanvas.height);
      }
      for (let gy = 0; gy <= numGridY; gy++) {
        const y = gy * GRID_SIZE;
        gridCtx.moveTo(0, y);
        gridCtx.lineTo(gridCanvas.width, y);
      }
      gridCtx.stroke();
    }
  }
  // --- Food class (unchanged) ---
  class Food {
    constructor(x, y) {
      this.x = x; this.y = y;
      this.element = document.createElement('div');
      this.element.className = 'food-pellet';
      this.element.style.left = `${x}px`;
      this.element.style.top  = `${y}px`;
      document.body.appendChild(this.element);
      foodItems.push(this);
    }
    remove() {
      if (this.element.parentNode) this.element.remove();
      foodItems = foodItems.filter(f => f !== this);
    }
  }

  // --- Turtle class (kept, with obstacle avoidance changed to grid-based) ---
  class Turtle {
    constructor(index) {
      this.element = document.createElement('main');
      this.scale = (0.2 * (0.8 + Math.random() * (settings.sizeVariation || 0))) || 0.2;
      this.element.className = 'turtle';
      this.element.innerHTML = `
        <div class="turtle__head"></div>
        <div class="turtle__legs -left"></div>
        <div class="turtle__legs -right"></div>
        <div class="turtle__tail"></div>
        <section class="turtle__shell"><div></div></section>
      `;
      this.headElement = this.element.querySelector('.turtle__head');
      this.shellElement = this.element.querySelector('.turtle__shell');
      if (Math.random() < settings.rainbowChance) this.shellElement.classList.add('rainbow');

      const types = Object.keys(PERSONALITIES);
      let nameList = loadNames();
      this.name = settings.namesEnabled ? (nameList[index] || `Turtle ${index+1}`) : null;
      let allPers = loadPersonalities();
      this.personalityType = settings.namesEnabled
        ? (allPers[this.name] || types[Math.floor(Math.random()*types.length)])
        : types[Math.floor(Math.random()*types.length)];
      if (settings.namesEnabled && !allPers[this.name]) { allPers[this.name] = this.personalityType; savePersonalities(allPers); }
      this.personality = PERSONALITIES[this.personalityType];

      if (settings.namesEnabled) {
        this.nameElement = document.createElement('div');
        this.nameElement.className = 'turtle-name';
        this.nameElement.textContent = `${this.name} (${this.personalityType})`;
        document.body.appendChild(this.nameElement);

        this.shellElement.addEventListener('dblclick', () => {
          const oldName = this.name;
          const newName = prompt('Enter turtle name:', this.name);
          if (newName && newName !== oldName) {
            const names = loadNames(); names[index] = newName; saveNames(names);
            const pers = loadPersonalities(); const p = pers[oldName];
            if (p) { delete pers[oldName]; pers[newName] = p; savePersonalities(pers); }
            this.name = newName;
            this.nameElement.textContent = `${this.name} (${this.personalityType})`;
          }
        });
      }

      this.x = Math.random() * window.innerWidth;
      this.y = Math.random() * window.innerHeight;
      this.rotation = Math.random() * 360;
      this.minSpeed = this.personality.minSpeed;
      this.maxSpeed = this.personality.maxSpeed;
      this.speed = this.minSpeed;
      this.rotationSpeed = (Math.random() - 0.5) * 1.0;
      this.idleTimer = 0;
      this.idleChance = this.personality.idleChance;
      this.idleDuration = this.personality.idleDuration;
      this.isBeingDragged = false;
      this.offsetX = 0; this.offsetY = 0;
      this.targetFood = null;

      document.body.appendChild(this.element);
      this.addListeners();
    }

    addListeners() {
      this.headElement.addEventListener('click', (e) => { e.stopPropagation(); this.retractHead(); });
      this.shellElement.addEventListener('mousedown', (e) => {
        e.stopPropagation(); this.isBeingDragged = true;
        this.element.classList.add('is-dragging');
        this.offsetX = e.clientX - this.x; this.offsetY = e.clientY - this.y;
      });
    }

    retractHead() {
      if (this.element.classList.contains('is-retracted')) return;
      this.element.classList.add('is-retracted');
      setTimeout(() => this.element.classList.remove('is-retracted'), 2000);
    }
    drag(e) { if (!this.isBeingDragged) return; this.x = e.clientX - this.offsetX; this.y = e.clientY - this.offsetY; }
    stopDrag() { this.isBeingDragged = false; this.element.classList.remove('is-dragging'); }

    getDX() { return Math.sin(this.rotation * Math.PI / 180) * this.speed; }
    getDY() { return -Math.cos(this.rotation * Math.PI / 180) * this.speed; }

    findFood() {
      if (this.targetFood) return;
      const visionDistance = this.personality.visionDistance;
      const visionAngle = 90;
      let closestFood = null; let minDistance = visionDistance;

      for (const food of foodItems) {
        const dx = food.x - this.x; const dy = food.y - this.y;
        const dist = Math.hypot(dx, dy);
        if (dist < minDistance) {
          let angleToFood = (Math.atan2(dy, dx) * 180 / Math.PI + 90 + 360) % 360;
          let angleDiff = Math.abs(this.rotation - angleToFood);
          if (angleDiff > 180) angleDiff = 360 - angleDiff;
          if (angleDiff < visionAngle / 2 && this.lineMostlyClear(this.x, this.y, food.x, food.y)) {
            minDistance = dist; closestFood = food;
          }
        }
      }
      if (closestFood) this.targetFood = closestFood;
    }

    lineMostlyClear(x1, y1, x2, y2) {
      const steps = Math.max(1, Math.ceil(Math.hypot(x2-x1, y2-y1) / GRID_SIZE));
      let blockedCount = 0;
      for (let i = 1; i < steps; i++) {
        const t = i / steps;
        const sx = x1 + (x2 - x1) * t;
        const sy = y1 + (y2 - y1) * t;
        if (isBlockedWorld(sx, sy)) blockedCount++;
        if (blockedCount > 2) return false;
      }
      return true;
    }

    wander() {
      if (Date.now() < this.navigationTimestamp) { return }
      if (this.idleTimer > 0) { this.idleTimer--; this.speed = 0; return; }
      if (Math.random() < this.idleChance) { this.idleTimer = Math.random() * this.idleDuration; this.speed = 0; return; }
      this.speed += (Math.random() - 0.45) * 0.1;
      this.speed = Math.max(this.minSpeed, Math.min(this.maxSpeed, this.speed));
      this.rotationSpeed += (Math.random() - 0.5) * 0.3;
      this.rotationSpeed = Math.max(-1.0, Math.min(1.0, this.rotationSpeed));
      this.rotation += this.rotationSpeed;
      if (this.rotation < 0) this.rotation += 360;
      if (this.rotation >= 360) this.rotation -= 360;
      this.x = clamp(this.x, margin, window.innerWidth - margin);
      this.y = clamp(this.y, margin, window.innerHeight - margin);
    }

    seekTarget() {
      if (!foodItems.includes(this.targetFood)) { this.targetFood = null; return; }
      const dx = this.targetFood.x - this.x; const dy = this.targetFood.y - this.y;
      const distance = Math.hypot(dx, dy);

      let targetAngle = (Math.atan2(dy, dx) * 180 / Math.PI + 90 + 360) % 360;
      let angleDiff = targetAngle - this.rotation;
      while (angleDiff < -180) angleDiff += 360;
      while (angleDiff > 180) angleDiff -= 360;

      const maxTurn = 2.0;
      this.rotation += Math.max(-maxTurn, Math.min(maxTurn, angleDiff));

      const arrivalRadius = 150;
      const maxSeekSpeed = this.personality.maxSeekSpeed;
      if (distance < arrivalRadius) {
        this.speed = (distance / arrivalRadius) * (maxSeekSpeed - this.minSpeed) + this.minSpeed;
      } else {
        this.speed += 0.05; this.speed = Math.min(this.speed, maxSeekSpeed);
      }

      if (distance < 30) {
        this.element.classList.add('neck-extend');
        setTimeout(() => this.element.classList.remove('neck-extend'), 200);
        this.targetFood.remove(); this.targetFood = null;
      }
    }

    avoidGridObstacles() {
      const look = this.personality.whiskerLength;
      const aheadX = this.x + Math.sin(this.rotation * Math.PI/180) * look;
      const aheadY = this.y - Math.cos(this.rotation * Math.PI/180) * look;

      if (isBlockedWorld(aheadX, aheadY)) {
        // check left and right directions
        this.navigationTimestamp=Date.now()+3000
        const leftRot = (this.rotation - 10 + 360) % 360;
        const rightRot = (this.rotation + 10) % 360;

        const leftX = this.x + Math.sin(leftRot * Math.PI/180) * look;
        const leftY = this.y - Math.cos(leftRot * Math.PI/180) * look;
        const rightX = this.x + Math.sin(rightRot * Math.PI/180) * look;
        const rightY = this.y - Math.cos(rightRot * Math.PI/180) * look;

        if (!isBlockedWorld(leftX, leftY)) {
          this.rotation = leftRot; // steer left
        } else if (!isBlockedWorld(rightX, rightY)) {
          this.rotation = rightRot; // steer right
        } else {
          this.rotation += 180; // dead end, turn around
        }

        this.speed = Math.max(this.minSpeed, this.speed * 0.85);
      }
    }


    update() {
      if (this.isBeingDragged) {
        this.element.classList.remove('is-moving');
        this.updateElementStyle(); return;
      }

      this.findFood();
      if (this.targetFood) this.seekTarget(); else this.wander();

      this.avoidGridObstacles();

      const nextX = this.x + this.getDX();
      const nextY = this.y + this.getDY();
      if (isBlockedWorld(nextX, nextY)) {
        this.speed = Math.max(this.minSpeed, this.speed * 0.85);
        this.rotation += 2;
      } else {
        this.x = nextX; this.y = nextY;
      }

      if (this.speed > this.minSpeed + 0.1) this.element.classList.add('is-moving');
      else this.element.classList.remove('is-moving');

      this.updateElementStyle();
    }

    updateElementStyle() {
      this.element.style.left = `${this.x}px`;
      this.element.style.top  = `${this.y}px`;
      this.element.style.transform = `translate(-50%, -50%) scale(${this.scale}) rotate(${this.rotation}deg)`;
      if (settings.namesEnabled) {
        this.nameElement.style.left = `${this.x}px`;
        this.nameElement.style.top  = `${this.y - (this.scale * 300)}px`;
      }
    }
  }
  
  // --- Global interactions ---
  document.addEventListener('mousemove', (e) => { turtles.forEach(t => t.drag(e)); });
  document.addEventListener('mouseup', () => { turtles.forEach(t => t.stopDrag()); });
  document.addEventListener('keydown', (e) => {
    if (e.key.toLowerCase() === 'q' && !e.repeat) {
    console.log('bruh',showLines)
      showLines = !showLines;
      drawGrid(showLines);
    }
  });



  // Click to add food (ignore when painting)
  document.addEventListener('click', (e) => {
    if (showLines) return;
    if (e.target === document.body || e.target.id === 'grid-canvas') {
      new Food(e.clientX, e.clientY);
    }
  });

  // --- Initialization ---
  for (let i = 0; i < settings.numTurtles; i++) {
    turtles.push(new Turtle(i));
  }
  initGridCanvas();

  function animate() {
    turtles.forEach(t => t.update());
    requestAnimationFrame(animate);
  }
  animate();

  window.addEventListener('resize', () => {
    initGridCanvas(); // rebuild canvas and preserve as much as possible
  });
</script>
</body>
</html>
